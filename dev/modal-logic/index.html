<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modal Logic · SoleLogics.jl</title><meta name="title" content="Modal Logic · SoleLogics.jl"/><meta property="og:title" content="Modal Logic · SoleLogics.jl"/><meta property="twitter:title" content="Modal Logic · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/modal-logic/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/modal-logic/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/modal-logic/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../base-logic/">Introduction to Logics and Propositional Logic</a></li><li class="is-active"><a class="tocitem" href>Modal Logic</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#modal-logic-pills"><span>Pills of Modal Logic</span></a></li><li><a class="tocitem" href="#why-modal-logic"><span>Why Modal Logic? An introduction</span></a></li><li><a class="tocitem" href="#modal-logic-worlds-and-frames"><span>Worlds and Frames</span></a></li><li><a class="tocitem" href="#modal-logic-relations"><span>Relations</span></a></li><li><a class="tocitem" href="#modal-logic-kripke-structures"><span>More on Frames and Kripke Structures</span></a></li><li><a class="tocitem" href="#modal-logic-connectives"><span>Modal Connectives</span></a></li><li><a class="tocitem" href="#modal-logic-relational-connectives"><span>Relational Connectives</span></a></li><li><a class="tocitem" href="#modal-logic-final-steps"><span>Final steps</span></a></li></ul></li><li><a class="tocitem" href="../many-valued-logics/">Many-valued logics</a></li><li><a class="tocitem" href="../more-on-formulas/">More on Formulas</a></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modal Logic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modal Logic</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/modal-logic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#modal-logic-introduction">Introduction</a></li><li><a href="#modal-logic-pills">Pills of Modal Logic</a></li><li class="no-marker"><ul><li><a href="#why-modal-logic">Why Modal Logic? An introduction</a></li><li><a href="#modal-logic-worlds-and-frames">Worlds and Frames</a></li><li><a href="#modal-logic-relations">Relations</a></li><li><a href="#modal-logic-kripke-structures">More on Frames and Kripke Structures</a></li><li><a href="#modal-logic-connectives">Modal Connectives</a></li><li><a href="#modal-logic-relational-connectives">Relational Connectives</a></li><li><a href="#modal-logic-final-steps">Final steps</a></li></ul></li></ul><h1 id="modal-logic-introduction"><a class="docs-heading-anchor" href="#modal-logic-introduction">Introduction</a><a id="modal-logic-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-introduction" title="Permalink"></a></h1><p>At the end of this chapter, you are going to understand what modal logic is, and why it is so important from a computational standpoint of view, with respect to propositional logic and first order logic. For those of you who want to fully immerse in the topic, we recommend reading the thesis <a href="https://eduardstan.github.io/assets/pdf/publications/theses/phd_thesis2023.pdf">Foundations of Modal Symbolic Learning</a>, by Stan Ionel Eduard. </p><p>Recalling the type hierarchy presented in <a href="../getting-started/#man-core">man-core</a>, it is here enriched with the following new types and structures.</p><ul><li><a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a><ul><li><a href="../base-logic/#SoleLogics.NamedConnective"><code>NamedConnective</code></a><ul><li><a href="#SoleLogics.DIAMOND"><code>DIAMOND</code></a></li><li><a href="#SoleLogics.BOX"><code>BOX</code></a></li></ul></li><li><a href="#SoleLogics.AbstractRelationalConnective"><code>AbstractRelationalConnective</code></a><ul><li><a href="#SoleLogics.DiamondRelationalConnective"><code>DiamondRelationalConnective</code></a></li><li><a href="@ref"><code>BoxRelationalConnective</code></a></li></ul></li></ul></li><li><a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a><ul><li><a href="#SoleLogics.World"><code>World</code></a></li></ul></li><li><a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a><ul><li><a href="#SoleLogics.AbstractUniModalFrame"><code>AbstractUniModalFrame</code></a></li><li><a href="#SoleLogics.AbstractMultiModalFrame"><code>AbstractMultiModalFrame</code></a></li><li><a href="@ref"><code>WrapperMultiModalFrame</code></a></li></ul></li><li><a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a></li><li><a href="../getting-started/#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a><ul><li><a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a><ul><li><a href="#SoleLogics.KripkeStructure"><code>KripkeStructure</code></a></li></ul></li></ul></li></ul><h1 id="modal-logic-pills"><a class="docs-heading-anchor" href="#modal-logic-pills">Pills of Modal Logic</a><a id="modal-logic-pills-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-pills" title="Permalink"></a></h1><p>Narrowly speaking, modal logic was initially investigated as the logic of <em>necessary</em> and <em>possible</em> truths judgments due to Aristotle&#39;s foresighted analysis of statements containing the words &quot;necessary&quot; and &quot;possible&quot;.</p><p>Modal logic is, essentially, Propositional Logic enriched with a set of <em>modal connectives</em> (or <em>modalities</em>), that are used to express some form of quantification over a set of <em>entities</em>. Interpretations in modal logic act as directed, possibly many-relation <em>graphs of propositional assigments</em>, and are called <em>Kripke structures</em>. The vertices in the graph model the entities, and are called <em>possible worlds</em> (or, simply, <em>worlds</em>). Furthermore, worlds are connected via one or more <em>accessibility</em> relations, and each world has a propositional assignment. Modal formula are, generally, interpreted on specific worlds of Kripke structures.</p><h2 id="why-modal-logic"><a class="docs-heading-anchor" href="#why-modal-logic">Why Modal Logic? An introduction</a><a id="why-modal-logic-1"></a><a class="docs-heading-anchor-permalink" href="#why-modal-logic" title="Permalink"></a></h2><p>Very often real-world applications give rise to non-static sets of data (e.g., temporal, spatial, graph-based data). The standard approach is to pre-process such data, so that their aspect becomes easy to fit in a tabular structure (e.g., datasets, spreadsheets).</p><p>Pre-processing non-static data means <em>denaturing it</em>: we want to deal with this kind of data <em>natively</em>, avoiding losing valuable information about its structure. Because of this, we require a logic which is more expressive than propositional one. This is where modal logic comes in.</p><p>Imagine the following scenario: you have a speech audio sample of <span>$9$</span> seconds and you want to establish whether the propositional letter <span>$p$</span> is true or no on the sample. Let&#39;s say that <span>$p$</span> is the fact <em>the audio is loud</em>. The latter is referred to the sample in its entirety: by looking at it <em>as a whole</em> we can compute whether <span>$p$</span> is true or no. Let&#39;s say that <span>$p$</span> is true. We can easily schematize the situation by just drawing a graph with a single node containing <span>$p$</span>, where the node is the entire audio.</p><p><img src="../assets/p_world.png" alt="A single node, where p is true"/></p><p>This single node above is what we call world, and it is exactly a propositional model. We can represent it as follows.</p><pre><code class="language-julia hljs">p = Atom(&quot;p&quot;) # &quot;the audio is loud&quot;
world = SoleLogics.World(1) # this is just an abstract reference to a 9s audio sample

# ... calculations here ...

valuation = Dict([world =&gt; TruthDict(p =&gt; true)]) # after some calculations, we establish &quot;p&quot; is true in &quot;world&quot;</code></pre><p>Now here&#39;s a challenge. Try to express the following fact using just propositional logic: <em>the audio contains at least two pauses of three seconds that are interspersed with each other by three or more seconds of loud speaking</em>. After a few tries you should be convinced that this is not possible, because through propositional logic we are not able to <em>quantify over relations <strong>inside</strong> the sample</em>. What we can do instead, is upgrade propositional logic to modal logic. We have to deal in a more granular manner with the original audio sample, and we don&#39;t want to denature it. Here is what we need:</p><ul><li>an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> <span>$p$</span>, representing the fact <em>the audio is loud</em>;</li><li>an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> <span>$q$</span>, representing the fact <em>the audio is silence</em>;</li><li><a href="#SoleLogics.World"><code>World</code></a>s describing small pieces of the original audio. In particular, we establish that each world is representative for <span>$3$</span> seconds of audio;</li><li>an accessibility relation (a specific <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>) to express which worlds are reachable from another through a modal <a href="../base-logic/#SoleLogics.NamedConnective"><code>NamedConnective</code></a>. </li></ul><p>The situation is simply schematized as follows</p><p><img src="../assets/time_serie.png" alt="A Kripke Model, representing a time serie"/></p><p>where each world identifies <span>$3$</span> seconds of audio, and we consider a relation between two worlds only if they represent adjacent parts of the audio. At this point, let&#39;s create the Kripke structure in the example using SoleLogics.jl.</p><pre><code class="language-julia hljs">p = Atom(&quot;p&quot;) # &quot;the audio is loud&quot;
q = Atom(&quot;q&quot;) # &quot;the audio is silence&quot;

# Worlds representing 3-second-pieces of the original audio
worlds = [SoleLogics.World(1), SoleLogics.World(2), SoleLogics.World(3)]
edges = Edge.([(1,2), (1,3), (2,3)])
kripkeframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))

valuation = Dict([worlds[1] =&gt; TruthDict([p =&gt; false, q =&gt; true]), worlds[2] =&gt; TruthDict([p =&gt; true, q =&gt; false]), worlds[3] =&gt; TruthDict([p =&gt; false, q =&gt; true])])

kripkestructure = KripkeStructure(kripkeframe, valuation)</code></pre><p>In the Kripke structure above, the central world <span>$w_2$</span> (the only one where <span>$p$</span> is true) is accessible from the leftmost world <span>$w_1$</span> (where <span>$q$</span> is true). In modal logic terms, this is expressed by the notation</p><p class="math-container">\[K,w_1 \models \lozenge p\]</p><p>where <span>$K$</span> is a Kripke structure, <span>$w_1$</span> is the leftmost world in the image, and <span>$\lozenge p$</span> means <em>look at the world accessibles from <span>$w_1$</span> and check whether p is true or false on those neighbors</em>.</p><p>Now we are ready to resume the long statement of a few paragraphs ago, the one we could not express using only propositional logic. We can translate it using modal logic! The formula we are looking for is </p><p class="math-container">\[q \wedge \lozenge p \wedge \lozenge \lozenge q\]</p><p>which has to be read <em>check whether this sub-sample of audio is silence, and the sub-sample after this is loud, and the sub-sample after the latter is silence again</em>. Let&#39;s see if this formula is true on the Kripke model above, starting from <span>$w_1$</span>.</p><pre><code class="language-julia hljs"># ... continuing code above ...

phi = ∧(q, ∧(◊(p),◊(◊(q)))) # \wedge+TAB can also be written as CONJUNCTION, while \lozenge+TAB is called DIAMOND and is a modal operator

check(phi, kripkestructure, worlds[1]) # prints true</code></pre><p>By reading the following sections, you will better grasp how <a href="#SoleLogics.World"><code>World</code></a>s are defined, as well as relations (<a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>), how those two concepts are bound togheter in <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>s and <a href="#SoleLogics.KripkeStructure"><code>KripkeStructure</code></a>s. You will also understand how to access one world from another by using (or implementing) <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s such as <a href="@ref"><code>◊</code></a> (or <a href="#SoleLogics.DIAMOND"><code>DIAMOND</code></a>) and the <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld"><code>accessibles</code></a> method.</p><h2 id="modal-logic-worlds-and-frames"><a class="docs-heading-anchor" href="#modal-logic-worlds-and-frames">Worlds and Frames</a><a id="modal-logic-worlds-and-frames-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-worlds-and-frames" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractWorld" href="#SoleLogics.AbstractWorld"><code>SoleLogics.AbstractWorld</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractWorld end</code></pre><p>Abstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to <em>worlds</em>, that is, nodes of a graph.</p><p><strong>Implementing</strong></p><p>When implementing a new world type, the logical semantics should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.World" href="#SoleLogics.World"><code>SoleLogics.World</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct World{T} &lt;: AbstractWorld
    name::T
end</code></pre><p>A world that is solely identified by its <code>name</code>. This can be useful when instantiating the underlying graph of a modal frame in an explicit way.</p><p>See also <a href="@ref"><code>OneWorld</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractFrame" href="#SoleLogics.AbstractFrame"><code>SoleLogics.AbstractFrame</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractFrame{W&lt;:AbstractWorld} end</code></pre><p>Abstract type for an accessibility graph (Kripke frame), that gives the topology to <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>. A frame can be queried for its set of vertices (also called <em>worlds</em>, see <a href="#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W&lt;:AbstractWorld"><code>allworlds</code></a>), and it can be browsed via its accessibility relation(s) (see <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld"><code>accessibles</code></a>). Refer to <a href="@ref"><code>FullDimensionalFrame</code></a> as an example.</p><p>See also <a href="../base-logic/#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><code>truthtype</code></a>, , <a href="#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W&lt;:AbstractWorld"><code>allworlds</code></a>, <a href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W&lt;:AbstractWorld" href="#SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W&lt;:AbstractWorld"><code>SoleLogics.worldtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">worldtype(fr::AbstractFrame)
worldtype(i::AbstractKripkeStructure)</code></pre><p>Return the world type of the Kripke frame/structure.</p><p>See also <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L40-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W&lt;:AbstractWorld" href="#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W&lt;:AbstractWorld"><code>SoleLogics.allworlds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allworlds(fr::AbstractFrame{W})::AbstractVector{&lt;:W} where {W&lt;:AbstractWorld}</code></pre><p>Return all worlds within the frame.</p><p>See also <a href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}" href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>SoleLogics.nworlds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nworlds(fr::AbstractFrame)::Integer</code></pre><p>Return the number of worlds within the frame.</p><p>See also <a href="#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}"><code>nworlds</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L62-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractUniModalFrame" href="#SoleLogics.AbstractUniModalFrame"><code>SoleLogics.AbstractUniModalFrame</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractUniModalFrame{W&lt;:AbstractWorld} &lt;: AbstractFrame{W} end</code></pre><p>A frame of a modal logic based on a single (implicit) accessibility relation.</p><p>See also <a href="#SoleLogics.AbstractMultiModalFrame"><code>AbstractMultiModalFrame</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld" href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld"><code>SoleLogics.accessibles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractUniModalFrame"><code>AbstractUniModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L86-L92">source</a></section></article><h2 id="modal-logic-relations"><a class="docs-heading-anchor" href="#modal-logic-relations">Relations</a><a id="modal-logic-relations-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-relations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractRelation" href="#SoleLogics.AbstractRelation"><code>SoleLogics.AbstractRelation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRelation end</code></pre><p>Abstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are <code>identityrel</code> and <code>globalrel</code>, which access the current world and all worlds, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>When implementing a new relation type <code>R</code>, please provide the methods:</p><pre><code class="nohighlight hljs">arity(::R)::Int = ...
syntaxstring(::R; kwargs...)::String = ...</code></pre><p>If the relation is symmetric, please specify its converse relation <code>cr</code> with:</p><pre><code class="nohighlight hljs">hasconverse(::R) = true
converse(::R) = cr</code></pre><p>If the relation is many-to-one or one-to-one, please flag it with:</p><pre><code class="nohighlight hljs">istoone(::R) = true</code></pre><p>If the relation is reflexive or transitive, flag it with:</p><pre><code class="nohighlight hljs">isreflexive(::R) = true
istransitive(::R) = true</code></pre><p>Most importantly, the logical semantics for <code>R</code> should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="../getting-started/#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>, <a href="#SoleLogics.converse-Tuple{AbstractRelation}"><code>converse</code></a>, <a href="@ref"><code>hasconverse</code></a>, <a href="#SoleLogics.istoone-Tuple{AbstractRelation}"><code>istoone</code></a>, <a href="@ref"><code>identityrel</code></a>, <a href="@ref"><code>globalrel</code></a>, <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld"><code>accessibles</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>, <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L101-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.arity-Tuple{AbstractRelation}" href="#SoleLogics.arity-Tuple{AbstractRelation}"><code>SoleLogics.arity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arity(::AbstractRelation)::Integer</code></pre><p>Return the <code>arity</code> of the relation.</p><p>See also <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.converse-Tuple{AbstractRelation}" href="#SoleLogics.converse-Tuple{AbstractRelation}"><code>SoleLogics.converse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hasconverse(r::AbstractRelation)::Bool
converse(r::AbstractRelation)::AbstractRelation</code></pre><p>If the relation <code>hasconverse</code>, return the converse relation (type) of a given relation (type).</p><p>See also <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L188-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.istoone-Tuple{AbstractRelation}" href="#SoleLogics.istoone-Tuple{AbstractRelation}"><code>SoleLogics.istoone</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istoone(r::AbstractRelation) = false</code></pre><p>Return whether it is known that a relation is istoone.</p><p>See also <a href="@ref"><code>hasconverse</code></a>, <a href="#SoleLogics.converse-Tuple{AbstractRelation}"><code>converse</code></a>, <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L193-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.issymmetric-Tuple{AbstractRelation}" href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>SoleLogics.issymmetric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issymmetric(r::AbstractRelation) = hasconverse(r) ? converse(r) == r : false</code></pre><p>Return whether it is known that a relation is symmetric.</p><p>See also <a href="@ref"><code>hasconverse</code></a>, <a href="#SoleLogics.converse-Tuple{AbstractRelation}"><code>converse</code></a>, <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L203-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.isreflexive-Tuple{AbstractRelation}" href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>SoleLogics.isreflexive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isreflexive(::AbstractRelation)</code></pre><p>Return whether it is known that a relation is reflexive.</p><p>See also <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.istransitive-Tuple{AbstractRelation}" href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>SoleLogics.istransitive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istransitive(::AbstractRelation)</code></pre><p>Return whether it is known that a relation is transitive.</p><p>See also <a href="#SoleLogics.istoone-Tuple{AbstractRelation}"><code>istoone</code></a>, <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.isgrounding-Tuple{AbstractRelation}" href="#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>SoleLogics.isgrounding</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isgrounding(::AbstractRelation)</code></pre><p>Return whether it is known that a relation is grounding. A relation <code>R</code> is grounding if ∀x,z,y R(x,y) ⇔ R(z,y).</p><p>See also <a href="#SoleLogics.isreflexive-Tuple{AbstractRelation}"><code>isreflexive</code></a>, <a href="#SoleLogics.issymmetric-Tuple{AbstractRelation}"><code>issymmetric</code></a>, <a href="#SoleLogics.istransitive-Tuple{AbstractRelation}"><code>istransitive</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L233-L241">source</a></section></article><h2 id="modal-logic-kripke-structures"><a class="docs-heading-anchor" href="#modal-logic-kripke-structures">More on Frames and Kripke Structures</a><a id="modal-logic-kripke-structures-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-kripke-structures" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractMultiModalFrame" href="#SoleLogics.AbstractMultiModalFrame"><code>SoleLogics.AbstractMultiModalFrame</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMultiModalFrame{W&lt;:AbstractWorld} &lt;: AbstractFrame{W} end</code></pre><p>A frame of a multi-modal logic, that is, a modal logic based on a set of accessibility relations.</p><p><strong>Implementation</strong></p><p>When implementing a new multi-modal frame type, the logical semantics for the frame should be defined via <code>accessibles</code> methods; refer to the help for <code>accessibles</code>.</p><p>See also <a href="#SoleLogics.AbstractUniModalFrame"><code>AbstractUniModalFrame</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L248-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld" href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W&lt;:AbstractWorld"><code>SoleLogics.accessibles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation
) where {W&lt;:AbstractWorld}</code></pre><p>Return the worlds in frame <code>fr</code> that are accessible from world <code>w</code> via relation <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fr = SoleLogics.FullDimensionalFrame((10,),);

julia&gt; typeof(accessibles(fr, Interval(2,5), IA_L))
Base.Generator{...}

julia&gt; typeof(accessibles(fr, globalrel))
Base.Generator{...}

julia&gt; @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))

julia&gt; typeof(accessibles(fr, Interval(2,5), identityrel))
Vector{Interval{Int64}}

julia&gt; Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))
true</code></pre><p><strong>Implementation</strong></p><p>Since <code>accessibles</code> always returns an iterator of worlds of the same type <code>W</code>, the current implementation of <code>accessibles</code> for multi-modal frames delegates the enumeration to a lower level <code>_accessibles</code> function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:</p><pre><code class="nohighlight hljs">function accessibles(
    fr::AbstractMultiModalFrame{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    IterTools.imap(W, _accessibles(fr, w, r))
end</code></pre><p>As such, when defining new frames, worlds, and/or relations, one should provide new methods for <code>_accessibles</code>. For example:</p><pre><code class="nohighlight hljs">_accessibles(fr::Full1DFrame, w::Interval{&lt;:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)</code></pre><p>This pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type <code>FR{W}</code>, one can resolve the ambiguities and define a custom <code>accessibles</code> method by providing these three methods:</p><pre><code class="nohighlight hljs"># access worlds through relation `r`
function accessibles(
    fr::FR{W},
    w::W,
    r::AbstractRelation,
) where {W&lt;:AbstractWorld}
    ...
end

# access current world
function accessibles(
    fr::FR{W},
    w::W,
    r::IdentityRel,
) where {W&lt;:AbstractWorld}
    [w]
end

# access all worlds
function accessibles(
    fr::FR{W},
    w::W,
    r::GlobalRel,
) where {W&lt;:AbstractWorld}
    allworlds(fr)
end</code></pre><p>In general, it should be true that <code>collect(accessibles(fr, w, r)) isa AbstractWorlds{W}</code>.</p><p>See also <a href="#SoleLogics.AbstractWorld"><code>AbstractWorld</code></a>, <a href="#SoleLogics.AbstractRelation"><code>AbstractRelation</code></a>, <a href="#SoleLogics.AbstractMultiModalFrame"><code>AbstractMultiModalFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L263-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractKripkeStructure" href="#SoleLogics.AbstractKripkeStructure"><code>SoleLogics.AbstractKripkeStructure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractKripkeStructure &lt;: AbstractInterpretation end</code></pre><p>Abstract type for representing <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>&#39;s. It comprehends a directed graph structure (Kripke frame), where nodes are referred to as <em>worlds</em>, and the binary relation between them is referred to as the <em>accessibility relation</em>. Additionally, each world is associated with a mapping from <code>Atom</code>s to <code>Truth</code> values.</p><p>See also <a href="@ref"><code>frame</code></a>, <a href="#SoleLogics.worldtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W&lt;:AbstractWorld"><code>worldtype</code></a>, <a href="#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W&lt;:AbstractWorld"><code>accessibles</code></a>, <a href="../getting-started/#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L368-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.check-Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure, Any}" href="#SoleLogics.check-Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure, Any}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    i::AbstractInterpretation,
    args...;
    kwargs...
)::Bool</code></pre><p>Check a formula on a logical interpretation (or model), returning <code>true</code> if the truth value for the formula <code>istop</code>. This process is referred to as (finite) <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>, and there are many algorithms for it, typically depending on the complexity of the logic.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; td = TruthDict([p =&gt; TOP, q =&gt; BOT])
TruthDict with values:
┌────────┬────────┐
│      q │      p │
│ String │ String │
├────────┼────────┤
│      ⊥ │      ⊤ │
└────────┴────────┘

julia&gt; check(CONJUNCTION(p,q), td)
false</code></pre><p>See also <a href="../getting-started/#SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>interpret</code></a>, <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>, <a href="../getting-started/#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>, <a href="../base-logic/#SoleLogics.TruthDict"><code>TruthDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/interpretation.jl#L110-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.KripkeStructure" href="#SoleLogics.KripkeStructure"><code>SoleLogics.KripkeStructure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct KripkeStructure{
    FR&lt;:AbstractFrame,
    MAS&lt;:AbstractDict
} &lt;: AbstractKripkeStructure
    frame::FR
    assignment::AS
end</code></pre><p>Type for representing <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structures</a>. explicitly; it wraps a <code>frame</code>, and an abstract dictionary that assigns an interpretation to each world.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L422-L435">source</a></section></article><h2 id="modal-logic-connectives"><a class="docs-heading-anchor" href="#modal-logic-connectives">Modal Connectives</a><a id="modal-logic-connectives-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-connectives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ismodal-Tuple{Type{&lt;:Connective}}" href="#SoleLogics.ismodal-Tuple{Type{&lt;:Connective}}"><code>SoleLogics.ismodal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ismodal(::Type{&lt;:Connective})::Bool = false
ismodal(c::Connective)::Bool = ismodal(typeof(c))</code></pre><p>Return whether it is known that an <code>Connective</code> is modal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ismodal(◊)
true

julia&gt; ismodal(∧)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L427-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.isbox-Tuple{Type{&lt;:Connective}}" href="#SoleLogics.isbox-Tuple{Type{&lt;:Connective}}"><code>SoleLogics.isbox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbox(::Type{&lt;:Connective})::Bool = false
isbox(c::Connective)::Bool = isbox(typeof(c))</code></pre><p>Return whether it is known that an <code>Connective</code> is a box (i.e., universal) connective.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SoleLogics.isbox(◊)
false

julia&gt; SoleLogics.isbox(∧)
false

julia&gt; SoleLogics.isbox(□)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L446-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.DIAMOND" href="#SoleLogics.DIAMOND"><code>SoleLogics.DIAMOND</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DIAMOND = NamedConnective{:◊}()
const ◊ = DIAMOND
ismodal(::typeof(◊)) = true
arity(::typeof(◊)) = 1</code></pre><p>Logical diamond connective, typically interpreted as the modal existential quantifier. See <a href="https://en.wikipedia.org/wiki/Modal_operator">here</a>.</p><p>See also <a href="#SoleLogics.BOX"><code>BOX</code></a>, <a href="../base-logic/#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L469-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.BOX" href="#SoleLogics.BOX"><code>SoleLogics.BOX</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const BOX = NamedConnective{:□}()
const □ = BOX
arity(::typeof(□)) = 1</code></pre><p>Logical box connective, typically interpreted as the modal universal quantifier. See <a href="https://en.wikipedia.org/wiki/Modal_operator">here</a>.</p><p>See also <a href="#SoleLogics.DIAMOND"><code>DIAMOND</code></a>, <a href="../base-logic/#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L489-L498">source</a></section></article><h2 id="modal-logic-relational-connectives"><a class="docs-heading-anchor" href="#modal-logic-relational-connectives">Relational Connectives</a><a id="modal-logic-relational-connectives-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-relational-connectives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractRelationalConnective" href="#SoleLogics.AbstractRelationalConnective"><code>SoleLogics.AbstractRelationalConnective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractRelationalConnective{R&lt;:AbstractRelation} &lt;: Connective end</code></pre><p>Abstract type for relational logical connectives. A relational connective allows for semantic quantification across relational structures (e.g., Kripke structures). It has arity equal to the arity of its underlying relation minus one.</p><p>See, for example <a href="https://en.wikipedia.org/wiki/Temporal_logic">temporal modal logic</a>.</p><p>See also <a href="#SoleLogics.DiamondRelationalConnective"><code>DiamondRelationalConnective</code></a>, <a href="@ref"><code>BoxRelationalConnective</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L476-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.relationtype-Union{Tuple{SoleLogics.AbstractRelationalConnective{R}}, Tuple{R}} where R&lt;:AbstractRelation" href="#SoleLogics.relationtype-Union{Tuple{SoleLogics.AbstractRelationalConnective{R}}, Tuple{R}} where R&lt;:AbstractRelation"><code>SoleLogics.relationtype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relationtype(::AbstractRelationalConnective{R}) where {R&lt;:AbstractRelation} = R
relation(op::AbstractRelationalConnective) = relationtype(op)()</code></pre><p>Return the underlying relation (and relation type) of the relational connective.</p><p>See also <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L499-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.DiamondRelationalConnective" href="#SoleLogics.DiamondRelationalConnective"><code>SoleLogics.DiamondRelationalConnective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DiamondRelationalConnective{R&lt;:AbstractRelation} &lt;: AbstractRelationalConnective{R} end
struct BoxRelationalConnective{R&lt;:AbstractRelation} &lt;: AbstractRelationalConnective{R} end</code></pre><p>Singleton types for relational connectives, typically interpreted as the modal existential and universal quantifier, respectively.</p><p>Both connectives can be easily instantiated with relation instances, such as <code>DiamondRelationalConnective(rel)</code>, which is a shortcut for <code>DiamondRelationalConnective{typeof(rel)}()</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(DiamondRelationalConnective(IA_A))
&quot;⟨A⟩&quot;

julia&gt; syntaxstring(BoxRelationalConnective(IA_A))
&quot;[A]&quot;

julia&gt; @assert DiamondRelationalConnective(IA_A) == SoleLogics.dual(BoxRelationalConnective(IA_A))
</code></pre><p>See also <a href="#SoleLogics.DiamondRelationalConnective"><code>DiamondRelationalConnective</code></a>, <a href="@ref"><code>BoxRelationalConnective</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>, <a href="../getting-started/#SoleLogics.dual-Tuple{SyntaxToken}"><code>dual</code></a>, <a href="#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L593-L620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.diamond-Tuple{}" href="#SoleLogics.diamond-Tuple{}"><code>SoleLogics.diamond</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diamond() = DIAMOND
diamond(r::AbstractRelation) = DiamondRelationalConnective(r)</code></pre><p>Return either the diamond modal connective from unimodal logic (i.e., ◊), or a a diamond relational connective from a multi-modal logic, wrapping the relation <code>r</code>.</p><p>See also <a href="#SoleLogics.DiamondRelationalConnective"><code>DiamondRelationalConnective</code></a>, <a href="#SoleLogics.diamond-Tuple{}"><code>diamond</code></a>, <a href="#SoleLogics.DIAMOND"><code>DIAMOND</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L637-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.box-Tuple{}" href="#SoleLogics.box-Tuple{}"><code>SoleLogics.box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">box() = BOX
box(r::AbstractRelation) = BoxRelationalConnective(r)</code></pre><p>Return either the box modal connective from unimodal logic (i.e., □), or a a box relational connective from a multi-modal logic, wrapping the relation <code>r</code>.</p><p>See also <a href="@ref"><code>BoxRelationalConnective</code></a>, <a href="#SoleLogics.box-Tuple{}"><code>box</code></a>, <a href="#SoleLogics.BOX"><code>BOX</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L649-L657">source</a></section></article><h2 id="modal-logic-final-steps"><a class="docs-heading-anchor" href="#modal-logic-final-steps">Final steps</a><a id="modal-logic-final-steps-1"></a><a class="docs-heading-anchor-permalink" href="#modal-logic-final-steps" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.modallogic-Tuple{}" href="#SoleLogics.modallogic-Tuple{}"><code>SoleLogics.modallogic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modallogic(;
    alphabet = AlphabetOfAny{String}(),
    operators = [⊤, ⊥, ¬, ∧, ∨, →, ◊, □],
    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →, ◊, □]),
    algebra = BooleanAlgebra(),
)</code></pre><p>Instantiate a <a href="https://simple.wikipedia.org/wiki/Modal_logic">modal logic</a> given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (¬) isa operatorstype(modallogic());
true

julia&gt; (□) isa operatorstype(modallogic());
true

julia&gt; (□) isa operatorstype(modallogic(; operators = [¬, ∨]))
┌ Warning: Instantiating modal logic (via `modallogic`) with solely propositional operators (SoleLogics.NamedConnective[¬, ∨]). Consider using propositionallogic instead.
└ @ SoleLogics ~/.julia/dev/SoleLogics/src/modal-logic.jl:642
false

julia&gt; modallogic(; alphabet = [&quot;p&quot;, &quot;q&quot;]);

julia&gt; modallogic(; alphabet = ExplicitAlphabet([Atom(&quot;p&quot;), Atom(&quot;q&quot;)]));
</code></pre><p>See also <a href="../base-logic/#SoleLogics.propositionallogic-Tuple{}"><code>propositionallogic</code></a>, <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="../base-logic/#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/utils/modal-logic.jl#L507-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, Operator, NTuple{N, var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(AbstractVector{W} where W&lt;:AbstractWorld)}} where {N, W&lt;:AbstractWorld}" href="#SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, Operator, NTuple{N, var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(AbstractVector{W} where W&lt;:AbstractWorld)}} where {N, W&lt;:AbstractWorld}"><code>SoleLogics.collateworlds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collateworlds(
    fr::AbstractFrame{W},
    op::Operator,
    t::NTuple{N,WS},
)::AbstractVector{&lt;:W} where {N,W&lt;:AbstractWorld,WS&lt;:AbstractWorlds}</code></pre><p>For a given crisp frame (<code>truthtype == Bool</code>), return the set of worlds where a composed formula op(φ1, ..., φN) is true, given the <code>N</code> sets of worlds where the each immediate sub-formula is true.</p><p>See also <a href="../getting-started/#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>check</code></a>, <a href="../base-logic/#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}"><code>iscrisp</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>, <a href="#SoleLogics.AbstractFrame"><code>AbstractFrame</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/types/modal-logic.jl#L524-L537">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../base-logic/">« Introduction to Logics and Propositional Logic</a><a class="docs-footer-nextpage" href="../many-valued-logics/">Many-valued logics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 25 October 2024 14:27">Friday 25 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
