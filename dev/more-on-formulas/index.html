<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More on Formulas · SoleLogics.jl</title><meta name="title" content="More on Formulas · SoleLogics.jl"/><meta property="og:title" content="More on Formulas · SoleLogics.jl"/><meta property="twitter:title" content="More on Formulas · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../base-logic/">Introduction to Logics and Propositional Logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li><a class="tocitem" href="../many-valued-logics/">Many-valued logics</a></li><li class="is-active"><a class="tocitem" href>More on Formulas</a><ul class="internal"><li><a class="tocitem" href="#Literals"><span>Literals</span></a></li><li><a class="tocitem" href="#Linear-Forms"><span>Linear Forms</span></a></li><li><a class="tocitem" href="#Random-sampling-and-generation"><span>Random sampling and generation</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>More on Formulas</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More on Formulas</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/more-on-formulas.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#more-on-formulas-section">More on Formulas</a></li><li class="no-marker"><ul><li><a href="#Literals">Literals</a></li><li><a href="#Linear-Forms">Linear Forms</a></li><li><a href="#Random-sampling-and-generation">Random sampling and generation</a></li><li><a href="#Parsing">Parsing</a></li><li><a href="#Utilities">Utilities</a></li></ul></li></ul><h1 id="more-on-formulas-section"><a class="docs-heading-anchor" href="#more-on-formulas-section">More on Formulas</a><a id="more-on-formulas-section-1"></a><a class="docs-heading-anchor-permalink" href="#more-on-formulas-section" title="Permalink"></a></h1><p>In this chapter, you are going to learn more on <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a> representations that are alternative to syntax trees. As you will see, for example, formulas with specific structure (e.g., <a href="https://en.wikipedia.org/wiki/Canonical_normal_form">normal forms</a>) can be represented in ways that make them more easy to handle, and can lead to great benefits in terms of both computational and memory load.</p><p>We proceed by presenting the random formulae generation engine, parsing and some utility function.</p><p>Recalling the type hierarchy presented in <a href="../getting-started/#man-core">man-core</a>, it is here enriched with the following new types and structures.</p><ul><li><a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a><ul><li><a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a><ul><li><a href="#SoleLogics.Literal"><code>Literal</code></a></li><li><a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a></li></ul></li></ul></li></ul><hr/><h2 id="Literals"><a class="docs-heading-anchor" href="#Literals">Literals</a><a id="Literals-1"></a><a class="docs-heading-anchor-permalink" href="#Literals" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.Literal"><a class="docstring-binding" href="#SoleLogics.Literal"><code>SoleLogics.Literal</code></a> — <span class="docstring-category">Type</span></summary><div><p>A <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a> given by an atom, or its negation.</p><p>Commonly used in normal forms (see <a href="#SoleLogics.CNF"><code>CNF</code></a>/<a href="#SoleLogics.DNF"><code>DNF</code></a>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/normal-forms/leftmost.jl#L523-L527">source</a></div></details></article><h2 id="Linear-Forms"><a class="docs-heading-anchor" href="#Linear-Forms">Linear Forms</a><a id="Linear-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Forms" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.LeftmostLinearForm"><a class="docstring-binding" href="#SoleLogics.LeftmostLinearForm"><code>SoleLogics.LeftmostLinearForm</code></a> — <span class="docstring-category">Type</span></summary><div><p>A <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a> representing the <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)"><code>foldl</code></a> of a set of other syntax structure of type <code>SS</code> by means of a connective <code>C</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="language-julia hljs">const LeftmostConjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}}
    &quot;(p) → (q) → (r)&quot;

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}
    &quot;(¬p) ∧ (q) ∧ (¬r)&quot;

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}
    &quot;(¬p) ∨ (q) ∨ (¬r)&quot;

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa DNF
true

julia&gt; conj = LeftmostConjunctiveForm(@atoms p q)
LeftmostConjunctiveForm with 2 Atom{String} grandchildren:
        p
        q

julia&gt; tree(conj)
SyntaxBranch: p ∧ q

julia&gt; nconj = NEGATION(conj)
LeftmostLinearForm with connective ¬ and 1 LeftmostConjunctiveForm{Atom{String}} grandchildren:
        (p) ∧ (q)

julia&gt; tree(nconj)
SyntaxBranch: ¬(p ∧ q)

julia&gt; tree(nconj ∧ nconj)
SyntaxBranch: ¬(p ∧ q) ∧ ¬(p ∧ q)</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="#SoleLogics.Literal"><code>Literal</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/normal-forms/leftmost.jl#L55-L102">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.LeftmostConjunctiveForm"><a class="docstring-binding" href="#SoleLogics.LeftmostConjunctiveForm"><code>SoleLogics.LeftmostConjunctiveForm</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LeftmostConjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}</code></pre><p>Specific instantiation of a <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, where <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are all <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>s.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/normal-forms/leftmost.jl#L347-L355">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.LeftmostDisjunctiveForm"><a class="docstring-binding" href="#SoleLogics.LeftmostDisjunctiveForm"><code>SoleLogics.LeftmostDisjunctiveForm</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LeftmostDisjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}</code></pre><p>Specific instantiation of a <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, where <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are all <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>s.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/normal-forms/leftmost.jl#L389-L397">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.CNF"><a class="docstring-binding" href="#SoleLogics.CNF"><code>SoleLogics.CNF</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">CNF{SS&lt;:SyntaxStructure} = LeftmostConjunctiveForm{LeftmostDisjunctiveForm{SS}}</code></pre><p>Conjunctive Normal Form of an <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/normal-forms/leftmost.jl#L431-L438">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.DNF"><a class="docstring-binding" href="#SoleLogics.DNF"><code>SoleLogics.DNF</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">DNF{SS&lt;:SyntaxStructure} = LeftmostConjunctiveForm{LeftmostConjunctiveForm{SS}}</code></pre><p>Disjunctive Normal Form of an <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/normal-forms/leftmost.jl#L451-L458">source</a></div></details></article><h2 id="Random-sampling-and-generation"><a class="docs-heading-anchor" href="#Random-sampling-and-generation">Random sampling and generation</a><a id="Random-sampling-and-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-sampling-and-generation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}"><a class="docstring-binding" href="#Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Base.rand(
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    alphabet::AbstractAlphabet,
    args...;
    kwargs...
)::Atom</code></pre><p>Synonym for <a href="#SoleLogics.randatom"><code>randatom(::AbstractAlphabet)</code></a>.</p><p>Randomly generate an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> from a <em>finite</em> <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a> according to a uniform distribution.</p><p>See also [<code>AbstractAlphabet</code>], <a href="#SoleLogics.randatom"><code>randatom(::AbstractAlphabet)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/generation/formula.jl#L79-L93">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.randatom"><a class="docstring-binding" href="#SoleLogics.randatom"><code>SoleLogics.randatom</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">randatom(
    [rng::Union{Random.AbstractRNG,Integer},]
    a::AbstractAlphabet,
    args...;
    kwargs...
)</code></pre><p>Randomly generate an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> from a <em>finite</em> <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a> according to a uniform distribution.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alphabet = ExplicitAlphabet(1:5)
ExplicitAlphabet{Int64}(Atom{Int64}[Atom{Int64}: 1, Atom{Int64}: 2, Atom{Int64}: 3, Atom{Int64}: 4, Atom{Int64}: 5])

julia&gt; randatom(42, alphabet)
Atom{Int64}: 4</code></pre><p>See also <a href="../base-logic/#SoleLogics.natoms-Tuple{SoleLogics.AbstractAlphabet}"><code>natoms</code></a>, <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/generation/formula.jl#L8-L29">source</a></div><div><pre><code class="language-julia hljs">randatom(
    [rng::Union{Random.AbstractRNG,Integer},]
    a::UnionAlphabet;
    atompicking_mode::Symbol=:uniform,
    subalphabets_weights::Union{Nothing,AbstractWeights,AbstractVector{&lt;:Real}}=nothing
)::Atom</code></pre><p>Sample an atom from a <code>UnionAlphabet</code>. By default, the sampling is uniform with respect to the atoms.</p><p>By setting <code>atompicking_mode = :uniform_subalphabets</code> one can force a uniform sampling with respect to the sub-alphabets.</p><p>Moreover, one can specify a <code>:weighted</code> <code>atompicking_mode</code>, together with a <code>subalphabets_weights</code> vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alphabet1 = ExplicitAlphabet(Atom.(1:10));
julia&gt; alphabet2 = ExplicitAlphabet(Atom.(11:20));
julia&gt; union_alphabet = UnionAlphabet([alphabet1, alphabet2]);

julia&gt; randatom(42, union_alphabet)
Atom{Int64}: 11

julia&gt; randatom(42, union_alphabet; atompicking_mode=:uniform_subalphabets)
Atom{Int64}: 11

julia&gt; for i in 1:10
            randatom(
                union_alphabet;
                atompicking_mode=:weighted,
                subalphabets_weights=[0.8,0.2]
            ) |&gt; syntaxstring |&gt; vcat |&gt; print
        end
[&quot;6&quot;][&quot;3&quot;][&quot;10&quot;][&quot;7&quot;][&quot;2&quot;][&quot;2&quot;][&quot;6&quot;][&quot;9&quot;][&quot;20&quot;][&quot;16&quot;]</code></pre><p>See also <a href="@ref"><code>UnionAlphabet</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/generation/formula.jl#L27-L67">source</a></div></details></article><article><details class="docstring" open="true"><summary id="StatsBase.sample-Tuple{SoleLogics.AbstractAlphabet, StatsBase.AbstractWeights, Vararg{Any}}"><a class="docstring-binding" href="#StatsBase.sample-Tuple{SoleLogics.AbstractAlphabet, StatsBase.AbstractWeights, Vararg{Any}}"><code>StatsBase.sample</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">function StatsBase.sample(
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    alphabet::AbstractAlphabet,
    weights::AbstractWeights,
    args...;
    kwargs...
)</code></pre><p>Sample an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> from an <code>alphabet</code>, with probabilities proportional to the weights given in <code>weights</code>.</p><p>See also <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="@ref"><code>AbstractWeights</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/generation/formula.jl#L156-L169">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.randformula"><a class="docstring-binding" href="#SoleLogics.randformula"><code>SoleLogics.randformula</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">function randformula(
    [T::Type{&lt;:Formula}=SyntaxTree,]
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    maxheight::Integer,
    alphabet::Union{AbstractVector,AbstractAlphabet},
    operators::AbstractVector{&lt;:Operator},
    args...;
    maxmodaldepth::Integer=maxheight,
    atompicker::Union{Nothing,Function,AbstractWeights,AbstractVector{&lt;:Real}}=randatom,
    opweights::Union{Nothing,AbstractWeights,AbstractVector{&lt;:Real}}=nothing,
    alphabet_sample_kwargs::Union{Nothing,AbstractVector}=nothing,
    kwargs...
)</code></pre><p>Return a pseudo-randomic formula of type <a href="@ref"><code>T</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Union{Intger,AbstractRNG}=Random.GLOBAL_RNG</code>: random number generator;</li><li><code>maxheight::Integer</code>: maximum height of the generated structure;</li><li><code>alphabet::AbstractAlphabet</code>: collection from which atoms are chosen randomly;</li><li><code>operators::AbstractVector{&lt;:Operator}</code>: vector from which legal operators are chosen.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>maxmodaldepth::Integer</code>: maximum modal depth;</li><li><code>atompicker::Union{Nothing,Function,AbstractWeights,AbstractVector{&lt;:Real}}</code>: method used   to pick a random element. For example, this could be Base.rand, StatsBase.sample or   an array of integers or an array of <code>StatsBase.AbstractWeights</code>;</li><li><code>opweights::Union{Nothing,AbstractWeights,AbstractVector{&lt;:Real}}</code>: operators are sampled   with probabilities proportional to this vector (see <a href="@ref"><code>AbstractWeights</code></a> of   StatsBase package).</li><li><code>alphabet_sample_kwargs::AbstractVector</code>: pool of atoms to pull from if the given alphabet   is not finite.</li><li><code>basecase::Function</code> = method to specify the base case of the recursion; if not specified,   it returns <code>atompicker</code>.</li></ul><p>[!WARNING] The basecase is applied at the end of the recustion (i.e., when height = 0). If introducting a basecase which produces a subformula, please adjust the <code>maxheight</code> parameter value accordingly (e.g., when producing a subformula of the type o(p,q), where <code>o</code> is a connective and <code>p,q</code> are atoms, to generate a formula of maxheight <code>n</code> provide a value of <code>n-1</code> for the <code>maxheight</code> parameter).</p><ul><li><code>mode::Bool = :maxheight</code> constrains the generated syntax tree   to having a height smaller or equal to <code>maxheight</code> (<code>mode = :maxheight</code>),   to having height equal to <code>maxheight</code> (<code>mode = :exactheight</code>),   or to having height equal to <code>maxheight</code> and being full (<code>mode = :full</code>),.</li><li><code>earlystoppingtreshold::Float</code> : when <code>mode = :maxheight</code>,   controls the probability of calling the basecase before reaching.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))
&quot;¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))&quot;</code></pre><p>See also <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="@ref"><code>AbstractWeights</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/generation/formula.jl#L208-L264">source</a></div><div><pre><code class="language-julia hljs">function randformula(
    [T::Type{&lt;:Formula}=SyntaxTree,]
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    maxheight::Integer,
    [g::AbstractGrammar,]
    args...;
    kwargs...
)</code></pre><p>Fallback to <code>randformula</code>, specifying only the <code>maxheight</code> (possibly also a <code>grammar</code>) of the generated <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p><p>See also <a href="../base-logic/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.randformula"><code>randformula(::Integer, ::Union{AbstractVector,AbstractAlphabet}, ::AbstractVector)</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/generation/formula.jl#L306-L321">source</a></div></details></article><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.BASE_PARSABLE_CONNECTIVES"><a class="docstring-binding" href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code></a> — <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const BASE_PARSABLE_CONNECTIVES = SoleLogics.Syntactical[¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤, ⊥]</code></pre><p>Vector of (standard) operators that are automatically taken care of when parsing. These are ¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤ and ⊥.</p><p>See also <a href="#SoleLogics.parseformula"><code>parseformula</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/parse.jl#L9-L16">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.parseformula"><a class="docstring-binding" href="#SoleLogics.parseformula"><code>SoleLogics.parseformula</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">parseformula(
    [F::Type{&lt;:Formula}=SyntaxTree],
    expr::AbstractString,
    additional_operators::Union{Nothing,AbstractVector} = nothing;
    kwargs...
)::F

parseformula(
    F::Type{&lt;:SyntaxTree},
    expr::AbstractString,
    logic::AbstractLogic;
    kwargs...
)::F</code></pre><p>Parse a formula of type <code>F</code> from a string expression (its <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>).</p><p>By default, this function is only able to parse operators in <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code></a> (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector <code>additional_operators</code>, and their <code>syntaxstring</code>s will be used for parsing them. Note that, in case of clashing <code>syntaxstring</code>s, the provided additional operators will override the standard ones.</p><p>When parsing <code>SyntaxTree</code>s, the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a> algorithm is used, and the method allows the following keywords arguments.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>function_notation::Bool = false</code>: if set to <code>true</code>, the expression is considered   in function notation (e.g., <code>&quot;⨁(arg1, arg2)&quot;</code>);   otherwise, it is considered in   <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a> (e.g., <code>&quot;arg1 ⨁ arg2&quot;</code>);</li><li><code>atom_parser::Base.Callable = Atom{String}</code>: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the <code>Atom</code> itself;</li><li><code>additional_whitespaces::Vector{Char} = Char[]</code>: characters to be stripped out from each   syntax token.   For example, if <code>&#39;@&#39; in additional_whitespaces</code>, &quot;¬@p@&quot; is parsed just as &quot;¬p&quot;.</li><li><code>opening_parenthesis::String = &quot;(&quot;</code>:   the string signaling the opening of an expression block;</li><li><code>closing_parenthesis::String = &quot;)&quot;</code>:   the string signaling the closing of an expression block;</li><li><code>arg_delim::String = &quot;,&quot;</code>:   when <code>function_notation = true</code>,   the string that delimits the different arguments of a function call.</li></ul><div class="admonition is-warning" id="Warning-2dfcd5f7db2a8a74"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2dfcd5f7db2a8a74" title="Permalink"></a></header><div class="admonition-body"><p>For a proper functioning, the <code>syntaxstring</code> of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator <code>⨁</code>, it should hold that <code>syntaxstring(⨁) == strip(syntaxstring(⨁))</code>. Also, <code>syntaxstring</code>s cannot contain special symbols (<code>opening_parenthesis</code>, <code>closing_parenthesis</code>, and <code>arg_delim</code>) as substrings.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬p∧q∧(¬s∧¬z)&quot;))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;∧(¬p,∧(q,∧(¬s,¬z)))&quot;, function_notation=true))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;¬1→0&quot;; atom_parser = (x -&gt; Atom{Float64}(parse(Float64, x)))))
&quot;(¬1.0) → 0.0&quot;</code></pre><div class="admonition is-info" id="Note-b179fd42f50fb8cb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b179fd42f50fb8cb" title="Permalink"></a></header><div class="admonition-body"><p>For any <code>Formula</code> type <code>F</code>, this function should be the inverse of <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>; that is, if <code>φ::F</code> then the following should hold, for at least some <code>args</code>, and for every <code>kwargs</code> allowing correct parsing: <code>φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...)</code>.</p></div></div><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>BASE_PARSABLE_CONNECTIVES</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/parse.jl#L114-L191">source</a></div></details></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}"><a class="docstring-binding" href="#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}"><code>SoleLogics.treewalk</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">treewalk(
    st::SyntaxTree,
    args...;
    rng::AbstractRNG = Random.GLOBAL_RNG,
    criterion::Function = ntokens,
    toleaf::Bool = true,
    returnnode::Bool = false,
    transformnode::Function = nothing
)::SyntaxTree</code></pre><p>Return a subtree of syntax tree, by following these options:</p><ul><li><code>criterion</code>: function used to compute the probability of stopping at a random node;</li><li><code>returnnode</code>: true if only the subtree is to be returned;</li><li><code>transformnode</code>: function that will be applied to the chosen subtree.</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/tools.jl#L9-L24">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.subformulas-Tuple{Formula}"><a class="docstring-binding" href="#SoleLogics.subformulas-Tuple{Formula}"><code>SoleLogics.subformulas</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">subformulas(f::Formula; sorted=true)</code></pre><p>Return all sub-formulas (sorted by size when <code>sorted=true</code>) of a given formula.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring.(SoleLogics.subformulas(parseformula(&quot;◊((p∧q)→r)&quot;)))
6-element Vector{String}:
 &quot;p&quot;
 &quot;q&quot;
 &quot;r&quot;
 &quot;p ∧ q&quot;
 &quot;◊(p ∧ q)&quot;
 &quot;(◊(p ∧ q)) → r&quot;</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/tools.jl#L81-L101">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.normalize-Tuple{Formula}"><a class="docstring-binding" href="#SoleLogics.normalize-Tuple{Formula}"><code>SoleLogics.normalize</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">normalize(
    f::Formula;
    profile = :readability,
    remove_boxes = nothing,
    reduce_negations = true,
    simplify_constants = true,
    allow_atom_flipping = false,
    prefer_implications = false,
    remove_implications = false,
    forced_negation_removal = nothing,
    remove_identities = true,
    unify_toones = true,
    rotate_commutatives = true,
    flip_atom = nothing,
)</code></pre><p>Return a modified version of a given formula, that has the same semantics but different syntax. This is useful for simplifying formulas for readability, or when checking the truth of many (possibly semantically similar) formulas; for example, when performing <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>. The current implementation assumes the underlying algebra is Boolean!</p><p><strong>Arguments</strong></p><ul><li><code>f::Formula</code>: when set to <code>true</code>,   the formula;</li><li><code>profile::Symbol</code>: possible values are :readability, which optimizes for qualitative   simplicity for a human to understand, and :modelchecking, which optimizes   model checking speed;</li><li><code>remove_boxes::Bool</code>: remove all (non-relational and relational) box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.</li><li><code>reduce_negations::Bool</code>: when set to <code>true</code>,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan&#39;s laws</a>).   Note: this assumes an underlying Boolean algebra.</li><li><code>allow_atom_flipping::Bool</code>: when set to <code>true</code>,   together with <code>reduce_negations=true</code>, this may cause the negation of an atom   to be replaced with the its <a href="../getting-started/#SoleLogics.dual-Tuple{SyntaxToken}"><code>dual</code></a> atom.</li><li><code>flip_atom::Union{Nothing,Callable}</code>: when a callable is provided, it is used   for deciding when to flip atoms.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;□¬((p∧¬q)→r)∧⊤&quot;);

julia&gt; syntaxstring(f)
&quot;□¬((p ∧ ¬q) → r) ∧ ⊤&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))
&quot;¬◊(q ∨ ¬p ∨ r)&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))
&quot;□(¬r ∧ p ∧ ¬q)&quot;</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/tools.jl#L126-L185">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.isgrounded-Tuple{Formula}"><a class="docstring-binding" href="#SoleLogics.isgrounded-Tuple{Formula}"><code>SoleLogics.isgrounded</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">isgrounded(f::Formula)::Bool</code></pre><p>Return <code>true</code> if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;⟨G⟩p → [G]q&quot;);

julia&gt; syntaxstring(f)
&quot;(⟨G⟩p) → ([G]q)&quot;

julia&gt; SoleLogics.isgrounded(f)
true</code></pre><p>See also <a href="../modal-logic/#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>), <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/90fd1235a476b86be06fa97d72b892cc848f5bb7/src/utils/tools.jl#L474-L494">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../many-valued-logics/">« Many-valued logics</a><a class="docs-footer-nextpage" href="../hands-on/">Hands On »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Wednesday 7 January 2026 15:48">Wednesday 7 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
