<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More on Formulas · SoleLogics.jl</title><meta name="title" content="More on Formulas · SoleLogics.jl"/><meta property="og:title" content="More on Formulas · SoleLogics.jl"/><meta property="twitter:title" content="More on Formulas · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../base-logic/">Introduction to Logics and Propositional Logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li><a class="tocitem" href="../many-valued-logics/">Many-valued logics</a></li><li class="is-active"><a class="tocitem" href>More on Formulas</a><ul class="internal"><li><a class="tocitem" href="#Literals"><span>Literals</span></a></li><li><a class="tocitem" href="#Linear-Forms"><span>Linear Forms</span></a></li><li><a class="tocitem" href="#Random-sampling-and-generation"><span>Random sampling and generation</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>More on Formulas</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More on Formulas</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/more-on-formulas.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#more-on-formulas-section">More on Formulas</a></li><li class="no-marker"><ul><li><a href="#Literals">Literals</a></li><li><a href="#Linear-Forms">Linear Forms</a></li><li><a href="#Random-sampling-and-generation">Random sampling and generation</a></li><li><a href="#Parsing">Parsing</a></li><li><a href="#Utilities">Utilities</a></li></ul></li></ul><h1 id="more-on-formulas-section"><a class="docs-heading-anchor" href="#more-on-formulas-section">More on Formulas</a><a id="more-on-formulas-section-1"></a><a class="docs-heading-anchor-permalink" href="#more-on-formulas-section" title="Permalink"></a></h1><p>In this chapter, you are going to learn more on <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a> representations that are alternative to syntax trees. As you will see, for example, formulas with specific structure (e.g., <a href="https://en.wikipedia.org/wiki/Canonical_normal_form">normal forms</a>) can be represented in ways that make them more easy to handle, and can lead to great benefits in terms of both computational and memory load.</p><p>We proceed by presenting the random formulae generation engine, parsing and some utility function.</p><p>Recalling the type hierarchy presented in <a href="../getting-started/#man-core">man-core</a>, it is here enriched with the following new types and structures.</p><ul><li><a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a><ul><li><a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a><ul><li><a href="#SoleLogics.Literal"><code>Literal</code></a></li><li><a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a></li></ul></li></ul></li></ul><hr/><h2 id="Literals"><a class="docs-heading-anchor" href="#Literals">Literals</a><a id="Literals-1"></a><a class="docs-heading-anchor-permalink" href="#Literals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Literal" href="#SoleLogics.Literal"><code>SoleLogics.Literal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Literal{T&lt;:SyntaxLeaf} &lt;: SyntaxStructure
    ispos::Bool
    prop::T
end</code></pre><p>An atom, or its negation.</p><p>See also <a href="#SoleLogics.CNF"><code>CNF</code></a>, <a href="#SoleLogics.DNF"><code>DNF</code></a>, <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L495-L504">source</a></section></article><h2 id="Linear-Forms"><a class="docs-heading-anchor" href="#Linear-Forms">Linear Forms</a><a id="Linear-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Forms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.LeftmostLinearForm" href="#SoleLogics.LeftmostLinearForm"><code>SoleLogics.LeftmostLinearForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LeftmostLinearForm{C&lt;:Connective,SS&lt;:SyntaxStructure} &lt;: SyntaxStructure
    children::Vector{&lt;:SS}
end</code></pre><p>A syntax structure representing the <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)"><code>foldl</code></a> of a set of other syntax structure of type <code>SS</code> by means of a connective <code>C</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="nohighlight hljs">const LeftmostConjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}}
    &quot;(p) → (q) → (r)&quot;

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}
    &quot;(¬p) ∧ (q) ∧ (¬r)&quot;

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}
    &quot;(¬p) ∨ (q) ∨ (¬r)&quot;

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa DNF
true

julia&gt; conj = LeftmostConjunctiveForm(@atoms p q)
LeftmostConjunctiveForm with 2 Atom{String} children:
        p
        q

julia&gt; tree(conj)
SyntaxBranch: p ∧ q

julia&gt; nconj = NEGATION(conj)
LeftmostLinearForm with connective ¬ and 1 LeftmostConjunctiveForm{Atom{String}} children:
        (p) ∧ (q)

julia&gt; tree(nconj)
SyntaxBranch: ¬(p ∧ q)

julia&gt; tree(nconj ∧ nconj)
SyntaxBranch: ¬(p ∧ q) ∧ ¬(p ∧ q)</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="#SoleLogics.Literal"><code>Literal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L57-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.LeftmostConjunctiveForm" href="#SoleLogics.LeftmostConjunctiveForm"><code>SoleLogics.LeftmostConjunctiveForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LeftmostConjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}</code></pre><p>Specific instantiation of a <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, where <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are all <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>s.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L328-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.LeftmostDisjunctiveForm" href="#SoleLogics.LeftmostDisjunctiveForm"><code>SoleLogics.LeftmostDisjunctiveForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LeftmostDisjunctiveForm{SS&lt;:SyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}</code></pre><p>Specific instantiation of a <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, where <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are all <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>s.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L356-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.CNF" href="#SoleLogics.CNF"><code>SoleLogics.CNF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CNF{SS&lt;:SyntaxStructure} = LeftmostConjunctiveForm{LeftmostDisjunctiveForm{SS}}</code></pre><p>Conjunctive Normal Form of an <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L384-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.DNF" href="#SoleLogics.DNF"><code>SoleLogics.DNF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DNF{SS&lt;:SyntaxStructure} = LeftmostConjunctiveForm{LeftmostConjunctiveForm{SS}}</code></pre><p>Disjunctive Normal Form of an <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L411-L418">source</a></section></article><p>&lt;!– </p><ul><li><a href="#SoleLogics.AnchoredFormula"><code>AnchoredFormula</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AnchoredFormula" href="#SoleLogics.AnchoredFormula"><code>SoleLogics.AnchoredFormula</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct AnchoredFormula{L&lt;:AbstractLogic} &lt;: Formula
    _logic::Base.RefValue{L}
    synstruct::SyntaxStructure
end</code></pre><p>A formula anchored to a logic of type <code>L</code>, and wrapping a syntax structure. The structure encodes a formula belonging to the grammar of the logic, and the truth of the formula can be evaluated on interpretations of the same logic. Note that, here, the logic is represented by a reference.</p><p>Upon construction, the logic can be passed either directly, or via a RefValue. Additionally, the following keyword arguments may be specified:</p><ul><li><code>check_atoms::Bool = false</code>: whether to perform or not a check that the atoms   belong to the alphabet of the logic;</li><li><code>check_tree::Bool = false</code>: whether to perform or not a check that the formula&#39;s   syntactic structure honors the grammar   (includes the check performed with <code>check_atoms = true</code>);</li></ul><p><em>Cool feature</em>: a <code>AnchoredFormula</code> can be used for instating other formulas of the same logic. See the examples.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; φ = parseformula(AnchoredFormula, &quot;◊(p→q)&quot;);

julia&gt; f2 = φ(parseformula(&quot;p&quot;));

julia&gt; syntaxstring(φ)
&quot;◊(→(p, q))&quot;

julia&gt; syntaxstring(f2)
&quot;p&quot;

julia&gt; @assert logic(φ) == logic(f2)

julia&gt; @assert ◊ in operators(logic(f2))

julia&gt; @assert ◊ isa operatorstype(logic(f2))
</code></pre><p>See also <a href="../base-logic/#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>, <a href="../base-logic/#logic"><code>logic</code></a>, <a href="../getting-started/#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="../getting-started/#SoleLogics.tree-Tuple{Formula}"><code>tree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/utils/anchored-formula.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.logic-Tuple{SoleLogics.AnchoredFormula}" href="#SoleLogics.logic-Tuple{SoleLogics.AnchoredFormula}"><code>SoleLogics.logic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logic(φ::AnchoredFormula)::AbstractLogic</code></pre><p>Return the logic of an anchored formula</p><p>See <a href="#SoleLogics.AnchoredFormula"><code>AnchoredFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/utils/anchored-formula.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.synstruct-Tuple{SoleLogics.AnchoredFormula}" href="#SoleLogics.synstruct-Tuple{SoleLogics.AnchoredFormula}"><code>SoleLogics.synstruct</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">synstruct(φ::AnchoredFormula)::SyntaxStructure</code></pre><p>Return the syntactic component of an anchored formula.</p><p>See <a href="#SoleLogics.AnchoredFormula"><code>AnchoredFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/utils/anchored-formula.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.baseformula-Tuple{Formula}" href="#SoleLogics.baseformula-Tuple{Formula}"><code>SoleLogics.baseformula</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function baseformula(
    φ::Formula;
    infer_logic = true,
    additional_operators::Union{Nothing,Vector{&lt;:Operator}} = nothing,
    kwargs...
)</code></pre><p>Attempt at instantiating a <code>AnchoredFormula</code> from a syntax token/formula, by inferring the logic it belongs to. If <code>infer_logic</code> is true, then a canonical logic (e.g., propositional logic with all the <code>BASE_PROPOSITIONAL_CONNECTIVES</code>) is inferred; if it&#39;s false, then a logic with exactly the operators appearing in the syntax tree, plus the <code>additional_operators</code> is instantiated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = parseformula(&quot;◊((p∧q)→r)&quot;);

julia&gt; unique(operators(logic(SoleLogics.baseformula(t))))
3-element Vector{Union{SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:∧}}}:
 ∧
 ◊
 →

julia&gt; unique(operators(logic(SoleLogics.baseformula(t; additional_operators = SoleLogics.BASE_MODAL_CONNECTIVES))))
8-element Vector{Union{SoleLogics.BottomOperator, SoleLogics.NamedConnective{:¬}, SoleLogics.NamedConnective{:∧}, SoleLogics.NamedConnective{:∨}, SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:□}, SoleLogics.TopOperator}}:
 ¬
 ∧
 ∨
 →
 ◊
 □</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/utils/anchored-formula.jl#L168-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.parseformula" href="#SoleLogics.parseformula"><code>SoleLogics.parseformula</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parseformula(
    T::Type{AnchoredFormula},
    expr::String,
    additional_operators::Union{Nothing,Vector{&lt;:Operator}} = nothing;
    operators::Union{Nothing,Vector{&lt;:Operator}},
    grammar::Union{Nothing,AbstractGrammar} = nothing,
    algebra::Union{Nothing,AbstractAlgebra} = nothing,
    kwargs...
)::AnchoredFormula</code></pre><p>Return a <code>AnchoredFormula</code> which is the result of parsing an expression via the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a> algorithm. By default, this function is only able to parse operators in <code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code>; additional operators may be provided as a second argument.</p><p>The <code>grammar</code> and <code>algebra</code> of the associated logic is inferred using the <code>baseformula</code> function from the operators encountered in the expression, and those in <code>additional_operators</code>.</p><p>See <a href="#SoleLogics.parseformula"><code>parseformula</code></a>, <a href="#SoleLogics.baseformula-Tuple{Formula}"><code>baseformula</code></a>, <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>BASE_PARSABLE_CONNECTIVES</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/utils/anchored-formula.jl#L244-L266">source</a></section></article><p>–&gt;</p><h2 id="Random-sampling-and-generation"><a class="docs-heading-anchor" href="#Random-sampling-and-generation">Random sampling and generation</a><a id="Random-sampling-and-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-sampling-and-generation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}" href="#Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.rand(
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    alphabet::AbstractAlphabet,
    args...;
    kwargs...
)::Atom</code></pre><p>Synonym for <a href="#SoleLogics.randatom"><code>randatom(::AbstractAlphabet)</code></a>.</p><p>Randomly generate an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> from a <em>finite</em> <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a> according to a uniform distribution.</p><p>See also [<code>AbstractAlphabet</code>], <a href="#SoleLogics.randatom"><code>randatom(::AbstractAlphabet)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/generation/formula.jl#L79-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.randatom" href="#SoleLogics.randatom"><code>SoleLogics.randatom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randatom(
    [rng::Union{Random.AbstractRNG,Integer},]
    a::AbstractAlphabet,
    args...;
    kwargs...
)</code></pre><p>Randomly generate an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> from a <em>finite</em> <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a> according to a uniform distribution.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alphabet = ExplicitAlphabet(1:5)
ExplicitAlphabet{Int64}(Atom{Int64}[Atom{Int64}: 1, Atom{Int64}: 2, Atom{Int64}: 3, Atom{Int64}: 4, Atom{Int64}: 5])

julia&gt; randatom(42, alphabet)
Atom{Int64}: 4</code></pre><p>See also <a href="../base-logic/#SoleLogics.natoms-Tuple{SoleLogics.AbstractAlphabet}"><code>natoms</code></a>, <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/generation/formula.jl#L8-L29">source</a></section><section><div><pre><code class="language-julia hljs">randatom(
    [rng::Union{Random.AbstractRNG,Integer},]
    a::UnionAlphabet;
    atompicking_mode::Symbol=:uniform,
    subalphabets_weights::Union{Nothing,AbstractWeights,AbstractVector{&lt;:Real}}=nothing
)::Atom</code></pre><p>Sample an atom from a <code>UnionAlphabet</code>. By default, the sampling is uniform with respect to the atoms.</p><p>By setting <code>atompicking_mode = :uniform_subalphabets</code> one can force a uniform sampling with respect to the sub-alphabets.</p><p>Moreover, one can specify a <code>:weighted</code> <code>atompicking_mode</code>, together with a <code>subalphabets_weights</code> vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; alphabet1 = ExplicitAlphabet(Atom.(1:10));
julia&gt; alphabet2 = ExplicitAlphabet(Atom.(11:20));
julia&gt; union_alphabet = UnionAlphabet([alphabet1, alphabet2]);

julia&gt; randatom(42, union_alphabet)
Atom{Int64}: 11

julia&gt; randatom(42, union_alphabet; atompicking_mode=:uniform_subalphabets)
Atom{Int64}: 11

julia&gt; for i in 1:10
            randatom(
                union_alphabet;
                atompicking_mode=:weighted,
                subalphabets_weights=[0.8,0.2]
            ) |&gt; syntaxstring |&gt; vcat |&gt; print
        end
[&quot;6&quot;][&quot;3&quot;][&quot;10&quot;][&quot;7&quot;][&quot;2&quot;][&quot;2&quot;][&quot;6&quot;][&quot;9&quot;][&quot;20&quot;][&quot;16&quot;]</code></pre><p>See also <a href="@ref"><code>UnionAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/generation/formula.jl#L27-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.sample-Tuple{SoleLogics.AbstractAlphabet, StatsBase.AbstractWeights, Vararg{Any}}" href="#StatsBase.sample-Tuple{SoleLogics.AbstractAlphabet, StatsBase.AbstractWeights, Vararg{Any}}"><code>StatsBase.sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function StatsBase.sample(
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    alphabet::AbstractAlphabet,
    weights::AbstractWeights,
    args...;
    kwargs...
)</code></pre><p>Sample an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> from an <code>alphabet</code>, with probabilities proportional to the weights given in <code>weights</code>.</p><p>See also <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="@ref"><code>AbstractWeights</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/generation/formula.jl#L156-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.randformula" href="#SoleLogics.randformula"><code>SoleLogics.randformula</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function randformula(
    [T::Type{&lt;:Formula}=SyntaxTree,]
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    height::Integer,
    alphabet::Union{AbstractVector,AbstractAlphabet},
    operators::AbstractVector{&lt;:Operator},
    args...;
    modaldepth::Integer=height,
    atompicker::Union{Nothing,Function,AbstractWeights,AbstractVector{&lt;:Real}}=randatom,
    opweights::Union{Nothing,AbstractWeights,AbstractVector{&lt;:Real}}=nothing,
    alphabet_sample_kwargs::Union{Nothing,AbstractVector}=nothing,
    kwargs...
)</code></pre><p>Return a pseudo-randomic formula of type <a href="@ref"><code>T</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::Union{Intger,AbstractRNG}=Random.GLOBAL_RNG</code>: random number generator;</li><li><code>height::Integer</code>: height of the generated structure;</li><li><code>alphabet::AbstractAlphabet</code>: collection from which atoms are chosen randomly;</li><li><code>operators::AbstractVector{&lt;:Operator}</code>: vector from which legal operators are chosen.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>modaldepth::Integer</code>: maximum modal depth;</li><li><code>atompicker::Union{Nothing,Function,AbstractWeights,AbstractVector{&lt;:Real}}</code>: method used   to pick a random element. For example, this could be Base.rand, StatsBase.sample or   an array of integers or an array of <code>StatsBase.AbstractWeights</code>;</li><li><code>opweights::Union{Nothing,AbstractWeights,AbstractVector{&lt;:Real}}</code>: operators are sampled   with probabilities proportional to this vector (see <a href="@ref"><code>AbstractWeights</code></a> of   StatsBase package).</li><li><code>alphabet_sample_kwargs::AbstractVector</code>: pool of atoms to pull from if the given alphabet   is not finite.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(randformula(4, ExplicitAlphabet([1,2]), [NEGATION, CONJUNCTION, IMPLICATION]))
&quot;¬((¬(¬(2))) → ((1 → 2) → (1 → 2)))&quot;</code></pre><p>See also <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="@ref"><code>AbstractWeights</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/generation/formula.jl#L203-L245">source</a></section><section><div><pre><code class="language-julia hljs">function randformula(
    [T::Type{&lt;:Formula}=SyntaxTree,]
    [rng::Union{Integer,AbstractRNG}=Random.GLOBAL_RNG,]
    height::Integer,
    [g::AbstractGrammar,]
    args...;
    kwargs...
)</code></pre><p>Fallback to <code>randformula</code>, specifying only the <code>height</code> (possibly also a <code>grammar</code>) of the generated <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p><p>See also <a href="../base-logic/#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.randformula"><code>randformula(::Integer, ::Union{AbstractVector,AbstractAlphabet}, ::AbstractVector)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/generation/formula.jl#L282-L297">source</a></section></article><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.BASE_PARSABLE_CONNECTIVES" href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const BASE_PARSABLE_CONNECTIVES = SoleLogics.Syntactical[¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤, ⊥]</code></pre><p>Vector of (standard) operators that are automatically taken care of when parsing. These are ¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤ and ⊥.</p><p>See also <a href="#SoleLogics.parseformula"><code>parseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/utils/parse.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.parseformula" href="#SoleLogics.parseformula"><code>SoleLogics.parseformula</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parseformula(
    [F::Type{&lt;:Formula}=SyntaxTree],
    expr::String,
    additional_operators::Union{Nothing,AbstractVector} = nothing;
    kwargs...
)::F

parseformula(
    F::Type{&lt;:SyntaxTree},
    expr::String,
    logic::AbstractLogic;
    kwargs...
)::F</code></pre><p>Parse a formula of type <code>F</code> from a string expression (its <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>).</p><p>By default, this function is only able to parse operators in <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code></a> (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector <code>additional_operators</code>, and their <code>syntaxstring</code>s will be used for parsing them. Note that, in case of clashing <code>syntaxstring</code>s, the provided additional operators will override the standard ones.</p><p>When parsing <code>SyntaxTree</code>s, the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a> algorithm is used, and the method allows the following keywords arguments.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>function_notation::Bool = false</code>: if set to <code>true</code>, the expression is considered   in function notation (e.g., <code>&quot;⨁(arg1, arg2)&quot;</code>);   otherwise, it is considered in   <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a> (e.g., <code>&quot;arg1 ⨁ arg2&quot;</code>);</li><li><code>atom_parser::Base.Callable = Atom{String}</code>: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the <code>Atom</code> itself;</li><li><code>additional_whitespaces::Vector{Char} = Char[]</code>: characters to be stripped out from each   syntax token.   For example, if <code>&#39;@&#39; in additional_whitespaces</code>, &quot;¬@p@&quot; is parsed just as &quot;¬p&quot;.</li><li><code>opening_parenthesis::String = &quot;(&quot;</code>:   the string signaling the opening of an expression block;</li><li><code>closing_parenthesis::String = &quot;)&quot;</code>:   the string signaling the closing of an expression block;</li><li><code>arg_delim::String = &quot;,&quot;</code>:   when <code>function_notation = true</code>,   the string that delimits the different arguments of a function call.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For a proper functioning, the <code>syntaxstring</code> of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator <code>⨁</code>, it should hold that <code>syntaxstring(⨁) == strip(syntaxstring(⨁))</code>. Also, <code>syntaxstring</code>s cannot contain special symbols (<code>opening_parenthesis</code>, <code>closing_parenthesis</code>, and <code>arg_delim</code>) as substrings.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬p∧q∧(¬s∧¬z)&quot;))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;∧(¬p,∧(q,∧(¬s,¬z)))&quot;, function_notation=true))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;¬1→0&quot;; atom_parser = (x -&gt; Atom{Float64}(parse(Float64, x)))))
&quot;(¬1.0) → 0.0&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For any <code>Formula</code> type <code>F</code>, this function should be the inverse of <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>; that is, if <code>φ::F</code> then the following should hold, for at least some <code>args</code>, and for every <code>kwargs</code> allowing correct parsing: <code>φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...)</code>.</p></div></div><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>BASE_PARSABLE_CONNECTIVES</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/utils/parse.jl#L114-L191">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}" href="#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}"><code>SoleLogics.treewalk</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">treewalk(
    st::SyntaxTree,
    args...;
    rng::AbstractRNG = Random.GLOBAL_RNG,
    criterion::Function = ntokens,
    toleaf::Bool = true,
    returnnode::Bool = false,
    transformnode::Function = nothing
)::SyntaxTree</code></pre><p>Return a subtree of syntax tree, by following these options:</p><ul><li><code>criterion</code>: function used to compute the probability of stopping at a random node;</li><li><code>returnnode</code>: true if only the subtree is to be returned;</li><li><code>transformnode</code>: function that will be applied to the chosen subtree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L617-L632">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.subformulas-Tuple{Formula}" href="#SoleLogics.subformulas-Tuple{Formula}"><code>SoleLogics.subformulas</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subformulas(f::Formula; sorted=true)</code></pre><p>Return all sub-formulas (sorted by size when <code>sorted=true</code>) of a given formula.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring.(SoleLogics.subformulas(parseformula(&quot;◊((p∧q)→r)&quot;)))
6-element Vector{String}:
 &quot;p&quot;
 &quot;q&quot;
 &quot;r&quot;
 &quot;p ∧ q&quot;
 &quot;◊(p ∧ q)&quot;
 &quot;(◊(p ∧ q)) → r&quot;</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L689-L709">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.normalize-Tuple{Formula}" href="#SoleLogics.normalize-Tuple{Formula}"><code>SoleLogics.normalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize(
    f::Formula;
    profile = :readability,
    remove_boxes = nothing,
    reduce_negations = true,
    simplify_constants = true,
    allow_atom_flipping = false,
    prefer_implications = false,
    remove_implications = false,
    forced_negation_removal = nothing,
    remove_identities = true,
    unify_toones = true,
    rotate_commutatives = true,
)</code></pre><p>Return a modified version of a given formula, that has the same semantics but different syntax. This is useful for simplifying formulas for readability, or when checking the truth of many (possibly semantically similar) formulas; for example, when performing <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>. The current implementation assumes the underlying algebra is Boolean!</p><p><strong>Arguments</strong></p><ul><li><code>f::Formula</code>: when set to <code>true</code>,   the formula;</li><li><code>profile::Symbol</code>: possible values are :readability, which optimizes for qualitative   simplicity for a human to understand, and :modelchecking, which optimizes   model checking speed;</li><li><code>remove_boxes::Bool</code>: remove all (non-relational and relational) box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.</li><li><code>reduce_negations::Bool</code>: when set to <code>true</code>,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan&#39;s laws</a>).   Note: this assumes an underlying Boolean algebra.</li><li><code>allow_atom_flipping::Bool</code>: when set to <code>true</code>,   together with <code>reduce_negations=true</code>, this may cause the negation of an atom   to be replaced with the its <a href="../getting-started/#SoleLogics.dual-Tuple{SyntaxToken}"><code>dual</code></a> atom.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;□¬((p∧¬q)→r)∧⊤&quot;);

julia&gt; syntaxstring(f)
&quot;□¬((p ∧ ¬q) → r) ∧ ⊤&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))
&quot;¬◊(q ∨ ¬p ∨ r)&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))
&quot;□(¬r ∧ p ∧ ¬q)&quot;</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L734-L790">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.isgrounded-Tuple{Formula}" href="#SoleLogics.isgrounded-Tuple{Formula}"><code>SoleLogics.isgrounded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isgrounded(f::Formula)::Bool</code></pre><p>Return <code>true</code> if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;⟨G⟩p → [G]q&quot;);

julia&gt; syntaxstring(f)
&quot;(⟨G⟩p) → ([G]q)&quot;

julia&gt; SoleLogics.isgrounded(f)
true</code></pre><p>See also <a href="../modal-logic/#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>), <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/c28646a3a57da847fdd55768ec77b408a5305590/src/syntax-utils.jl#L1064-L1084">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../many-valued-logics/">« Many-valued logics</a><a class="docs-footer-nextpage" href="../hands-on/">Hands On »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 25 October 2024 14:36">Friday 25 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
