<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Logics and Propositional Logic · SoleLogics.jl</title><meta name="title" content="Introduction to Logics and Propositional Logic · SoleLogics.jl"/><meta property="og:title" content="Introduction to Logics and Propositional Logic · SoleLogics.jl"/><meta property="twitter:title" content="Introduction to Logics and Propositional Logic · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/base-logic/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/base-logic/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/base-logic/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Introduction to Logics and Propositional Logic</a><ul class="internal"><li><a class="tocitem" href="#alphabets"><span>Alphabet</span></a></li><li><a class="tocitem" href="#grammars"><span>Grammar</span></a></li><li><a class="tocitem" href="#algebra"><span>Algebra</span></a></li><li><a class="tocitem" href="#logic"><span>Logic</span></a></li><li><a class="tocitem" href="#more-about-connectives"><span>More on Connectives</span></a></li><li><a class="tocitem" href="#boolean-algebra"><span>Propositional boolean logic</span></a></li><li class="toplevel"><a class="tocitem" href="#Interpretations"><span>Interpretations</span></a></li></ul></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li><a class="tocitem" href="../many-valued-logics/">Many-valued logics</a></li><li><a class="tocitem" href="../more-on-formulas/">More on Formulas</a></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction to Logics and Propositional Logic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Logics and Propositional Logic</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/base-logic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#base-logic-introduction">Introduction</a></li><li class="no-marker"><ul><li><a href="#alphabets">Alphabet</a></li><li><a href="#grammars">Grammar</a></li><li><a href="#algebra">Algebra</a></li><li><a href="#logic">Logic</a></li><li><a href="#more-about-connectives">More on Connectives</a></li><li><a href="#boolean-algebra">Propositional boolean logic</a></li></ul></li><li><a href="#Interpretations">Interpretations</a></li></ul><h1 id="base-logic-introduction"><a class="docs-heading-anchor" href="#base-logic-introduction">Introduction</a><a id="base-logic-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#base-logic-introduction" title="Permalink"></a></h1><p>At the end of this chapter, you are going to understand how <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>s and <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a> values are arranged into <em>alphabets</em> and <em>grammars</em>.</p><p>You will also get an in-depth view of how boolean <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a> values and boolean <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>&#39;s are defined from both a syntax and a syntactical standpoint of view.</p><p>Finally, you will get a clearer idea about how to represent and manipulate <em>interpretations</em> and their outcomes.</p><p>Recalling the type hierarchy presented in <a href="../getting-started/#man-core">man-core</a>, it is here enriched with the following new types and structures.</p><ul><li><a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a><ul><li><a href="#SoleLogics.BooleanTruth"><code>BooleanTruth</code></a></li></ul></li><li><a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a><ul><li><a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a><ul><li><a href="#SoleLogics.NEGATION"><code>NEGATION</code></a></li><li><a href="#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a> </li><li><a href="#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a></li><li><a href="#SoleLogics.IMPLICATION"><code>IMPLICATION</code></a></li></ul></li></ul></li><li><a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a><ul><li><a href="#SoleLogics.ExplicitAlphabet"><code>ExplicitAlphabet</code></a></li><li><a href="#SoleLogics.AlphabetOfAny"><code>AlphabetOfAny</code></a></li></ul></li><li><a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a><ul><li><a href="#SoleLogics.CompleteFlatGrammar"><code>CompleteFlatGrammar</code></a></li></ul></li><li><a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a><ul><li><a href="#SoleLogics.BooleanAlgebra"><code>BooleanAlgebra</code></a></li></ul></li><li><a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a><ul><li><a href="#SoleLogics.BaseLogic"><code>BaseLogic</code></a></li></ul></li><li><a href="../getting-started/#SoleLogics.Interpretation"><code>Interpretation</code></a><ul><li><a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a><ul><li><a href="#SoleLogics.TruthDict"><code>TruthDict</code></a></li><li><a href="#SoleLogics.DefaultedTruthDict"><code>DefaultedTruthDict</code></a></li><li><a href="@ref"><code>InterpretationSet</code></a></li><li><a href="@ref"><code>InterpretationVector</code></a></li></ul></li><li><a href="@ref"><code>LogicalInstance</code></a> </li></ul></li><li><a href="#SoleLogics.TruthTable"><code>TruthTable</code></a></li><li><a href="@ref"><code>LogicalInstance</code></a></li></ul><h2 id="alphabets"><a class="docs-heading-anchor" href="#alphabets">Alphabet</a><a id="alphabets-1"></a><a class="docs-heading-anchor-permalink" href="#alphabets" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.AbstractAlphabet"><a class="docstring-binding" href="#SoleLogics.AbstractAlphabet"><code>SoleLogics.AbstractAlphabet</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">abstract type AbstractAlphabet{V} end</code></pre><p>Abstract type for representing an alphabet of atoms with values of type <code>V</code>. An alphabet (or <em>propositional alphabet</em>) is a set of atoms (assumed to be <a href="https://en.wikipedia.org/wiki/Countable_set">countable</a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Atom(1) in ExplicitAlphabet(Atom.(1:10))
true

julia&gt; Atom(1) in ExplicitAlphabet(1:10)
true

julia&gt; Atom(1) in AlphabetOfAny{String}()
false

julia&gt; Atom(&quot;mystring&quot;) in AlphabetOfAny{String}()
true

julia&gt; &quot;mystring&quot; in AlphabetOfAny{String}()
┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})
└ @ SoleLogics ...
true</code></pre><p><strong>Interface</strong></p><ul><li><code>atoms(a::AbstractAlphabet)::AbstractVector</code></li><li><code>Base.isfinite(::Type{&lt;:AbstractAlphabet})::Bool</code></li><li><code>randatom(rng::Union{Random.AbstractRNG, Integer}, a::AbstractAlphabet, args...; kwargs...)::AbstractAtom</code></li></ul><p><strong>Utility functions</strong></p><ul><li><code>natoms(a::AbstractAlphabet)::Bool</code></li><li><code>Base.in(p::AbstractAtom, a::AbstractAlphabet)::Bool</code></li><li><code>Base.eltype(a::AbstractAlphabet)</code></li><li><code>randatom(a::AbstractAlphabet, args...; kwargs...)::AbstractAtom</code></li><li><code>atomstype(a::AbstractAlphabet)</code></li><li><code>valuetype(a::AbstractAlphabet)</code></li></ul><p><strong>Implementation</strong></p><p>When implementing a new alphabet type <code>MyAlphabet</code>, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:</p><pre><code class="language-julia hljs">function Base.in(p::AbstractAtom, a::MyAlphabet)::Bool</code></pre><p>in the case of <em>finite</em> alphabets, it suffices to define a method:</p><pre><code class="language-julia hljs">function atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>By default, an alphabet is considered finite:</p><pre><code class="language-julia hljs">Base.isfinite(::Type{&lt;:AbstractAlphabet}) = true
Base.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))
Base.in(p::AbstractAtom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)</code></pre><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AlphabetOfAny"><code>AlphabetOfAny</code></a>, <a href="@ref"><code>AbstractAtom</code></a>, <a href="#SoleLogics.ExplicitAlphabet"><code>ExplicitAlphabet</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L10-L71">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.isfinite-Tuple{Type{&lt;:SoleLogics.AbstractAlphabet}}"><a class="docstring-binding" href="#Base.isfinite-Tuple{Type{&lt;:SoleLogics.AbstractAlphabet}}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Base.isfinite(a::AbstractAlphabet)</code></pre><p>Return <code>true</code> if the alphabet is finite, <code>false</code> otherwise.</p><p>See <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L81-L87">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><a class="docstring-binding" href="#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><code>SoleLogics.atoms</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}</code></pre><p>List the atoms of a <em>finite</em> alphabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L91-L97">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.natoms-Tuple{SoleLogics.AbstractAlphabet}"><a class="docstring-binding" href="#SoleLogics.natoms-Tuple{SoleLogics.AbstractAlphabet}"><code>SoleLogics.natoms</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">natoms(a::AbstractAlphabet)::Integer</code></pre><p>Return the number of atoms of a <em>finite</em> alphabet.</p><p>See also <a href="../more-on-formulas/#SoleLogics.randatom"><code>randatom</code></a>, <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L129-L135">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}"><a class="docstring-binding" href="#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Base.in(p::AbstractAtom, a::AbstractAlphabet)::Bool</code></pre><p>Return whether an atom belongs to an alphabet.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="@ref"><code>AbstractAtom</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L106-L112">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ExplicitAlphabet"><a class="docstring-binding" href="#SoleLogics.ExplicitAlphabet"><code>SoleLogics.ExplicitAlphabet</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct ExplicitAlphabet{V} &lt;: AbstractAlphabet{V}
    atoms::Vector{Atom{V}}
end</code></pre><p>An alphabet wrapping atoms in a (finite) <code>Vector</code>.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><code>atoms</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L316-L324">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.AlphabetOfAny"><a class="docstring-binding" href="#SoleLogics.AlphabetOfAny"><code>SoleLogics.AlphabetOfAny</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct AlphabetOfAny{V} &lt;: AbstractAlphabet{V} end</code></pre><p>An implicit, infinite alphabet that includes all atoms with values of a subtype of V.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L356-L362">source</a></div></details></article><h2 id="grammars"><a class="docs-heading-anchor" href="#grammars">Grammar</a><a id="grammars-1"></a><a class="docs-heading-anchor-permalink" href="#grammars" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.AbstractGrammar"><a class="docstring-binding" href="#SoleLogics.AbstractGrammar"><code>SoleLogics.AbstractGrammar</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">abstract type AbstractGrammar{V&lt;:AbstractAlphabet,O&lt;:Operator} end</code></pre><p>Abstract type for representing a <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammar</a> based on a <em>single</em> alphabet of type <code>V</code>, and a set of operators that consists of all the (singleton) child types of <code>O</code>. V context-free grammar is a simple structure for defining formulas inductively.</p><p><strong>Interface</strong></p><ul><li><code>alphabet(g::AbstractGrammar)::AbstractAlphabet</code></li><li><code>Base.in(::SyntaxTree, g::AbstractGrammar)::Bool</code></li><li><code>formulas(g::AbstractGrammar; kwargs...)::Vector{&lt;:SyntaxTree}</code></li></ul><p><strong>Utility functions</strong></p><ul><li><code>Base.in(a::AbstractAtom, g::AbstractGrammar)</code></li><li><code>atomstype(g::AbstractGrammar)</code></li><li><code>tokenstype(g::AbstractGrammar)</code></li><li><code>operatorstype(g::AbstractGrammar)</code></li><li><code>alphabettype(g::AbstractGrammar)</code></li></ul><p>See also <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>alphabet</code></a>, <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L181-L204">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><a class="docstring-binding" href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>SoleLogics.alphabet</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">alphabet(g::AbstractGrammar{V} where {V})::V</code></pre><p>Return the propositional alphabet of a grammar.</p><p>See also <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L210-L216">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}"><a class="docstring-binding" href="#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool</code></pre><p>Return whether a <code>SyntaxTree</code>, belongs to a grammar.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L223-L229">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><a class="docstring-binding" href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">formulas(
    g::AbstractGrammar;
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing,
    args...
)::Vector{&lt;:SyntaxTree}</code></pre><p>Enumerate the formulas produced by a given grammar with a finite and iterable alphabet.</p><p><strong>Implementation</strong></p><p>Additional <code>args</code> can be used to model the function&#39;s behavior. At least these two arguments should be covered:</p><ul><li>a <code>nformulas</code> argument can be used to limit the size of the returned <code>Vector</code>;</li><li>a <code>maxdepth</code> argument can be used to limit the syntactic component, represented as a syntax tree,</li></ul><p>to a given maximum depth;</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="@ref"><code>AbstractSyntaxBranch</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L244-L263">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.CompleteFlatGrammar"><a class="docstring-binding" href="#SoleLogics.CompleteFlatGrammar"><code>SoleLogics.CompleteFlatGrammar</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct CompleteFlatGrammar{V&lt;:AbstractAlphabet,O&lt;:Operator} &lt;: AbstractGrammar{V,O}
    alphabet::V
    operators::Vector{&lt;:O}
end</code></pre><p>V grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type <code>V</code>, and all operators in <code>operators</code>. With n operators, this grammar has exactly n+1 production rules. For example, with <code>operators = [∧,∨]</code>, the grammar (in Backus-Naur form) is:</p><pre><code class="language-julia hljs">φ ::= p | φ ∧ φ | φ ∨ φ</code></pre><p>with p ∈ alphabet. Note: it is <em>flat</em> in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>, <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>alphabet</code></a>, <a href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>formulas</code></a>, <a href="#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}"><code>connectives</code></a>, <a href="@ref"><code>operators</code></a>, <a href="#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}"><code>leaves</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L428-L446">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}"><a class="docstring-binding" href="#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.connectives</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">connectives(g::AbstractGrammar)</code></pre><p>List all connectives appearing in a grammar.</p><p>See also <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="@ref"><code>nconnectives</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L482-L488">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}"><a class="docstring-binding" href="#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}"><code>SoleLogics.leaves</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">leaves(g::AbstractGrammar)</code></pre><p>List all leaves appearing in a grammar.</p><p>See also <a href="../getting-started/#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>, <a href="@ref"><code>nleaves</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L493-L499">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}"><a class="docstring-binding" href="#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}"><code>SoleLogics.formulas</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">formulas(
    g::CompleteFlatGrammar{V,O} where {V,O};
    maxdepth::Integer,
    nformulas::Union{Nothing,Integer} = nothing
)::Vector{SyntaxBranch}</code></pre><p>Generate all formulas whose <code>SyntaxBranch</code>s that are not taller than a given <code>maxdepth</code>.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L520-L530">source</a></div></details></article><h2 id="algebra"><a class="docs-heading-anchor" href="#algebra">Algebra</a><a id="algebra-1"></a><a class="docs-heading-anchor-permalink" href="#algebra" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.AbstractAlgebra"><a class="docstring-binding" href="#SoleLogics.AbstractAlgebra"><code>SoleLogics.AbstractAlgebra</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">abstract type AbstractAlgebra{T&lt;:Truth} end</code></pre><p>Abstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice structure</a> where two elements(or nodes) <em>⊤</em> and <em>⊥</em> are referred to as <em>TOP</em> (or maximum) and <em>bot</em> (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.</p><p><strong>Interface</strong></p><ul><li><code>truthtype(a::AbstractAlgebra)</code></li><li><code>domain(a::AbstractAlgebra)</code></li><li><code>top(a::AbstractAlgebra)</code></li><li><code>bot(a::AbstractAlgebra)</code></li></ul><p><strong>Utility functions</strong></p><ul><li><code>iscrisp(a::AbstractAlgebra)</code></li></ul><p><strong>Implementation</strong></p><p>When implementing a new algebra type, the methods <code>domain</code>, <code>TOP</code>, and <code>bot</code> should be implemented.</p><p>See also <a href="#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}"><code>bot</code></a>, <a href="#SoleLogics.BooleanAlgebra"><code>BooleanAlgebra</code></a>, <a href="../getting-started/#SoleLogics.Operator"><code>Operator</code></a>, <a href="@ref"><code>TOP</code></a>, <a href="#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, NTuple{N, Truth}}} where N"><code>collatetruth</code></a>, <a href="#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}"><code>domain</code></a>, <a href="#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}"><code>iscrisp</code></a>, <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><code>truthtype</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L291-L319">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><a class="docstring-binding" href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><code>SoleLogics.truthtype</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">truthtype(::Type{&lt;:AbstractAlgebra{T}}) where {T&lt;:Truth} = T
truthtype(a::AbstractAlgebra) = truthtype(typeof(a))</code></pre><p>The Julia type for representing truth values of the algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L322-L329">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}"><a class="docstring-binding" href="#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.domain</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">domain(a::AbstractAlgebra)</code></pre><p>Return an iterator to the values in the <code>domain</code> of a given algebra.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L333-L339">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}"><a class="docstring-binding" href="#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}"><code>SoleLogics.top</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">top(a::AbstractAlgebra)</code></pre><p>Return the top of a given algebra.</p><p>See also <a href="#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}"><code>bot</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L347-L353">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}"><a class="docstring-binding" href="#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.bot</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">bot(a::AbstractAlgebra)</code></pre><p>Return the bottom of a given algebra.</p><p>See also <a href="#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}"><code>top</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L358-L364">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}"><a class="docstring-binding" href="#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}"><code>SoleLogics.iscrisp</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">iscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))</code></pre><p>An algebra is crisp (or <em>boolean</em>) when its domain only has two values, namely, the top and the bottom. The antonym of crisp is <em>fuzzy</em>.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L369-L376">source</a></div></details></article><h2 id="logic"><a class="docs-heading-anchor" href="#logic">Logic</a><a id="logic-1"></a><a class="docs-heading-anchor-permalink" href="#logic" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.AbstractLogic"><a class="docstring-binding" href="#SoleLogics.AbstractLogic"><code>SoleLogics.AbstractLogic</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">abstract type AbstractLogic{G&lt;:AbstractGrammar,A&lt;:AbstractAlgebra} end</code></pre><p>Abstract type of a logic, which comprehends a context-free grammar (<em>syntax</em>) and an algebra (<em>semantics</em>).</p><p><strong>Interface</strong></p><ul><li><code>grammar(l::AbstractLogic)::AbstractGrammar</code></li><li><code>algebra(l::AbstractLogic)::AbstractAlgebra</code></li></ul><p><strong>Utility functions</strong></p><ul><li>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a></li><li>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a></li></ul><p><strong>Implementation</strong></p><p>When implementing a new logic type, the methods <code>grammar</code> and <code>algebra</code> should be implemented.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L383-L404">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar"><a class="docstring-binding" href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar"><code>SoleLogics.grammar</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">grammar(l::AbstractLogic{G})::G where {G&lt;:AbstractGrammar}</code></pre><p>Return the <code>grammar</code> of a given logic.</p><p>See also <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>, <a href="#algebra"><code>algebra</code></a>, <a href="#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}"><code>alphabet</code></a>, <a href="#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}"><code>formulas</code></a>, <a href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar"><code>grammar</code></a>, <a href="@ref"><code>operators</code></a>, <a href="#SoleLogics.truthtype-Union{Tuple{Type{&lt;:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T&lt;:Truth"><code>truthtype</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L407-L415">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}"><a class="docstring-binding" href="#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}"><code>SoleLogics.algebra</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">algebra(l::AbstractLogic{G,V})::V where {G,V}</code></pre><p>Return the <code>algebra</code> of a given logic.</p><p>See also <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/logic.jl#L432-L438">source</a></div></details></article><h2 id="more-about-connectives"><a class="docs-heading-anchor" href="#more-about-connectives">More on Connectives</a><a id="more-about-connectives-1"></a><a class="docs-heading-anchor-permalink" href="#more-about-connectives" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.NamedConnective"><a class="docstring-binding" href="#SoleLogics.NamedConnective"><code>SoleLogics.NamedConnective</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct NamedConnective{Symbol} &lt;: Connective end</code></pre><p>A singleton type for representing connectives defined by a name or a symbol.</p><p><strong>Examples</strong></p><p>The AND connective (i.e., the logical conjunction) is defined as the subtype:</p><pre><code class="language-julia hljs">const CONJUNCTION = NamedConnective{:∧}()
const ∧ = CONJUNCTION
arity(::typeof(∧)) = 2</code></pre><p>See also <a href="#SoleLogics.NEGATION"><code>NEGATION</code></a>, <a href="#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>, <a href="#SoleLogics.IMPLICATION"><code>IMPLICATION</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/syntactical.jl#L228-L242">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, NTuple{N, Truth}}} where N"><a class="docstring-binding" href="#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, NTuple{N, Truth}}} where N"><code>SoleLogics.collatetruth</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">collatetruth(c::Connective, ts::NTuple{N,T where T&lt;:Truth}, args...)::Truth where {N}</code></pre><p>Return the truth value for a composed formula <code>c(t1, ..., tN)</code>, given the <code>N</code> with t1, ..., tN being <code>Truth</code> values.</p><p>See also <a href="#SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, NTuple{N, Formula}}} where N"><code>simplify</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/syntactical.jl#L180-L187">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, NTuple{N, Formula}}} where N"><a class="docstring-binding" href="#SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, NTuple{N, Formula}}} where N"><code>SoleLogics.simplify</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">simplify(c::Connective, ts::NTuple{N,F where F&lt;:Formula} args...)::Truth where {N}</code></pre><p>Return a formula with the same semantics of a composed formula <code>c(φ1, ..., φN)</code>, given the <code>N</code> immediate sub-formulas.</p><p>See also <a href="#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, NTuple{N, Truth}}} where N"><code>collatetruth</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/syntactical.jl#L207-L215">source</a></div></details></article><h2 id="boolean-algebra"><a class="docs-heading-anchor" href="#boolean-algebra">Propositional boolean logic</a><a id="boolean-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#boolean-algebra" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.NEGATION"><a class="docstring-binding" href="#SoleLogics.NEGATION"><code>SoleLogics.NEGATION</code></a> — <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const NEGATION = NamedConnective{:¬}()
const ¬ = NEGATION
arity(::typeof(¬)) = 1</code></pre><p>Logical negation (also referred to as complement). It can be typed by <code>\neg&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L12-L21">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.CONJUNCTION"><a class="docstring-binding" href="#SoleLogics.CONJUNCTION"><code>SoleLogics.CONJUNCTION</code></a> — <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const CONJUNCTION = NamedConnective{:∧}()
const ∧ = CONJUNCTION
arity(::typeof(∧)) = 2</code></pre><p>Logical conjunction. It can be typed by <code>\wedge&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L32-L41">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.DISJUNCTION"><a class="docstring-binding" href="#SoleLogics.DISJUNCTION"><code>SoleLogics.DISJUNCTION</code></a> — <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const DISJUNCTION = NamedConnective{:∨}()
const ∨ = DISJUNCTION
arity(::typeof(∨)) = 2</code></pre><p>Logical disjunction. It can be typed by <code>\vee&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L48-L57">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.IMPLICATION"><a class="docstring-binding" href="#SoleLogics.IMPLICATION"><code>SoleLogics.IMPLICATION</code></a> — <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const IMPLICATION = NamedConnective{:→}()
const → = IMPLICATION
arity(::typeof(→)) = 2</code></pre><p>Logical implication. It can be typed by <code>\to&lt;tab&gt;</code>.</p><p>See also <a href="#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L64-L73">source</a></div></details></article><p>Boolean logic <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are regrouped in a single collection.</p><article><details class="docstring" open="true"><summary id="SoleLogics.BASE_CONNECTIVES"><a class="docstring-binding" href="#SoleLogics.BASE_CONNECTIVES"><code>SoleLogics.BASE_CONNECTIVES</code></a> — <span class="docstring-category">Constant</span></summary><div><pre><code class="language-julia hljs">const BASE_CONNECTIVES = [¬, ∧, ∨, →]</code></pre><p>Basic logical operators.</p><p>See also <a href="#SoleLogics.NEGATION"><code>NEGATION</code></a>, <a href="#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>, <a href="#SoleLogics.IMPLICATION"><code>IMPLICATION</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L576-L586">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.BooleanTruth"><a class="docstring-binding" href="#SoleLogics.BooleanTruth"><code>SoleLogics.BooleanTruth</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct BooleanTruth &lt;: Truth
    flag::Bool
end</code></pre><p>Structure for representing the Boolean truth values ⊤ and ⊥. It wraps a flag which takes value <code>true</code> for ⊤ (<a href="@ref"><code>TOP</code></a>), and <code>false</code> for ⊥ (<a href="@ref"><code>BOT</code></a>)</p><p>See also <a href="#SoleLogics.BooleanAlgebra"><code>BooleanAlgebra</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L83-L93">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.BooleanAlgebra"><a class="docstring-binding" href="#SoleLogics.BooleanAlgebra"><code>SoleLogics.BooleanAlgebra</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct BooleanAlgebra &lt;: AbstractAlgebra{Bool} end</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Boolean_algebra">Boolean algebra</a>, defined on the values TOP (representing <em>truth</em>) and BOT (for bottom, representing <em>falsehood</em>). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, of the integer cast of <code>true</code> and <code>false</code>, respectively.</p><p>See also <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L164-L174">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.BaseLogic"><a class="docstring-binding" href="#SoleLogics.BaseLogic"><code>SoleLogics.BaseLogic</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct BaseLogic{G&lt;:AbstractGrammar,A&lt;:AbstractAlgebra} &lt;: AbstractLogic{G,A}
    grammar::G
    algebra::A
end</code></pre><p>A basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.</p><p>See also <a href="#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G&lt;:SoleLogics.AbstractGrammar"><code>grammar</code></a>, <a href="#algebra"><code>algebra</code></a>, <a href="#SoleLogics.AbstractGrammar"><code>AbstractGrammar</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/base-logic.jl#L236-L247">source</a></div></details></article><p>A method is provided to simply access a propositional logic.</p><article><details class="docstring" open="true"><summary id="SoleLogics.propositionallogic-Tuple{}"><a class="docstring-binding" href="#SoleLogics.propositionallogic-Tuple{}"><code>SoleLogics.propositionallogic</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">propositionallogic(;
    alphabet = AlphabetOfAny{String}(),
    operators = NamedConnective[¬, ∧, ∨, →],
    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), NamedConnective[¬, ∧, ∨, →]),
    algebra = BooleanAlgebra()
)</code></pre><p>Instantiate a <a href="https://simple.wikipedia.org/wiki/Propositional_logic">propositional logic</a> given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (¬) isa operatorstype(propositionallogic())
true

julia&gt; (¬) isa operatorstype(propositionallogic(; operators = [∨]))
false

julia&gt; propositionallogic(; alphabet = [&quot;p&quot;, &quot;q&quot;]);

julia&gt; propositionallogic(; alphabet = ExplicitAlphabet([Atom(&quot;p&quot;), Atom(&quot;q&quot;)]));
</code></pre><p>See also <a href="../modal-logic/#SoleLogics.modallogic-Tuple{}"><code>modallogic</code></a>,  <a href="#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>, <a href="#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>, <a href="#SoleLogics.AlphabetOfAny"><code>AlphabetOfAny</code></a>, [<code>CompleteFlatGrammar</code>], <a href="#SoleLogics.BooleanAlgebra"><code>BooleanAlgebra</code></a>, <a href="@ref"><code>BASE_PROPOSITIONAL_CONNECTIVES</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/propositional-logic.jl#L29-L58">source</a></div></details></article><h1 id="Interpretations"><a class="docs-heading-anchor" href="#Interpretations">Interpretations</a><a id="Interpretations-1"></a><a class="docs-heading-anchor-permalink" href="#Interpretations" title="Permalink"></a></h1><p>Interpretations are nothing but dictionaries working with <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a> values, or other types that can be ultimately converted to <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p><article><details class="docstring" open="true"><summary id="SoleLogics.AbstractAssignment"><a class="docstring-binding" href="#SoleLogics.AbstractAssignment"><code>SoleLogics.AbstractAssignment</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">abstract type AbstractAssignment &lt;: Interpretation end</code></pre><p>Abstract type for assigments, that is, interpretations of propositional logic, encoding mappings from <a href="@ref"><code>AbstractAtom</code></a>s to <code>Truth</code> values.</p><p><strong>Interface</strong></p><ul><li><code>Base.haskey(i::AbstractAssignment, ::AbstractAtom)::Bool</code></li><li><code>inlinedisplay(i::AbstractAssignment)::String</code></li><li><code>interpret(a::AbstractAtom, i::AbstractAssignment, args...; kwargs...)::SyntaxLeaf</code></li></ul><p>See also <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="@ref"><code>AbstractAtom</code></a>, <a href="../getting-started/#SoleLogics.Interpretation"><code>Interpretation</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/propositional-logic.jl#L35-L47">source</a></div></details></article><article><details class="docstring" open="true"><summary id="Base.haskey-Tuple{SoleLogics.AbstractAssignment, Atom}"><a class="docstring-binding" href="#Base.haskey-Tuple{SoleLogics.AbstractAssignment, Atom}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">Base.haskey(i::AbstractAssignment, ::AbstractAtom)::Bool</code></pre><p>Return whether an <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a> has a truth value for a given <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>. If any object is passed, it is wrapped in an <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> and then checked.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; haskey(TruthDict([&quot;a&quot; =&gt; true, &quot;b&quot; =&gt; false, &quot;c&quot; =&gt; true]), Atom(&quot;a&quot;))
true

julia&gt; haskey(TruthDict(1:4, false), Atom(3))
true</code></pre><p>See also <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="../getting-started/#SoleLogics.Interpretation"><code>Interpretation</code></a>,  <a href="@ref"><code>AbstractAtom</code></a>, <a href="#SoleLogics.TruthDict"><code>TruthDict</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/types/propositional-logic.jl#L50-L68">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.TruthDict"><a class="docstring-binding" href="#SoleLogics.TruthDict"><code>SoleLogics.TruthDict</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct TruthDict{D&lt;:AbstractDict{A where A&lt;:Atom,T where T&lt;:Truth}} &lt;: AbstractAssignment
    truth::D
end</code></pre><p>A logical interpretation instantiated as a dictionary, explicitly assigning truth values to a <em>finite</em> set of atoms.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; TruthDict(1:4)
TruthDict with values:
┌────────┬────────┬────────┬────────┐
│      4 │      2 │      3 │      1 │
│  Int64 │  Int64 │  Int64 │  Int64 │
├────────┼────────┼────────┼────────┤
│      ⊤ │      ⊤ │      ⊤ │      ⊤ │
└────────┴────────┴────────┴────────┘


julia&gt; t1 = TruthDict(1:4, false); t1[5] = true; t1
TruthDict with values:
┌───────┬───────┬───────┬───────┬───────┐
│     5 │     4 │     2 │     3 │     1 │
│ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │
├───────┼───────┼───────┼───────┼───────┤
│     ⊤ │     ⊥ │     ⊥ │     ⊥ │     ⊥ │
└───────┴───────┴───────┴───────┴───────┘

julia&gt; t2 = TruthDict([&quot;a&quot; =&gt; true, &quot;b&quot; =&gt; false, &quot;c&quot; =&gt; true])
TruthDict with values:
┌────────┬────────┬────────┐
│      c │      b │      a │
│ String │ String │ String │
├────────┼────────┼────────┤
│      ⊤ │      ⊥ │      ⊤ │
└────────┴────────┴────────┘

julia&gt; check(parseformula(&quot;a ∨ b&quot;), t2)
true
</code></pre><div class="admonition is-info" id="Note-d4d28ff1c854996c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d4d28ff1c854996c" title="Permalink"></a></header><div class="admonition-body"><p>If prompted for the value of an unknown atom, this throws an error. If boolean, integer, or float values are specified, they are converted to <code>Truth</code> values. If the structure is initialized as empty, <a href="#SoleLogics.BooleanTruth"><code>BooleanTruth</code></a> values are assumed.</p></div></div><p>See also <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>,  <a href="../getting-started/#SoleLogics.Interpretation"><code>Interpretation</code></a>, <a href="#SoleLogics.DefaultedTruthDict"><code>DefaultedTruthDict</code></a>, <a href="#SoleLogics.BooleanTruth"><code>BooleanTruth</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/propositional-logic.jl#L79-L132">source</a></div></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.DefaultedTruthDict"><a class="docstring-binding" href="#SoleLogics.DefaultedTruthDict"><code>SoleLogics.DefaultedTruthDict</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct DefaultedTruthDict{
    D&lt;:AbstractDict{A where A&lt;:Atom,T where T&lt;:Truth},
    T&lt;:Truth
} &lt;: AbstractAssignment
    truth::D
    default_truth::T
end</code></pre><p>A truth table instantiated as a dictionary, plus a default value. This structure assigns truth values to a set of atoms and, when prompted for the value of an atom that is not in the dictionary, it returns <code>default_truth</code>.</p><p><strong>Implementation</strong></p><p>If you use <a href="../getting-started/#SoleLogics.interpret-Tuple{Formula, Interpretation, Vararg{Any}}"><code>interpret</code></a> function and you pass a <a href="#SoleLogics.DefaultedTruthDict"><code>DefaultedTruthDict</code></a> as <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>  and the <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> is not present in the dictionary, then the default dictionary value will be  returned and not the <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a> itself.</p><p>Here is an example of this.</p><pre><code class="language-julia-repl hljs">julia&gt; interpret(Atom(5), DefaultedTruthDict(string.(1:4), false))
⊥</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t1 = DefaultedTruthDict(string.(1:4), false); t1[&quot;5&quot;] = false; t1
DefaultedTruthDict with default truth `⊥` and values:
┌────────┬────────┬────────┬────────┬────────┐
│      4 │      1 │      5 │      2 │      3 │
│ String │ String │ String │ String │ String │
├────────┼────────┼────────┼────────┼────────┤
│      ⊤ │      ⊤ │      ⊥ │      ⊤ │      ⊤ │
└────────┴────────┴────────┴────────┴────────┘

julia&gt; check(parseformula(&quot;1 ∨ 2&quot;), t1)
true

julia&gt; check(parseformula(&quot;1 ∧ 5&quot;), t1)
false
</code></pre><p>See also <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="../getting-started/#SoleLogics.Interpretation"><code>Interpretation</code></a>, <a href="../getting-started/#SoleLogics.interpret-Tuple{Formula, Interpretation, Vararg{Any}}"><code>interpret</code></a>, <a href="../getting-started/#SoleLogics.Atom"><code>Atom</code></a>, <a href="#SoleLogics.TruthDict"><code>TruthDict</code></a>, <a href="#SoleLogics.DefaultedTruthDict"><code>DefaultedTruthDict</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/utils/propositional-logic.jl#L233-L281">source</a></div></details></article><p>To associate interpretations with their assignment, we can simply build a <a href="https://en.wikipedia.org/wiki/Truth_table">truth table</a>.</p><article><details class="docstring" open="true"><summary id="SoleLogics.TruthTable"><a class="docstring-binding" href="#SoleLogics.TruthTable"><code>SoleLogics.TruthTable</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct TruthTable{A,T&lt;:Truth}</code></pre><p>Dictionary which associates an <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>s to the truth value of the assignment itself on a <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>.</p><p>See also <a href="#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="../getting-started/#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.Truth"><code>Truth</code></a>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/47755a3c07ad4f0623895c31ce0525d403a5653b/src/deprecate.jl#L49-L56">source</a></div></details></article><pre><code class="nohighlight hljs">InterpretationSet

LogicalInstance{S&lt;:InterpretationSet}

check(φ::Formula, s::InterpretationSet, i_instance::Integer, args...; kwargs...)
check(φ::Formula, s::InterpretationSet, args...; kwargs...)

InterpretationVector{M&lt;:Interpretation}</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting started</a><a class="docs-footer-nextpage" href="../modal-logic/">Modal Logic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Tuesday 16 December 2025 13:21">Tuesday 16 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
