var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleLogics","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In this introductory section you will learn about the main building blocks of SoleLogics. Their definition, usage examples and how to customize them to your own needs. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In short, you can consider this package as divided into two halves.:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"the syntactical half, which defines structures to represent logical constructs such as assertions, logical constants, alphabets, grammars, crisp and fuzzy algebras, formulas etc. A consistent part of SoleLogics is devoted to randomly generate such structures, as well as parse and minimize formulas;\nthe semantic half, which defines rules to apply when interpreting a logical formulas. The \"semantic heart\" of SoleLogics is its finite model checking algorithm, whose purpose is to efficiently check whether a formula is satisfied by an interpretation or not.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Please, feel free to use the following tree structures to orient yourself in the reading of this section. More pieces will be added to this type-hierarchy tree in the following sections.","category":"page"},{"location":"getting-started/#Type-hierarchy","page":"Getting started","title":"Type hierarchy","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Syntactical\nConnective                      (e.g., ∧, ∨, ¬, →)\nFormula\nAbstractSyntaxStructure\nSyntaxTree              (e.g., ¬p ∧ q → s)\nSyntaxLeaf\nAtom            (e.g., p, q)\nTruth           (e.g., ⊤, ⊥)\nSyntaxBranch        (e.g., p ∧ q)\nAbstractInterpretation (e.g., p is ⊤, equivalent to p is true in boolean logic)","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Also, two union types are defined:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Operator, that is, Union{Connective,Truth}, \nSyntaxToken, that is, Union{Atom,Connective}.  ","category":"page"},{"location":"getting-started/#syntactical-base-definitions","page":"Getting started","title":"Syntax Basics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Syntactical","category":"page"},{"location":"getting-started/#SoleLogics.Syntactical","page":"Getting started","title":"SoleLogics.Syntactical","text":"abstract type Syntactical end\n\nMaster abstract type for all syntactical objects (e.g., formulas, connectives).\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To print out a generic Syntactical element, we must define how it is converted into a string. To do this, we can implement a custom syntaxstring.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"syntaxstring(s::Syntactical; kwargs...)","category":"page"},{"location":"getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}","page":"Getting started","title":"SoleLogics.syntaxstring","text":"syntaxstring(s::Syntactical; kwargs...)::String\n\nReturn the string representation of any syntactic object (e.g., Formula, SyntaxTree, SyntaxToken, Atom, Truth, etc). Note that this representation may introduce redundant parentheses. kwargs can be used to specify how to display syntax tokens/trees under some specific conditions.\n\nThe following kwargs are currently supported:\n\nfunction_notation = false::Bool: when set to true, it forces the use of  function notation for binary operators  (see here).\nremove_redundant_parentheses = true::Bool: when set to false, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.\nparenthesize_atoms = !remove_redundant_parentheses::Bool: when set to true,  it forces the atoms (which are the leaves of a formula's tree structure) to be  wrapped in parentheses.\n\nExamples\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"))\n\"p ∧ q ∧ r ∧ s ∧ t\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), function_notation=true)\n\"∧(∧(∧(∧(p, q), r), s), t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=false)\n\"((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"p∧q∧r∧s∧t\"), remove_redundant_parentheses=true, parenthesize_atoms=true)\n\"(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"))\n\"◊((p ∧ s) → q)\"\n\njulia> syntaxstring(parseformula(\"◊((p∧s)→q)\"); function_notation = true)\n\"◊(→(∧(p, s), q))\"\n\nSee also parseformula, SyntaxBranch, SyntaxToken.\n\nImplementation\n\nIn the case of a syntax tree, syntaxstring is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the syntaxstring must be defined (including the kwargs... part!) for every newly defined SyntaxToken (e.g., SyntaxLeafs, that is, Atoms and Truth values, and Operators), in a way that it produces a unique string representation, since Base.hash and Base.isequal, at least for SyntaxTrees, rely on it.\n\nIn particular, for the case of Atoms, the function calls itself on the wrapped value:\n\nsyntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)\n\nThe syntaxstring for any value defaults to its string representation, but it can be defined by defining the appropriate syntaxstring method.\n\nwarning: Warning\nThe syntaxstring for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon parsing. For similar reasons, syntaxstrings should not contain parentheses ('(', ')'), and, when parsing in function notation, commas (',').\n\nSee also SyntaxLeaf, Operator, parseformula.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Connective","category":"page"},{"location":"getting-started/#SoleLogics.Connective","page":"Getting started","title":"SoleLogics.Connective","text":"abstract type Connective <: Syntactical end\n\nAbstract type for logical connectives, that are used to express non-atomic statements; for example, CONJUNCTION, DISJUNCTION, NEGATION and IMPLICATION (stylized as ∧, ∨, ¬ and →).\n\nImplementation\n\nWhen implementing a new type C for a connective, please define its arity. For example, with a binary operator (e.g., ∨ or ∧):\n\narity(::C) = 2\n\nWhen implementing a new type C for a commutative connective with arity higher than 1, please provide a method iscommutative(::C). This can speed up model checking operations.\n\nWhen implementing a custom binary connective, one can override the default precedence and associativity (see here. If the custom connective is a NamedConnective and renders as something considered as a math symbol (for example, ⊙, see https://stackoverflow.com/a/60321302/5646732), by the Julia parser, Base.operator_precedence and Base.operator_associativity are used to define these behaviors, and you might want to avoid providing these methods at all.\n\nThe semantics of a propositional connective can be specified via collatetruth (see example below); in principle, the definition can rely on the partial order between truth values (specified via precedes).\n\nHere is an example of a custom implementation of the xor (⊻) Boolean operator.\n\nimport SoleLogics: arity, iscommutative, collatetruth\nconst ⊻ = SoleLogics.NamedConnective{:⊻}()\nSoleLogics.arity(::typeof(⊻)) = 2\nSoleLogics.iscommutative(::typeof(⊻)) = true\nSoleLogics.collatetruth(::typeof(⊻), (t1, t2)::NTuple{N,T where T<:BooleanTruth}) where {N} = (count(istop, (t1, t2)) == 1)\n\nNote that collatetruth must be defined at least for some truth value types T via methods accepting an NTuple{arity,T} as a second argument.\n\nTo make the operator work with incomplete interpretations (e.g., when the Truth value for an atom is not known), simplification rules for NTuple{arity,T where T<:Formula}s should be provided via methods for simplify. For example, these rules suffice for simplifying xors between TOP/BOT`s, and other formulas:\n\nimport SoleLogics: simplify\nsimplify(::typeof(⊻), (t1, t2)::Tuple{BooleanTruth,BooleanTruth}) = istop(t1) == istop(t2) ? BOT : TOP\nsimplify(::typeof(⊻), (t1, t2)::Tuple{BooleanTruth,Formula}) = istop(t1) ? ¬t2 : t2\nsimplify(::typeof(⊻), (t1, t2)::Tuple{Formula,BooleanTruth}) = istop(t2) ? ¬t1 : t1\n\nBeware of dispatch ambiguities!\n\nSee also arity, SyntaxBranch, associativity, precedence, check, iscommutative, NamedConnective, Syntactical.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"If the definition above overwhelms you, don't worry: it will be clearer later. For now we are simply interested in understanding that Connectives are simply symbols used to concatenate other logical constructs with each other. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Later, we will see some interesting example about how to equip these symbols with semantics, that is, what rules should be applied when interpreting connectives in a generic Formula. We will also understand how to define our own custom connectives.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"arity(φ::SyntaxTree)","category":"page"},{"location":"getting-started/#SoleLogics.arity-Tuple{SyntaxTree}","page":"Getting started","title":"SoleLogics.arity","text":"arity(φ::SyntaxTree)::Integer\narity(tok::Connective)::Integer\n\nReturn the arity of a Connective or a SyntaxTree. The arity is an integer representing the number of allowed children for a node in a tree. Connectives with arity equal to 0, 1 or 2 are called nullary, unary and binary, respectively. SyntaxLeafs (Atoms and Truth values) are always nullary.\n\nSee also SyntaxLeaf, Connective, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The vast majority of data structures involved in encoding a logical formula, are children of the Formula abstract type. When such data structures purely represents tree-shaped data structures (or single nodes in them), then they are also children of the AbstractSyntaxStructure abstract type.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Formula","category":"page"},{"location":"getting-started/#SoleLogics.Formula","page":"Getting started","title":"SoleLogics.Formula","text":"abstract type Formula <: Syntactical end\n\nAbstract type for logical formulas. Examples of Formulas are SyntaxLeafs (for example, Atoms and Truth values), AbstractSyntaxStructures (for example, SyntaxTrees and LeftmostLinearForms) and TruthTables ( enriched representation, which associates a syntactic structure with additional memoization structures, which can save computational time upon model checking).\n\nAny formula can be converted into its SyntaxTree representation via tree; its height can be computed, and it can be queried for its syntax tokens, atoms, etc... It can be parsed from its syntaxstring representation via parseformula.\n\nSee also tree, AbstractSyntaxStructure, SyntaxLeaf.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The following methods define Formula interface.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"tree(φ::Formula)\nheight(φ::Formula)\ntokens(φ::Formula)","category":"page"},{"location":"getting-started/#SoleLogics.tree-Tuple{Formula}","page":"Getting started","title":"SoleLogics.tree","text":"tree(φ::Formula)::SyntaxTree\n\nReturn the SyntaxTree representation of a formula; note that this is equivalent to Base.convert(SyntaxTree, φ).\n\nSee also Formula, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.height-Tuple{Formula}","page":"Getting started","title":"SoleLogics.height","text":"height(φ::Formula)::Integer\n\nReturn the height of a formula, in its syntax tree representation.\n\nSee also SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.tokens-Tuple{Formula}","page":"Getting started","title":"SoleLogics.tokens","text":"tokens(φ::Formula)::AbstractVector{<:SyntaxToken}\natoms(φ::Formula)::AbstractVector{<:Atom}\ntruths(φ::Formula)::AbstractVector{<:Truth}\nleaves(φ::Formula)::AbstractVector{<:SyntaxLeaf}\nconnectives(φ::Formula)::AbstractVector{<:Connective}\noperators(φ::Formula)::AbstractVector{<:Operator}\nntokens(φ::Formula)::Integer\nnatoms(φ::Formula)::Integer\nntruths(φ::Formula)::Integer\nnleaves(φ::Formula)::Integer\nnconnectives(φ::Formula)::Integer\nnoperators(φ::Formula)::Integer\n\nReturn the list/number of (non-unique) SyntaxTokens, Atoms, etc... appearing in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Now, let us see how to compose syntax elements, to express more complex concepts.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"composeformulas(c::Connective, φs::NTuple{N,F}) where {N,F<:Formula}","category":"page"},{"location":"getting-started/#SoleLogics.composeformulas-Union{Tuple{F}, Tuple{N}, Tuple{Connective, Tuple{Vararg{F, N}}}} where {N, F<:Formula}","page":"Getting started","title":"SoleLogics.composeformulas","text":"composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F<:Formula}\n\nReturn a new formula of type F by composing N formulas of the same type via a connective c. This function allows one to use connectives for flexibly composing formulas (see Implementation section).\n\nExamples\n\njulia> f = parseformula(\"◊(p→q)\");\n\njulia> p = Atom(\"p\");\n\njulia> ∧(f, p)  # Easy way to compose a formula\nSyntaxBranch: ◊(p → q) ∧ p\n\njulia> f ∧ ¬p   # Leverage infix notation ;) (see https://stackoverflow.com/a/60321302/5646732)\nSyntaxBranch: ◊(p → q) ∧ ¬p\n\njulia> ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))\nSyntaxBranch: ◊(p → q) ∧ p ∧ ¬p\n\nImplementation\n\nUpon composeformulas lies a flexible way of using connectives for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:\n\nfunction (c::Connective)(φs::NTuple{N,Formula}) where {N}\n    ...\nend\n\nThese allow composing formulas as in ∧(f, ¬p), and in order to access this composition with any newly defined subtype of Formula, a new method for composeformulas should be defined, together with promotion from/to other Formulas should be taken care of (see here and here).\n\nSimilarly, for allowing a (possibly newly defined) connective to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined connective c, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as ∧(f, f2, f3, ...) and ∨(f, f2, f3, ...) can be done thanks to the following two methods that were defined in SoleLogics:\n\nfunction ∧(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∧(c1, ∧(c2, c3, cs...))\nend\nfunction ∨(\n    c1::Formula,\n    c2::Formula,\n    c3::Formula,\n    cs::Formula...\n)\n    return ∨(c1, ∨(c2, c3, cs...))\nend\n\nnote: Note\nTo allow for the composition of Formulas of different types, promotion rules should be provided.\n\nSee also Formula, Connective.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We are ready to see how logical formulas are represented using syntax trees","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractSyntaxStructure\nSyntaxTree\nchildren(φ::SyntaxTree)\ntoken(φ::SyntaxTree)\narity(φ::SyntaxTree)\n\nSyntaxLeaf\nSyntaxToken\ndual(t::SyntaxToken)\nBase.in(tok::SyntaxToken, φ::SyntaxTree)\n\nAtom","category":"page"},{"location":"getting-started/#SoleLogics.AbstractSyntaxStructure","page":"Getting started","title":"SoleLogics.AbstractSyntaxStructure","text":"abstract type AbstractSyntaxStructure <: Formula end\n\nAbstract type for the purely-syntactic component of a logical formula (e.g., no fancy memoization structure associated). The typical representation is the SyntaxTree, however, different implementations can cover specific syntactic forms (e.g., conjunctive or disjunctive normal forms).\n\nSee also Formula, AbstractLogic, SyntaxTree, tree.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.SyntaxTree","page":"Getting started","title":"SoleLogics.SyntaxTree","text":"abstract type SyntaxTree <: AbstractSyntaxStructure end\n\nAbstract type for syntax trees; that is, syntax leaves (see SyntaxLeaf, such as Truth values and Atoms), and their composition via Connectives (i.e., SyntaxBranch).\n\nnote: Note\nNote that SyntaxTrees are ranked trees, and (should) adhere to the AbstractTrees interface.\n\nSee also SyntaxLeaf, SyntaxBranch, AbstractSyntaxStructure, Formula.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#AbstractTrees.children-Tuple{SyntaxTree}","page":"Getting started","title":"AbstractTrees.children","text":"children(φ::SyntaxTree)\n\nReturn the immediate children of a syntax tree.\n\nSee also SyntaxBranch, SyntaxLeaf.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.token-Tuple{SyntaxTree}","page":"Getting started","title":"SoleLogics.token","text":"token(φ::SyntaxTree)::SyntaxToken\n\nReturn the token at the root of a syntax tree.\n\nSee also SyntaxBranch, SyntaxLeaf.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.SyntaxLeaf","page":"Getting started","title":"SoleLogics.SyntaxLeaf","text":"abstract type SyntaxLeaf <: AbstractSyntaxStructure end\n\nAn atomic logical element, like a Truth value or an Atom. SyntaxLeafs have arity equal to zero, meaning that they are not allowed to have children in tree-like syntactic structures.\n\nSee also AbstractSyntaxStructure,  arity, SyntaxBranch.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.SyntaxToken","page":"Getting started","title":"SoleLogics.SyntaxToken","text":"const SyntaxToken = Union{Connective,SyntaxLeaf}\n\nUnion type for values wrapped in SyntaxTree nodes.\n\nSee also SyntaxTree, SyntaxLeaf, Connective.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.dual-Tuple{SyntaxToken}","page":"Getting started","title":"SoleLogics.dual","text":"dual(tok::SyntaxToken)\n\nReturn the dual of a syntax token.\n\nIf tok is an Operator of arity n, the dual dtok is such that, on a Boolean algebra, tok(ch_1, ..., ch_n) ≡ ¬dtok(¬ch_1, ..., ¬ch_n).\n\nDuality can be used to perform syntactic simplifications on formulas. For example, since ∧ and ∨ are duals, ¬(¬p ∧ ¬q) can be simplified to (p ∧ q) (De Morgan's law). Duality also applies to operators with existential/universal semantics (◊/□), to Truth values (⊤/⊥), and to Atoms.\n\nImplementation\n\nWhen providing a dual for an operator of type O, please also provide:\n\nhasdual(::O) = true\n\nThe dual of an Atom (that is, the atom with inverted semantics) is defined as:\n\ndual(p::Atom{V}) where {V} = Atom(dual(value(p)))\n\nAs such, hasdual(::V) and dual(::V) should be defined when wrapping objects of type A.\n\nSee also normalize, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Base.in-Tuple{SyntaxToken, SyntaxTree}","page":"Getting started","title":"Base.in","text":"Base.in(tok::SyntaxToken, φ::Formula)::Bool\n\nReturn whether a syntax token appears in a formula.\n\nSee also Formula, SyntaxToken.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.Atom","page":"Getting started","title":"SoleLogics.Atom","text":"struct Atom{V} <: SyntaxLeaf\n    value::V\nend\n\nAn atom, sometimes called an atomic proposition, propositional letter (or simply letter), of type Atom{V} wraps a value::V representing a fact which truth can be assessed on a logical interpretation.\n\nAtoms are nullary tokens (i.e, they are at the leaves of a syntax tree); note that their atoms cannot be Atoms.\n\nSee also AbstractInterpretation, atoms, check, SyntaxToken.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Truth","category":"page"},{"location":"getting-started/#SoleLogics.Truth","page":"Getting started","title":"SoleLogics.Truth","text":"abstract type Truth <: SyntaxLeaf end\n\nAbstract type for syntax leaves representing values of a lattice algebra. In Boolean logic, the two BooleanTruth values TOP (⊤) and BOT (⊥) are used.\n\nSee also BooleanTruth.\n\nImplementation\n\nA three-valued algebra, that is, an algebra with three truth values (top, bottom and unknown), can be based on the following Truth value definitions:\n\nimport SoleLogics: precedes\n\nabstract type ThreeVTruth <: Truth end\n\nstruct ThreeTop <: ThreeVTruth end\nconst ⫪ = ThreeTop() # Note that ⊤ is already use to indicate BooleanTruth's top.\nsyntaxstring(::ThreeTop; kwargs...) = \"⫪\"\n\nstruct ThreeBot <: ThreeVTruth end\nconst ⫫ = ThreeBot() # Note that ⊥ is already use to indicate BooleanTruth's top.\nsyntaxstring(::ThreeBot; kwargs...) = \"⫫\"\n\nstruct ThreeUnknown <: ThreeVTruth end\nconst υ = ThreeUnknown()\nsyntaxstring(::ThreeUnknown; kwargs...) = \"υ\"\n\nistop(t::ThreeTop) = true\nisbot(t::ThreeBot) = true\n\nprecedes(::ThreeBot, ::ThreeTop) = true\nprecedes(::ThreeBot, ::ThreeUnknown) = true\nprecedes(::ThreeUnknown, ::ThreeTop) = true\nprecedes(::ThreeTop, ::ThreeBot) = false\nprecedes(::ThreeUnknown, ::ThreeBot) = false\nprecedes(::ThreeTop, ::ThreeUnknown) = false\n\nNote that precedes is used to define the (partial) order between Truth values.\n\nSee also Connective, BooleanTruth.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Similarly to the Connectives case, Truth explanation could be unfamiliar at first sight. At the moment, what is of our interest is that SoleLogics provides us a simple interface to create custom, complex at will, algebras without worrying about adapting all the underlying algorithms (e.g., formulas generation, parsing, model checking etc.).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"istop(t::Truth)\nisbot(t::Truth)","category":"page"},{"location":"getting-started/#SoleLogics.istop-Tuple{Truth}","page":"Getting started","title":"SoleLogics.istop","text":"istop(::Truth)::Bool\n\nReturn true if the Truth value is the top of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nistop(t::Bool)::Bool = (t == true)\n\nSee also isbot, Truth.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.isbot-Tuple{Truth}","page":"Getting started","title":"SoleLogics.isbot","text":"isbot(::Truth)::Bool\n\nReturn true if the Truth value is the bottom of its algebra. For example, in the crisp case, with Bool truth values, it is:\n\nisbot(t::Bool)::Bool = (t == false)\n\nSee also istop, Truth.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The union of Connectives and Truth values are exactly what is called logical operators, or simply Operator. In SoleLogics, logical operators are splitted in two parts to highlight some differences that always holds (e.g., Truth values arity is always 0, while Connectives arity is always greater than 0); apart from this technical decision, many dispatches are defined using the more general union type Operator.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Operator","category":"page"},{"location":"getting-started/#SoleLogics.Operator","page":"Getting started","title":"SoleLogics.Operator","text":"const Operator = Union{Connective,Truth}\n\nUnion type for logical constants of any ariety (zero for Truth values, non-zero for Connectives).\n\nSee also Connective, Truth.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"An Operator can be used to compose syntax tokens (e.g., Atoms), SyntaxTrees and/or Formulas.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"    ¬(Atom(1)) ∨ Atom(1) ∧ ⊤\n    ∧(⊤,⊤)\n    ⊤()","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The internal nodes in a SyntaxTree definitely have ariety greater than 0, and thus, cannot wrap Atoms nor Truth values. To clearly distinguish internal nodes and leaves, the SyntaxBranch type is defined, making each SyntaxTree arity-complaint.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SyntaxBranch","category":"page"},{"location":"getting-started/#SoleLogics.SyntaxBranch","page":"Getting started","title":"SoleLogics.SyntaxBranch","text":"struct SyntaxBranch <: SyntaxTree\n    token::Connective\n    children::NTuple{N,SyntaxTree} where {N}\nend\n\nAn internal node of a syntax tree encoding a logical formula. Such a node holds a syntax token (a Connective, and has as many children as the arity of the token.\n\nThis implementation is arity-compliant, in that, upon construction, the arity of the token is checked against the number of children provided.\n\nExamples\n\njulia> p,q = Atom.([p, q])\n2-element Vector{Atom{String}}:\n Atom{String}: p\n Atom{String}: q\n\njulia> branch = SyntaxBranch(CONJUNCTION, p, q)\nSyntaxBranch: p ∧ q\n\njulia> token(branch)\n∧\n\njulia> syntaxstring.(children(branch))\n(p, q)\n\njulia> ntokens(a) == nconnectives(a) + nleaves(a)\ntrue\n\njulia> arity(a)\n2\n\njulia> height(a)\n1\n\nSee also token, children, arity, Connective, height, atoms, natoms, operators, noperators, tokens, ntokens,\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#semantics-base-definitions","page":"Getting started","title":"Semantics Basics","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"AbstractInterpretation\ninterpret(φ::Formula, i::AbstractInterpretation, args...; kwargs...)\ncheck(φ::Formula, i::AbstractInterpretation, args...; kwargs...)","category":"page"},{"location":"getting-started/#SoleLogics.AbstractInterpretation","page":"Getting started","title":"SoleLogics.AbstractInterpretation","text":"abstract type AbstractInterpretation end\n\nAbstract type for representing a logical interpretation. In the case of propositional logic, is essentially a map atom → truth value.\n\nProperties expressed via logical formulas can be checked on logical interpretations.\n\nSee also check, AbstractAssignment, AbstractKripkeStructure.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Getting started","title":"SoleLogics.interpret","text":"interpret(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Formula\n\nReturn the truth value for a formula on a logical interpretation (or model).\n\nExamples\n\njulia> @atoms p q\n2-element Vector{Atom{String}}:\n p\n q\n\njulia> td = TruthDict([p => true, q => false])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> interpret(CONJUNCTION(p,q), td)\n⊥\n\nSee also check, Formula, AbstractInterpretation, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}","page":"Getting started","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on a logical interpretation (or model), returning true if the truth value for the formula istop. This process is referred to as (finite) model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => TOP, q => BOT])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also interpret, Formula, AbstractInterpretation, TruthDict.\n\n\n\n\n\n","category":"method"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"CurrentModule = SoleLogics","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"Pages = [\"fuzzy.md\"]","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/#fuzzy-introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"SoleLogics also provides tools to work with many-valued logics (e.g., fuzzy logics), that is, logics with more truth values other than the classical Boolean ones ⊤ and ⊥. With many-valued logics, the truth values are part of a bounded lattice encoding a partial order between them, encoding a truer than relation.","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"The main reference, here, is Many-Valued Modal Logics by Melvin Fitting.","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/#heytingtruth","page":"Introduction","title":"HeytingTruth","text":"","category":"section"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"HeytingTruth\nheytingtruths","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/#heytingalgebra","page":"Introduction","title":"HeytingAlgebra","text":"","category":"section"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"HeytingAlgebra\nheytingalgebra","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/#fuzzy-example","page":"Introduction","title":"A simple example","text":"","category":"section"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"Let's take as an example the simplest meaningful Heyting Algebra, characterised by the 4 values ⊥, α, β, and ⊤, where α and β are both greater than ⊥ but lesser than ⊤.","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"This could be represented by the following bounded lattice:","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"   ⊤\n /   \\\nα     β\n \\   /\n   ⊥","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"To declare a new Heyting algebra in SoleLogics, we can use the heytingalgebra macro, which takes as input a tuple containing the symbols representing the new values of the algebra other than ⊥ and ⊤, and the direct relations between these values, with each relation being a tuple (t1, t2) asserting that t1 < t2. The macro will take care of the declaration of HeytingTruths.","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"!!!info     Please note how both the HeytingTruths and the HeytingAlgebra defined in this way are declared as constants in the global scope.","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"julia> SoleLogics.@heytingalgebra myalgebra (α, β) (⊥, α) (⊥, β) (α, ⊤) (β, ⊤)\nHeytingAlgebra(HeytingTruth[⊤, ⊥, α, β], SimpleDiGraph{Int64}(4, [Int64[], [3, 4], [1], [1]], [[3, 4], Int64[], [2], [2]]))","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"The classical Boolean connectives are extended to the meet (lower greatest bound), join (greater lowest bound) and Heyting implication operations. These are computed via the collatetruth method, which requires the algebra as an additional argument.","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"!!!info     Note how the truth values have no meaning by themselves, and they must always be associated with an algebra!","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"julia> collatetruth(∧, (α, β), myalgebra)\nHeytingTruth: ⊥\n\njulia> collatetruth(∨, (α, β), myalgebra)\nHeytingTruth: ⊤\n\njulia>  collatetruth(→, (α, β), myalgebra)\nHeytingTruth: β","category":"page"},{"location":"old-code/many-valued-logics/heyting-algebras/","page":"Introduction","title":"Introduction","text":"```","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Pages = [\"base-logic.md\"]","category":"page"},{"location":"base-logic/#base-logic-introduction","page":"Introduction to Logics and Propositional Logic","title":"Introduction","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"At the end of this chapter, you are going to understand how Atoms and Truth values are arranged into alphabets and grammars.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"You will also get an in-depth view of how boolean Truth values and boolean Connective's are defined from both a syntax and a syntactical standpoint of view.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Finally, you will get a clearer idea about how to represent and manipulate interpretations and their outcomes.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Recalling the type hierarchy presented in man-core, it is here enriched with the following new types and structures.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Truth\nBooleanTruth\nConnective\nNamedConnective\nNEGATION\nCONJUNCTION \nDISJUNCTION\nIMPLICATION\nAbstractAlphabet\nExplicitAlphabet\nAlphabetOfAny\nAbstractGrammar\nCompleteFlatGrammar\nAbstractAlgebra\nBooleanAlgebra\nAbstractLogic\nBaseLogic\nAbstractInterpretation\nAbstractAssignment\nTruthDict\nDefaultedTruthDict\nAbstractInterpretationSet\nInterpretationVector\nLogicalInstance \nTruthTable\nLogicalInstance","category":"page"},{"location":"base-logic/#alphabets","page":"Introduction to Logics and Propositional Logic","title":"Alphabet","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractAlphabet{V}\nBase.isfinite(::Type{<:AbstractAlphabet})\natoms(a::AbstractAlphabet)\nBase.in(p::Atom, a::AbstractAlphabet)\nBase.length(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet)\n\nExplicitAlphabet{V}\nAlphabetOfAny{V}","category":"page"},{"location":"base-logic/#SoleLogics.AbstractAlphabet","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractAlphabet","text":"abstract type AbstractAlphabet{V} end\n\nAbstract type for representing an alphabet of atoms with values of type V. An alphabet (or propositional alphabet) is a set of atoms (assumed to be countable).\n\nExamples\n\njulia> Atom(1) in ExplicitAlphabet(Atom.(1:10))\ntrue\n\njulia> Atom(1) in ExplicitAlphabet(1:10)\ntrue\n\njulia> Atom(1) in AlphabetOfAny{String}()\nfalse\n\njulia> Atom(\"mystring\") in AlphabetOfAny{String}()\ntrue\n\njulia> \"mystring\" in AlphabetOfAny{String}()\n┌ Warning: Please, use Base.in(Atom(mystring), alphabet::AlphabetOfAny{String}) instead of Base.in(mystring, alphabet::AlphabetOfAny{String})\n└ @ SoleLogics ...\ntrue\n\nImplementation\n\nWhen implementing a new alphabet type MyAlphabet, you should provide a method for establishing whether an atom belongs to it or not; while, in general, this method should be:\n\nfunction Base.in(p::Atom, a::MyAlphabet)::Bool\n\nin the case of finite alphabets, it suffices to define a method:\n\nfunction atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nBy default, an alphabet is considered finite:\n\nBase.isfinite(::Type{<:AbstractAlphabet}) = true\nBase.isfinite(a::AbstractAlphabet) = Base.isfinite(typeof(a))\nBase.in(p::Atom, a::AbstractAlphabet) = Base.isfinite(a) ? Base.in(p, atoms(a)) : error(...)\n\nSee also AbstractGrammar, AlphabetOfAny, Atom, ExplicitAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#Base.isfinite-Tuple{Type{<:SoleLogics.AbstractAlphabet}}","page":"Introduction to Logics and Propositional Logic","title":"Base.isfinite","text":"Base.isfinite(a::AbstractAlphabet)\n\nReturn true if the alphabet is finite, false otherwise.\n\nSee AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.atoms","text":"atoms(a::AbstractAlphabet)::AbstractVector{atomstype(a)}\n\nList the atoms of a finite alphabet.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Base.in-Tuple{Atom, SoleLogics.AbstractAlphabet}","page":"Introduction to Logics and Propositional Logic","title":"Base.in","text":"Base.in(p::Atom, a::AbstractAlphabet)::Bool\n\nReturn whether an atom belongs to an alphabet.\n\nSee also AbstractAlphabet, Atom.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Base.iterate-Tuple{SoleLogics.AbstractAlphabet}","page":"Introduction to Logics and Propositional Logic","title":"Base.iterate","text":"Base.iterate(a::AbstractAlphabet)\nBase.iterate(a::AbstractAlphabet, state)\n\nReturn an iterator to the next element in an alhabet.\n\nSee also AbstractAlphabet, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.ExplicitAlphabet","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.ExplicitAlphabet","text":"struct ExplicitAlphabet{V} <: AbstractAlphabet{V}\n    atoms::Vector{Atom{V}}\nend\n\nAn alphabet wrapping atoms in a (finite) Vector.\n\nSee also AbstractAlphabet, atoms.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.AlphabetOfAny","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AlphabetOfAny","text":"struct AlphabetOfAny{V} <: AbstractAlphabet{V} end\n\nAn implicit, infinite alphabet that includes all atoms with values of a subtype of V.\n\nSee also AbstractAlphabet.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#grammars","page":"Introduction to Logics and Propositional Logic","title":"Grammar","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractGrammar{V<:AbstractAlphabet,O<:Operator} \nalphabet(g::AbstractGrammar{V} where {V})\nBase.in(φ::SyntaxTree, g::AbstractGrammar)\nformulas(g::AbstractGrammar; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing, args...)\n\nCompleteFlatGrammar{V<:AbstractAlphabet,O<:Operator}\nconnectives(g::AbstractGrammar)\nleaves(g::AbstractGrammar)\n\nformulas(g::CompleteFlatGrammar{V,O} where {V,O}; maxdepth::Integer, nformulas::Union{Nothing,Integer} = nothing)","category":"page"},{"location":"base-logic/#SoleLogics.AbstractGrammar","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractGrammar","text":"abstract type AbstractGrammar{V<:AbstractAlphabet,O<:Operator} end\n\nAbstract type for representing a context-free grammar based on a single alphabet of type V, and a set of operators that consists of all the (singleton) child types of O. V context-free grammar is a simple structure for defining formulas inductively.\n\nSee also alphabet, AbstractAlphabet, Operator.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.alphabet-Tuple{SoleLogics.AbstractGrammar{V} where V}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.alphabet","text":"alphabet(g::AbstractGrammar{V} where {V})::V\n\nReturn the propositional alphabet of a grammar.\n\nSee also AbstractAlphabet, AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Base.in-Tuple{SyntaxTree, SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"Base.in","text":"Base.in(φ::SyntaxTree, g::AbstractGrammar)::Bool\n\nReturn whether a SyntaxTree, belongs to a grammar.\n\nSee also AbstractGrammar, SyntaxTree.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.formulas-Tuple{SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.formulas","text":"formulas(\n    g::AbstractGrammar;\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing,\n    args...\n)::Vector{<:SyntaxBranch}\n\nEnumerate the formulas produced by a given grammar with a finite and iterable alphabet.\n\nImplementation\n\nAdditional args can be used to model the function's behavior. At least these two arguments should be covered:\n\na nformulas argument can be used to limit the size of the returned Vector;\na maxdepth argument can be used to limit the syntactic component, represented as a syntax tree,\n\nto a given maximum depth;\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.CompleteFlatGrammar","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.CompleteFlatGrammar","text":"struct CompleteFlatGrammar{V<:AbstractAlphabet,O<:Operator} <: AbstractGrammar{V,O}\n    alphabet::V\n    operators::Vector{<:O}\nend\n\nV grammar of all well-formed formulas obtained by the arity-complying composition of atoms of an alphabet of type V, and all operators in operators. With n operators, this grammar has exactly n+1 production rules. For example, with operators = [∧,∨], the grammar (in Backus-Naur form) is:\n\nφ ::= p | φ ∧ φ | φ ∨ φ\n\nwith p ∈ alphabet. Note: it is flat in the sense that all rules substitute the same (unique and starting) non-terminal symbol φ.\n\nSee also AbstractGrammar, Operator, alphabet, formulas, connectives, operators, leaves.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.connectives-Tuple{SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.connectives","text":"connectives(g::AbstractGrammar)\n\nList all connectives appearing in a grammar.\n\nSee also Connective, nconnectives.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.leaves-Tuple{SoleLogics.AbstractGrammar}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.leaves","text":"leaves(g::AbstractGrammar)\n\nList all leaves appearing in a grammar.\n\nSee also SyntaxLeaf, nleaves.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.formulas-Tuple{SoleLogics.CompleteFlatGrammar{V, O} where {V, O}}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.formulas","text":"formulas(\n    g::CompleteFlatGrammar{V,O} where {V,O};\n    maxdepth::Integer,\n    nformulas::Union{Nothing,Integer} = nothing\n)::Vector{SyntaxBranch}\n\nGenerate all formulas whose SyntaxBranchs that are not taller than a given maxdepth.\n\nSee also AbstractGrammar, SyntaxBranch.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#algebra","page":"Introduction to Logics and Propositional Logic","title":"Algebra","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractAlgebra{T<:Truth}\ntruthtype(::Type{<:AbstractAlgebra{T}}) where {T<:Truth}\ndomain(a::AbstractAlgebra)\ntop(a::AbstractAlgebra{T} where {T})\nbot(a::AbstractAlgebra)\niscrisp(a::AbstractAlgebra)","category":"page"},{"location":"base-logic/#SoleLogics.AbstractAlgebra","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractAlgebra","text":"abstract type AbstractAlgebra{T<:Truth} end\n\nAbstract type for representing algebras. Algebras are used for grounding the truth of atoms and the semantics of operators. They typically encode a lattice structure where two elements(or nodes) ⊤ and ⊥ are referred to as TOP (or maximum) and bot (or minimum). Each node in the lattice represents a truth value that an atom or a formula can have on an interpretation, and the semantics of operators is given in terms of operations between truth values.\n\nImplementation\n\nWhen implementing a new algebra type, the methods domain, TOP, and bot should be implemented.\n\nSee also bot, BooleanAlgebra, Operator, TOP, collatetruth, domain, iscrisp, truthtype.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.truthtype-Union{Tuple{Type{<:SoleLogics.AbstractAlgebra{T}}}, Tuple{T}} where T<:Truth","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.truthtype","text":"truthtype(::Type{<:AbstractAlgebra{T}}) where {T<:Truth} = T\ntruthtype(a::AbstractAlgebra) = truthtype(typeof(a))\n\nThe Julia type for representing truth values of the algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.domain-Tuple{SoleLogics.AbstractAlgebra}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.domain","text":"domain(a::AbstractAlgebra)\n\nReturn an iterator to the values in the domain of a given algebra.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.top-Tuple{SoleLogics.AbstractAlgebra{T} where T}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.top","text":"top(a::AbstractAlgebra)\n\nReturn the top of a given algebra.\n\nSee also bot, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.bot-Tuple{SoleLogics.AbstractAlgebra}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.bot","text":"bot(a::AbstractAlgebra)\n\nReturn the bottom of a given algebra.\n\nSee also top, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.iscrisp-Tuple{SoleLogics.AbstractAlgebra}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.iscrisp","text":"iscrisp(a::AbstractAlgebra) = iscrisp(typeof(a))\n\nAn algebra is crisp (or boolean) when its domain only has two values, namely, the top and the bottom. The antonym of crisp is fuzzy.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#logic","page":"Introduction to Logics and Propositional Logic","title":"Logic","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractLogic{G<:AbstractGrammar,A<:AbstractAlgebra}\ngrammar(l::AbstractLogic{G}) where {G<:AbstractGrammar}\nalgebra(l::AbstractLogic{G,V}) where {G,V}","category":"page"},{"location":"base-logic/#SoleLogics.AbstractLogic","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractLogic","text":"abstract type AbstractLogic{G<:AbstractGrammar,A<:AbstractAlgebra} end\n\nAbstract type of a logic, which comprehends a context-free grammar (syntax) and an algebra (semantics).\n\nImplementation\n\nWhen implementing a new logic type, the methods grammar and algebra should be implemented.\n\nSee also AbstractAlgebra, AbstractGrammar.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.grammar-Union{Tuple{SoleLogics.AbstractLogic{G}}, Tuple{G}} where G<:SoleLogics.AbstractGrammar","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.grammar","text":"grammar(l::AbstractLogic{G})::G where {G<:AbstractGrammar}\n\nReturn the grammar of a given logic.\n\nSee also AbstractGrammar, AbstractLogic, algebra, alphabet, formulas, grammar, operators, truthtype.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.algebra-Union{Tuple{SoleLogics.AbstractLogic{G, V}}, Tuple{V}, Tuple{G}} where {G, V}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.algebra","text":"algebra(l::AbstractLogic{G,V})::V where {G,V}\n\nReturn the algebra of a given logic.\n\nSee also AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#more-about-connectives","page":"Introduction to Logics and Propositional Logic","title":"More on Connectives","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"NamedConnective{Symbol}\ncollatetruth(c::Connective, ts::NTuple{N,T where T<:Truth}) where {N}\nsimplify(c::Connective, ts::NTuple{N,F where F<:Formula}) where {N}","category":"page"},{"location":"base-logic/#SoleLogics.NamedConnective","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.NamedConnective","text":"struct NamedConnective{Symbol} <: Connective end\n\nA singleton type for representing connectives defined by a name or a symbol.\n\nExamples\n\nThe AND connective (i.e., the logical conjunction) is defined as the subtype:\n\nconst CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.collatetruth-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Truth, N}}}} where N","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.collatetruth","text":"collatetruth(c::Connective, ts::NTuple{N,T where T<:Truth})::Truth where {N}\n\nReturn the truth value for a composed formula c(t1, ..., tN), given the N with t1, ..., tN being Truth values.\n\nSee also simplify, Connective, Truth.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.simplify-Union{Tuple{N}, Tuple{Connective, Tuple{Vararg{Formula, N}}}} where N","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.simplify","text":"simplify(c::Connective, ts::NTuple{N,F where F<:Formula})::Truth where {N}\n\nReturn a formula with the same semantics of a composed formula c(φ1, ..., φN), given the N immediate sub-formulas.\n\nSee also collatetruth, Connective, Formula.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#boolean-algebra","page":"Introduction to Logics and Propositional Logic","title":"Propositional boolean logic","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"NEGATION\nCONJUNCTION\nDISJUNCTION\nIMPLICATION","category":"page"},{"location":"base-logic/#SoleLogics.NEGATION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.NEGATION","text":"const NEGATION = NamedConnective{:¬}()\nconst ¬ = NEGATION\narity(::typeof(¬)) = 1\n\nLogical negation (also referred to as complement). It can be typed by \\neg<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/#SoleLogics.CONJUNCTION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.CONJUNCTION","text":"const CONJUNCTION = NamedConnective{:∧}()\nconst ∧ = CONJUNCTION\narity(::typeof(∧)) = 2\n\nLogical conjunction. It can be typed by \\wedge<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/#SoleLogics.DISJUNCTION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.DISJUNCTION","text":"const DISJUNCTION = NamedConnective{:∨}()\nconst ∨ = DISJUNCTION\narity(::typeof(∨)) = 2\n\nLogical disjunction. It can be typed by \\vee<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/#SoleLogics.IMPLICATION","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.IMPLICATION","text":"const IMPLICATION = NamedConnective{:→}()\nconst → = IMPLICATION\narity(::typeof(→)) = 2\n\nLogical implication. It can be typed by \\to<tab>.\n\nSee also NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Boolean logic Connectives are regrouped in a single collection.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"BASE_CONNECTIVES","category":"page"},{"location":"base-logic/#SoleLogics.BASE_CONNECTIVES","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BASE_CONNECTIVES","text":"const BASE_CONNECTIVES = [¬, ∧, ∨, →]\n\nBasic logical operators.\n\nSee also NEGATION, CONJUNCTION, DISJUNCTION, IMPLICATION, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"BooleanTruth","category":"page"},{"location":"base-logic/#SoleLogics.BooleanTruth","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BooleanTruth","text":"struct BooleanTruth <: Truth\n    flag::Bool\nend\n\nStructure for representing the Boolean truth values ⊤ and ⊥. It wraps a flag which takes value true for ⊤ (TOP), and false for ⊥ (BOT)\n\nSee also BooleanAlgebra.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"BooleanAlgebra\nBaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra}","category":"page"},{"location":"base-logic/#SoleLogics.BooleanAlgebra","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BooleanAlgebra","text":"struct BooleanAlgebra <: AbstractAlgebra{Bool} end\n\nA Boolean algebra, defined on the values TOP (representing truth) and BOT (for bottom, representing falsehood). For this algebra, the basic operators negation, conjunction and disjunction (stylized as ¬, ∧, ∨) can be defined as the complement, minimum and maximum, of the integer cast of true and false, respectively.\n\nSee also Truth.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.BaseLogic","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.BaseLogic","text":"struct BaseLogic{G<:AbstractGrammar,A<:AbstractAlgebra} <: AbstractLogic{G,A}\n    grammar::G\n    algebra::A\nend\n\nA basic logic based on a grammar and an algebra, where both the grammar and the algebra are instantiated.\n\nSee also grammar, algebra, AbstractGrammar, AbstractAlgebra, AbstractLogic.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"A method is provided to simply access a propositional logic.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"    propositionallogic(; alphabet = AlphabetOfAny{String}(), operators = $(BASE_PROPOSITIONAL_CONNECTIVES), grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), $(BASE_PROPOSITIONAL_CONNECTIVES)), algebra = BooleanAlgebra())","category":"page"},{"location":"base-logic/#SoleLogics.propositionallogic-Tuple{}","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.propositionallogic","text":"propositionallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = NamedConnective[¬, ∧, ∨, →],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), NamedConnective[¬, ∧, ∨, →]),\n    algebra = BooleanAlgebra()\n)\n\nInstantiate a propositional logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(propositionallogic())\ntrue\n\njulia> (¬) isa operatorstype(propositionallogic(; operators = [∨]))\nfalse\n\njulia> propositionallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> propositionallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also modallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#Interpretations","page":"Introduction to Logics and Propositional Logic","title":"Interpretations","text":"","category":"section"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"Interpretations are nothing but dictionaries working with Truth values, or other types that can be ultimately converted to Truth.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractAssignment\nBase.haskey(i::AbstractAssignment, ::Atom)\nTruthDict{D<:AbstractDict{A where A<:Atom,T where T<:Truth}}\nDefaultedTruthDict{D<:AbstractDict{A where A<:Atom,T where T<:Truth}, T<:Truth}","category":"page"},{"location":"base-logic/#SoleLogics.AbstractAssignment","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.AbstractAssignment","text":"abstract type AbstractAssignment <: AbstractInterpretation end\n\nAbstract type for assigments, that is, interpretations of propositional logic, encoding mappings from Atoms to Truth values.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#Base.haskey-Tuple{SoleLogics.AbstractAssignment, Atom}","page":"Introduction to Logics and Propositional Logic","title":"Base.haskey","text":"Base.haskey(i::AbstractAssignment, ::Atom)::Bool\n\nReturn whether an assigment has a truth value for a given atom.\n\nSee also AbstractInterpretation.\n\n\n\n\n\n","category":"method"},{"location":"base-logic/#SoleLogics.TruthDict","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.TruthDict","text":"struct TruthDict{D<:AbstractDict{A where A<:Atom,T where T<:Truth}} <: AbstractAssignment\n    truth::D\nend\n\nA logical interpretation instantiated as a dictionary, explicitly assigning truth values to a finite set of atoms.\n\nExamples\n\njulia> TruthDict(1:4)\nTruthDict with values:\n┌────────┬────────┬────────┬────────┐\n│      4 │      2 │      3 │      1 │\n│  Int64 │  Int64 │  Int64 │  Int64 │\n├────────┼────────┼────────┼────────┤\n│      ⊤ │      ⊤ │      ⊤ │      ⊤ │\n└────────┴────────┴────────┴────────┘\n\n\njulia> t1 = TruthDict(1:4, false); t1[5] = true; t1\nTruthDict with values:\n┌───────┬───────┬───────┬───────┬───────┐\n│     5 │     4 │     2 │     3 │     1 │\n│ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │\n├───────┼───────┼───────┼───────┼───────┤\n│     ⊤ │     ⊥ │     ⊥ │     ⊥ │     ⊥ │\n└───────┴───────┴───────┴───────┴───────┘\n\njulia> t2 = TruthDict([\"a\" => true, \"b\" => false, \"c\" => true])\nTruthDict with values:\n┌────────┬────────┬────────┐\n│      c │      b │      a │\n│ String │ String │ String │\n├────────┼────────┼────────┤\n│      ⊤ │      ⊥ │      ⊤ │\n└────────┴────────┴────────┘\n\njulia> check(parseformula(\"a ∨ b\"), t2)\ntrue\n\n\nnote: Note\nIf prompted for the value of an unknown atom, this throws an error. If boolean, integer, or float values are specified, they are converted to Truth values. If the structure is initialized as empty, BooleanTruth values are assumed.\n\nSee also DefaultedTruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/#SoleLogics.DefaultedTruthDict","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.DefaultedTruthDict","text":"struct DefaultedTruthDict{\n    D<:AbstractDict{A where A<:Atom,T where T<:Truth},\n    T<:Truth\n} <: AbstractAssignment\n    truth::D\n    default_truth::T\nend\n\nA truth table instantiated as a dictionary, plus a default value. This structure assigns truth values to a set of atoms and, when prompted for the value of an atom that is not in the dictionary, it returns default_truth.\n\nExamples\n\njulia> t1 = DefaultedTruthDict(string.(1:4), false); t1[\"5\"] = false; t1\nDefaultedTruthDict with default truth `⊥` and values:\n┌────────┬────────┬────────┬────────┬────────┐\n│      4 │      1 │      5 │      2 │      3 │\n│ String │ String │ String │ String │ String │\n├────────┼────────┼────────┼────────┼────────┤\n│      ⊤ │      ⊤ │      ⊥ │      ⊤ │      ⊤ │\n└────────┴────────┴────────┴────────┴────────┘\n\njulia> check(parseformula(\"1 ∨ 2\"), t1)\ntrue\n\njulia> check(parseformula(\"1 ∧ 5\"), t1)\nfalse\n\n\nSee also TruthDict, AbstractAssignment, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"To associate interpretations with their assignment, we can simply build a truth table.","category":"page"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"TruthTable{A,T<:Truth}","category":"page"},{"location":"base-logic/#SoleLogics.TruthTable","page":"Introduction to Logics and Propositional Logic","title":"SoleLogics.TruthTable","text":"struct TruthTable{A,T<:Truth}\n\nDictionary which associates an AbstractAssignments to the truth value of the assignment itself on a AbstractSyntaxStructure.\n\nSee also AbstractAssignment, AbstractSyntaxStructure, Truth.\n\n\n\n\n\n","category":"type"},{"location":"base-logic/","page":"Introduction to Logics and Propositional Logic","title":"Introduction to Logics and Propositional Logic","text":"AbstractInterpretationSet\n\nLogicalInstance{S<:AbstractInterpretationSet}\n\ncheck(φ::Formula, s::AbstractInterpretationSet, i_instance::Integer, args...; kwargs...)\ncheck(φ::Formula, s::AbstractInterpretationSet, args...; kwargs...)\n\nInterpretationVector{M<:AbstractInterpretation}","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"CurrentModule = SoleLogics","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Pages = [\"modal-logic.md\"]","category":"page"},{"location":"modal-logic/#modal-logic-introduction","page":"Modal Logic","title":"Introduction","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"At the end of this chapter, you are going to understand what modal logic is, and why it is so important from a computational standpoint of view, with respect to propositional logic and first order logic. For those of you who want to fully immerse in the topic, we recommend reading the thesis Foundations of Modal Symbolic Learning, by Stan Ionel Eduard. ","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Recalling the type hierarchy presented in man-core, it is here enriched with the following new types and structures.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Connective\nNamedConnective\nDIAMOND\nBOX\nAbstractRelationalConnective\nDiamondRelationalConnective\nBoxRelationalConnective\nAbstractWorld\nWorld\nAbstractFrame\nAbstractUniModalFrame\nAbstractMultiModalFrame\nWrapperMultiModalFrame\nAbstractRelation\nAbstractInterpretation\nAbstractKripkeStructure\nKripkeStructure","category":"page"},{"location":"modal-logic/#modal-logic-pills","page":"Modal Logic","title":"Pills of Modal Logic","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Narrowly speaking, modal logic was initially investigated as the logic of necessary and possible truths judgments due to Aristotle's foresighted analysis of statements containing the words \"necessary\" and \"possible\".","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Modal logic is, essentially, Propositional Logic enriched with a set of modal connectives (or modalities), that are used to express some form of quantification over a set of entities. Interpretations in modal logic act as directed, possibly many-relation graphs of propositional assigments, and are called Kripke structures. The vertices in the graph model the entities, and are called possible worlds (or, simply, worlds). Furthermore, worlds are connected via one or more accessibility relations, and each world has a propositional assignment. Modal formula are, generally, interpreted on specific worlds of Kripke structures.","category":"page"},{"location":"modal-logic/#why-modal-logic","page":"Modal Logic","title":"Why Modal Logic? An introduction","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Very often real-world applications give rise to non-static sets of data (e.g., temporal, spatial, graph-based data). The standard approach is to pre-process such data, so that their aspect becomes easy to fit in a tabular structure (e.g., datasets, spreadsheets).","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Pre-processing non-static data means denaturing it: we want to deal with this kind of data natively, avoiding losing valuable information about its structure. Because of this, we require a logic which is more expressive than propositional one. This is where modal logic comes in.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Imagine the following scenario: you have a speech audio sample of 9 seconds and you want to establish whether the propositional letter p is true or no on the sample. Let's say that p is the fact the audio is loud. The latter is referred to the sample in its entirety: by looking at it as a whole we can compute whether p is true or no. Let's say that p is true. We can easily schematize the situation by just drawing a graph with a single node containing p, where the node is the entire audio.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"(Image: A single node, where p is true)","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"This single node above is what we call world, and it is exactly a propositional model. We can represent it as follows.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"p = Atom(\"p\") # \"the audio is loud\"\nworld = SoleLogics.World(1) # this is just an abstract reference to a 9s audio sample\n\n# ... calculations here ...\n\nvaluation = Dict([world => TruthDict(p => true)]) # after some calculations, we establish \"p\" is true in \"world\"","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Now here's a challenge. Try to express the following fact using just propositional logic: the audio contains at least two pauses of three seconds that are interspersed with each other by three or more seconds of loud speaking. After a few tries you should be convinced that this is not possible, because through propositional logic we are not able to quantify over relations inside the sample. What we can do instead, is upgrade propositional logic to modal logic. We have to deal in a more granular manner with the original audio sample, and we don't want to denature it. Here is what we need:","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"an Atom p, representing the fact the audio is loud;\nan Atom q, representing the fact the audio is silence;\nWorlds describing small pieces of the original audio. In particular, we establish that each world is representative for 3 seconds of audio;\nan accessibility relation (a specific AbstractRelation) to express which worlds are reachable from another through a modal NamedConnective. ","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"The situation is simply schematized as follows","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"(Image: A Kripke Model, representing a time serie)","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"where each world identifies 3 seconds of audio, and we consider a relation between two worlds only if they represent adjacent parts of the audio. At this point, let's create the Kripke structure in the example using SoleLogics.jl.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"p = Atom(\"p\") # \"the audio is loud\"\nq = Atom(\"q\") # \"the audio is silence\"\n\n# Worlds representing 3-second-pieces of the original audio\nworlds = [SoleLogics.World(1), SoleLogics.World(2), SoleLogics.World(3)]\nedges = Edge.([(1,2), (1,3), (2,3)])\nkripkeframe = SoleLogics.ExplicitCrispUniModalFrame(worlds, Graphs.SimpleDiGraph(edges))\n\nvaluation = Dict([worlds[1] => TruthDict([p => false, q => true]), worlds[2] => TruthDict([p => true, q => false]), worlds[3] => TruthDict([p => false, q => true])])\n\nkripkestructure = KripkeStructure(kripkeframe, valuation)","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"In the Kripke structure above, the central world w_2 (the only one where p is true) is accessible from the leftmost world w_1 (where q is true). In modal logic terms, this is expressed by the notation","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Kw_1 models lozenge p","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"where K is a Kripke structure, w_1 is the leftmost world in the image, and lozenge p means look at the world accessibles from w_1 and check whether p is true or false on those neighbors.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"Now we are ready to resume the long statement of a few paragraphs ago, the one we could not express using only propositional logic. We can translate it using modal logic! The formula we are looking for is ","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"q wedge lozenge p wedge lozenge lozenge q","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"which has to be read check whether this sub-sample of audio is silence, and the sub-sample after this is loud, and the sub-sample after the latter is silence again. Let's see if this formula is true on the Kripke model above, starting from w_1.","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"# ... continuing code above ...\n\nphi = ∧(q, ∧(◊(p),◊(◊(q)))) # \\wedge+TAB can also be written as CONJUNCTION, while \\lozenge+TAB is called DIAMOND and is a modal operator\n\ncheck(phi, kripkestructure, worlds[1]) # prints true","category":"page"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"By reading the following sections, you will better grasp how Worlds are defined, as well as relations (AbstractRelation), how those two concepts are bound togheter in AbstractFrames and KripkeStructures. You will also understand how to access one world from another by using (or implementing) Connectives such as ◊ (or DIAMOND) and the accessibles method.","category":"page"},{"location":"modal-logic/#modal-logic-worlds-and-frames","page":"Modal Logic","title":"Worlds and Frames","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractWorld\nWorld{T}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractWorld","page":"Modal Logic","title":"SoleLogics.AbstractWorld","text":"abstract type AbstractWorld end\n\nAbstract type for the nodes of an annotated accessibility graph (Kripke structure). This is used, for example, in modal logic, where the truth of formulas is relativized to worlds, that is, nodes of a graph.\n\nImplementing\n\nWhen implementing a new world type, the logical semantics should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.World","page":"Modal Logic","title":"SoleLogics.World","text":"struct World{T} <: AbstractWorld\n    name::T\nend\n\nA world that is solely identified by its name. This can be useful when instantiating the underlying graph of a modal frame in an explicit way.\n\nSee also OneWorld, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractFrame{W<:AbstractWorld}\nworldtype(::Type{<:AbstractFrame{W}}) where {W<:AbstractWorld}\nallworlds(fr::AbstractFrame{W}) where {W<:AbstractWorld}\nnworlds(fr::AbstractFrame)\n\nAbstractUniModalFrame{W<:AbstractWorld}\naccessibles(fr::AbstractUniModalFrame{W}, w::W) where {W<:AbstractWorld}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractFrame","page":"Modal Logic","title":"SoleLogics.AbstractFrame","text":"abstract type AbstractFrame{W<:AbstractWorld} end\n\nAbstract type for an accessibility graph (Kripke frame), that gives the topology to Kripke structures. A frame can be queried for its set of vertices (also called worlds, see allworlds), and it can be browsed via its accessibility relation(s) (see accessibles). Refer to FullDimensionalFrame as an example.\n\nSee also truthtype, , allworlds, nworlds, AbstractKripkeStructure, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.worldtype-Union{Tuple{Type{<:SoleLogics.AbstractFrame{W}}}, Tuple{W}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.worldtype","text":"worldtype(fr::AbstractFrame)\nworldtype(i::AbstractKripkeStructure)\n\nReturn the world type of the Kripke frame/structure.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.allworlds-Union{Tuple{SoleLogics.AbstractFrame{W}}, Tuple{W}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.allworlds","text":"allworlds(fr::AbstractFrame{W})::AbstractVector{<:W} where {W<:AbstractWorld}\n\nReturn all worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.nworlds-Tuple{SoleLogics.AbstractFrame}","page":"Modal Logic","title":"SoleLogics.nworlds","text":"nworlds(fr::AbstractFrame)::Integer\n\nReturn the number of worlds within the frame.\n\nSee also nworlds, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.AbstractUniModalFrame","page":"Modal Logic","title":"SoleLogics.AbstractUniModalFrame","text":"abstract type AbstractUniModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a modal logic based on a single (implicit) accessibility relation.\n\nSee also AbstractMultiModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractUniModalFrame{W}, W}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.accessibles","text":"accessibles(fr::AbstractUniModalFrame{W}, w::W)::Worlds{W} where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w.\n\nSee also AbstractWorld, AbstractUniModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#modal-logic-relations","page":"Modal Logic","title":"Relations","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractRelation\narity(r::AbstractRelation)\nconverse(r::AbstractRelation)\nistoone(r::AbstractRelation)\nissymmetric(r::AbstractRelation)\nisreflexive(::AbstractRelation)\nistransitive(::AbstractRelation)\nisgrounding(::AbstractRelation)","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractRelation","page":"Modal Logic","title":"SoleLogics.AbstractRelation","text":"abstract type AbstractRelation end\n\nAbstract type for the relations of a multi-modal annotated accessibility graph (Kripke structure). Two noteworthy relations are identityrel and globalrel, which access the current world and all worlds, respectively.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> Interval(8,11) in (accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nWhen implementing a new relation type R, please provide the methods:\n\narity(::R)::Int = ...\nsyntaxstring(::R; kwargs...)::String = ...\n\nIf the relation is symmetric, please specify its converse relation cr with:\n\nhasconverse(::R) = true\nconverse(::R) = cr\n\nIf the relation is many-to-one or one-to-one, please flag it with:\n\nistoone(::R) = true\n\nIf the relation is reflexive or transitive, flag it with:\n\nisreflexive(::R) = true\nistransitive(::R) = true\n\nMost importantly, the logical semantics for R should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also issymmetric, isreflexive, istransitive, isgrounding, arity, syntaxstring, converse, hasconverse, istoone, identityrel, globalrel, accessibles, AbstractKripkeStructure, AbstractFrame, AbstractWorld.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.arity-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.arity","text":"arity(::AbstractRelation)::Integer\n\nReturn the arity of the relation.\n\nSee also AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.converse-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.converse","text":"hasconverse(r::AbstractRelation)::Bool\nconverse(r::AbstractRelation)::AbstractRelation\n\nIf the relation hasconverse, return the converse relation (type) of a given relation (type).\n\nSee also issymmetric, isreflexive, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.istoone-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.istoone","text":"istoone(r::AbstractRelation) = false\n\nReturn whether it is known that a relation is istoone.\n\nSee also hasconverse, converse, issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.issymmetric-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.issymmetric","text":"issymmetric(r::AbstractRelation) = hasconverse(r) ? converse(r) == r : false\n\nReturn whether it is known that a relation is symmetric.\n\nSee also hasconverse, converse, isreflexive, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.isreflexive-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.isreflexive","text":"isreflexive(::AbstractRelation)\n\nReturn whether it is known that a relation is reflexive.\n\nSee also issymmetric, istransitive, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.istransitive-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.istransitive","text":"istransitive(::AbstractRelation)\n\nReturn whether it is known that a relation is transitive.\n\nSee also istoone, issymmetric, isgrounding, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.isgrounding-Tuple{AbstractRelation}","page":"Modal Logic","title":"SoleLogics.isgrounding","text":"isgrounding(::AbstractRelation)\n\nReturn whether it is known that a relation is grounding. A relation R is grounding if ∀x,z,y R(x,y) ⇔ R(z,y).\n\nSee also isreflexive, issymmetric, istransitive, AbstractRelation.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#modal-logic-kripke-structures","page":"Modal Logic","title":"More on Frames and Kripke Structures","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractMultiModalFrame{W<:AbstractWorld}\naccessibles(fr::AbstractMultiModalFrame{W}, w::W, r::AbstractRelation) where {W<:AbstractWorld}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractMultiModalFrame","page":"Modal Logic","title":"SoleLogics.AbstractMultiModalFrame","text":"abstract type AbstractMultiModalFrame{W<:AbstractWorld} <: AbstractFrame{W} end\n\nA frame of a multi-modal logic, that is, a modal logic based on a set of accessibility relations.\n\nImplementation\n\nWhen implementing a new multi-modal frame type, the logical semantics for the frame should be defined via accessibles methods; refer to the help for accessibles.\n\nSee also AbstractUniModalFrame, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.accessibles-Union{Tuple{W}, Tuple{SoleLogics.AbstractMultiModalFrame{W}, W, AbstractRelation}} where W<:AbstractWorld","page":"Modal Logic","title":"SoleLogics.accessibles","text":"accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation\n) where {W<:AbstractWorld}\n\nReturn the worlds in frame fr that are accessible from world w via relation r.\n\nExamples\n\njulia> fr = SoleLogics.FullDimensionalFrame((10,),);\n\njulia> typeof(accessibles(fr, Interval(2,5), IA_L))\nBase.Generator{...}\n\njulia> typeof(accessibles(fr, globalrel))\nBase.Generator{...}\n\njulia> @assert SoleLogics.nworlds(fr) == length(collect(accessibles(fr, globalrel)))\n\njulia> typeof(accessibles(fr, Interval(2,5), identityrel))\nVector{Interval{Int64}}\n\njulia> Interval(8,11) in collect(accessibles(fr, Interval(2,5), IA_L))\ntrue\n\nImplementation\n\nSince accessibles always returns an iterator of worlds of the same type W, the current implementation of accessibles for multi-modal frames delegates the enumeration to a lower level _accessibles function, which returns an iterator of parameter tuples that are, then, fed to the world constructor the using IterTools generators, as in:\n\nfunction accessibles(\n    fr::AbstractMultiModalFrame{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    IterTools.imap(W, _accessibles(fr, w, r))\nend\n\nAs such, when defining new frames, worlds, and/or relations, one should provide new methods for _accessibles. For example:\n\n_accessibles(fr::Full1DFrame, w::Interval{<:Integer}, ::_IA_A) = zip(Iterators.repeated(w.y), w.y+1:X(fr)+1)\n\nThis pattern is generally convenient; it can, however, be bypassed, although this requires defining two additional methods in order to resolve dispatch ambiguities. When defining a new frame type FR{W}, one can resolve the ambiguities and define a custom accessibles method by providing these three methods:\n\n# access worlds through relation `r`\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::AbstractRelation,\n) where {W<:AbstractWorld}\n    ...\nend\n\n# access current world\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::IdentityRel,\n) where {W<:AbstractWorld}\n    [w]\nend\n\n# access all worlds\nfunction accessibles(\n    fr::FR{W},\n    w::W,\n    r::GlobalRel,\n) where {W<:AbstractWorld}\n    allworlds(fr)\nend\n\nIn general, it should be true that collect(accessibles(fr, w, r)) isa AbstractWorlds{W}.\n\nSee also AbstractWorld, AbstractRelation, AbstractMultiModalFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractKripkeStructure\n\ncheck(φ::SyntaxTree, i::AbstractKripkeStructure, w; use_memo::Union{Nothing,AbstractDict{<:Formula,<:Vector{<:AbstractWorld}}} = nothing, perform_normalization::Bool = true, memo_max_height::Union{Nothing,Int} = nothing)\n\nKripkeStructure{FR<:AbstractFrame, MAS<:AbstractDict}","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractKripkeStructure","page":"Modal Logic","title":"SoleLogics.AbstractKripkeStructure","text":"abstract type AbstractKripkeStructure <: AbstractInterpretation end\n\nAbstract type for representing Kripke structures's. It comprehends a directed graph structure (Kripke frame), where nodes are referred to as worlds, and the binary relation between them is referred to as the accessibility relation. Additionally, each world is associated with a mapping from Atoms to Truth values.\n\nSee also frame, worldtype, accessibles, AbstractInterpretation.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.check-Tuple{SyntaxTree, SoleLogics.AbstractKripkeStructure, Any}","page":"Modal Logic","title":"SoleLogics.check","text":"check(\n    φ::Formula,\n    i::AbstractInterpretation,\n    args...;\n    kwargs...\n)::Bool\n\nCheck a formula on a logical interpretation (or model), returning true if the truth value for the formula istop. This process is referred to as (finite) model checking, and there are many algorithms for it, typically depending on the complexity of the logic.\n\nExamples\n\njulia> @atoms String p q\n2-element Vector{Atom{String}}:\n Atom{String}(\"p\")\n Atom{String}(\"q\")\n\njulia> td = TruthDict([p => TOP, q => BOT])\nTruthDict with values:\n┌────────┬────────┐\n│      q │      p │\n│ String │ String │\n├────────┼────────┤\n│      ⊥ │      ⊤ │\n└────────┴────────┘\n\njulia> check(CONJUNCTION(p,q), td)\nfalse\n\nSee also interpret, Formula, AbstractInterpretation, TruthDict.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.KripkeStructure","page":"Modal Logic","title":"SoleLogics.KripkeStructure","text":"struct KripkeStructure{\n    FR<:AbstractFrame,\n    MAS<:AbstractDict\n} <: AbstractKripkeStructure\n    frame::FR\n    assignment::AS\nend\n\nType for representing Kripke structures. explicitly; it wraps a frame, and an abstract dictionary that assigns an interpretation to each world.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#modal-logic-connectives","page":"Modal Logic","title":"Modal Connectives","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"ismodal(::Type{<:Connective})\nisbox(::Type{<:Connective})","category":"page"},{"location":"modal-logic/#SoleLogics.ismodal-Tuple{Type{<:Connective}}","page":"Modal Logic","title":"SoleLogics.ismodal","text":"ismodal(::Type{<:Connective})::Bool = false\nismodal(c::Connective)::Bool = ismodal(typeof(c))\n\nReturn whether it is known that an Connective is modal.\n\nExamples\n\njulia> ismodal(◊)\ntrue\n\njulia> ismodal(∧)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.isbox-Tuple{Type{<:Connective}}","page":"Modal Logic","title":"SoleLogics.isbox","text":"isbox(::Type{<:Connective})::Bool = false\nisbox(c::Connective)::Bool = isbox(typeof(c))\n\nReturn whether it is known that an Connective is a box (i.e., universal) connective.\n\nExamples\n\njulia> SoleLogics.isbox(◊)\nfalse\n\njulia> SoleLogics.isbox(∧)\nfalse\n\njulia> SoleLogics.isbox(□)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"DIAMOND\nBOX","category":"page"},{"location":"modal-logic/#SoleLogics.DIAMOND","page":"Modal Logic","title":"SoleLogics.DIAMOND","text":"const DIAMOND = NamedConnective{:◊}()\nconst ◊ = DIAMOND\nismodal(::typeof(◊)) = true\narity(::typeof(◊)) = 1\n\nLogical diamond connective, typically interpreted as the modal existential quantifier. See here.\n\nSee also BOX, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"modal-logic/#SoleLogics.BOX","page":"Modal Logic","title":"SoleLogics.BOX","text":"const BOX = NamedConnective{:□}()\nconst □ = BOX\narity(::typeof(□)) = 1\n\nLogical box connective, typically interpreted as the modal universal quantifier. See here.\n\nSee also DIAMOND, NamedConnective, Connective.\n\n\n\n\n\n","category":"constant"},{"location":"modal-logic/#modal-logic-relational-connectives","page":"Modal Logic","title":"Relational Connectives","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"AbstractRelationalConnective{R<:AbstractRelation}\nrelationtype(::AbstractRelationalConnective{R}) where {R<:AbstractRelation}\nDiamondRelationalConnective{R<:AbstractRelation}\n\ndiamond()\nbox()","category":"page"},{"location":"modal-logic/#SoleLogics.AbstractRelationalConnective","page":"Modal Logic","title":"SoleLogics.AbstractRelationalConnective","text":"abstract type AbstractRelationalConnective{R<:AbstractRelation} <: Connective end\n\nAbstract type for relational logical connectives. A relational connective allows for semantic quantification across relational structures (e.g., Kripke structures). It has arity equal to the arity of its underlying relation minus one.\n\nSee, for example temporal modal logic.\n\nSee also DiamondRelationalConnective, BoxRelationalConnective, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.relationtype-Union{Tuple{SoleLogics.AbstractRelationalConnective{R}}, Tuple{R}} where R<:AbstractRelation","page":"Modal Logic","title":"SoleLogics.relationtype","text":"relationtype(::AbstractRelationalConnective{R}) where {R<:AbstractRelation} = R\nrelation(op::AbstractRelationalConnective) = relationtype(op)()\n\nReturn the underlying relation (and relation type) of the relational connective.\n\nSee also AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.DiamondRelationalConnective","page":"Modal Logic","title":"SoleLogics.DiamondRelationalConnective","text":"struct DiamondRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\nstruct BoxRelationalConnective{R<:AbstractRelation} <: AbstractRelationalConnective{R} end\n\nSingleton types for relational connectives, typically interpreted as the modal existential and universal quantifier, respectively.\n\nBoth connectives can be easily instantiated with relation instances, such as DiamondRelationalConnective(rel), which is a shortcut for DiamondRelationalConnective{typeof(rel)}().\n\nExamples\n\njulia> syntaxstring(DiamondRelationalConnective(IA_A))\n\"⟨A⟩\"\n\njulia> syntaxstring(BoxRelationalConnective(IA_A))\n\"[A]\"\n\njulia> @assert DiamondRelationalConnective(IA_A) == SoleLogics.dual(BoxRelationalConnective(IA_A))\n\n\nSee also DiamondRelationalConnective, BoxRelationalConnective, syntaxstring, dual, AbstractKripkeStructure, AbstractFrame.\n\n\n\n\n\n","category":"type"},{"location":"modal-logic/#SoleLogics.diamond-Tuple{}","page":"Modal Logic","title":"SoleLogics.diamond","text":"diamond() = DIAMOND\ndiamond(r::AbstractRelation) = DiamondRelationalConnective(r)\n\nReturn either the diamond modal connective from unimodal logic (i.e., ◊), or a a diamond relational connective from a multi-modal logic, wrapping the relation r.\n\nSee also DiamondRelationalConnective, diamond, DIAMOND.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.box-Tuple{}","page":"Modal Logic","title":"SoleLogics.box","text":"box() = BOX\nbox(r::AbstractRelation) = BoxRelationalConnective(r)\n\nReturn either the box modal connective from unimodal logic (i.e., □), or a a box relational connective from a multi-modal logic, wrapping the relation r.\n\nSee also BoxRelationalConnective, box, BOX.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#modal-logic-final-steps","page":"Modal Logic","title":"Final steps","text":"","category":"section"},{"location":"modal-logic/","page":"Modal Logic","title":"Modal Logic","text":"modallogic(; alphabet::Union{Nothing,Vector,AbstractAlphabet} = nothing, operators::Union{Nothing,Vector{<:Connective}} = nothing, grammar::Union{Nothing,AbstractGrammar} = nothing, algebra::Union{Nothing,AbstractAlgebra} = nothing, default_operators = BASE_MODAL_CONNECTIVES)\n\ncollateworlds(fr::AbstractFrame{W}, op::Operator, t::NTuple{N,<:AbstractWorlds}) where {N,W<:AbstractWorld}","category":"page"},{"location":"modal-logic/#SoleLogics.modallogic-Tuple{}","page":"Modal Logic","title":"SoleLogics.modallogic","text":"modallogic(;\n    alphabet = AlphabetOfAny{String}(),\n    operators = [⊤, ⊥, ¬, ∧, ∨, →, ◊, □],\n    grammar = CompleteFlatGrammar(AlphabetOfAny{String}(), [⊤, ⊥, ¬, ∧, ∨, →, ◊, □]),\n    algebra = BooleanAlgebra(),\n)\n\nInstantiate a modal logic given a grammar and an algebra. Alternatively, an alphabet and a set of operators can be specified instead of the grammar.\n\nExamples\n\njulia> (¬) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic());\ntrue\n\njulia> (□) isa operatorstype(modallogic(; operators = [¬, ∨]))\n┌ Warning: Instantiating modal logic (via `modallogic`) with solely propositional operators (SoleLogics.NamedConnective[¬, ∨]). Consider using propositionallogic instead.\n└ @ SoleLogics ~/.julia/dev/SoleLogics/src/modal-logic.jl:642\nfalse\n\njulia> modallogic(; alphabet = [\"p\", \"q\"]);\n\njulia> modallogic(; alphabet = ExplicitAlphabet([Atom(\"p\"), Atom(\"q\")]));\n\n\nSee also propositionallogic, AbstractAlphabet, AbstractAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"modal-logic/#SoleLogics.collateworlds-Union{Tuple{W}, Tuple{N}, Tuple{SoleLogics.AbstractFrame{W}, Operator, Tuple{Vararg{var\"#s1\", N}} where var\"#s1\"<:(AbstractVector{W} where W<:AbstractWorld)}} where {N, W<:AbstractWorld}","page":"Modal Logic","title":"SoleLogics.collateworlds","text":"collateworlds(\n    fr::AbstractFrame{W},\n    op::Operator,\n    t::NTuple{N,WS},\n)::AbstractVector{<:W} where {N,W<:AbstractWorld,WS<:AbstractWorlds}\n\nFor a given crisp frame (truthtype == Bool), return the set of worlds where a composed formula op(φ1, ..., φN) is true, given the N sets of worlds where the each immediate sub-formula is true.\n\nSee also check, iscrisp, Operator, AbstractFrame.\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"CurrentModule = SoleLogics","category":"page"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"Pages = [\"more-on-formulas.md\"]","category":"page"},{"location":"more-on-formulas/#more-on-formulas-section","page":"More on Formulas","title":"More on Formulas","text":"","category":"section"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"In this chapter, you are going to learn more on Formula representations that are alternative to syntax trees. As you will see, for example, formulas with specific structure (e.g., normal forms) can be represented in ways that make them more easy to handle, and can lead to great benefits in terms of both computational and memory load.","category":"page"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"We proceed by presenting the random formulae generation engine, parsing and some utility function.","category":"page"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"Recalling the type hierarchy presented in man-core, it is here enriched with the following new types and structures.","category":"page"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"Formula\nAnchoredFormula\nAbstractSyntaxStructure\nLiteral\nLeftmostLinearForm","category":"page"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"","category":"page"},{"location":"more-on-formulas/#Literals","page":"More on Formulas","title":"Literals","text":"","category":"section"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"Literal","category":"page"},{"location":"more-on-formulas/#SoleLogics.Literal","page":"More on Formulas","title":"SoleLogics.Literal","text":"struct Literal{T<:SyntaxLeaf} <: AbstractSyntaxStructure\n    ispos::Bool\n    prop::T\nend\n\nAn atom, or its negation.\n\nSee also CNF, DNF, AbstractSyntaxStructure.\n\n\n\n\n\n","category":"type"},{"location":"more-on-formulas/#Linear-Forms","page":"More on Formulas","title":"Linear Forms","text":"","category":"section"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure}\n\nLeftmostConjunctiveForm{SS<:AbstractSyntaxStructure}\nLeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure}\n\nCNF{SS<:AbstractSyntaxStructure}\nDNF{SS<:AbstractSyntaxStructure}","category":"page"},{"location":"more-on-formulas/#SoleLogics.LeftmostLinearForm","page":"More on Formulas","title":"SoleLogics.LeftmostLinearForm","text":"struct LeftmostLinearForm{C<:Connective,SS<:AbstractSyntaxStructure} <: AbstractSyntaxStructure\n    children::Vector{<:SS}\nend\n\nA syntax structure representing the foldl of a set of other syntax structure of type SS by means of a connective C. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:\n\nconst LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\nconst LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nconst CNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}\nconst DNF{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}\n\nExamples\n\njulia> LeftmostLinearForm(→, parseformula.([\"p\", \"q\", \"r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}}\n    \"(p) → (q) → (r)\"\n\njulia> LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))\nLeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}\n    \"(¬p) ∧ (q) ∧ (¬r)\"\n\njulia> LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(\"p\")), Literal(true, Atom(\"q\")), Literal(false, Atom(\"r\"))])\nLeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}\n    \"(¬p) ∨ (q) ∨ (¬r)\"\n\njulia> LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([\"¬p\", \"q\", \"¬r\"]))]) isa DNF\ntrue\n\njulia> conj = LeftmostConjunctiveForm(@atoms p q)\nLeftmostConjunctiveForm with 2 Atom{String} children:\n        p\n        q\n\njulia> tree(conj)\nSyntaxBranch: p ∧ q\n\njulia> nconj = NEGATION(conj)\nLeftmostLinearForm with connective ¬ and 1 LeftmostConjunctiveForm{Atom{String}} children:\n        (p) ∧ (q)\n\njulia> tree(nconj)\nSyntaxBranch: ¬(p ∧ q)\n\njulia> tree(nconj ∧ nconj)\nSyntaxBranch: ¬(p ∧ q) ∧ ¬(p ∧ q)\n\nSee also AbstractSyntaxStructure, SyntaxTree, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, Literal.\n\n\n\n\n\n","category":"type"},{"location":"more-on-formulas/#SoleLogics.LeftmostConjunctiveForm","page":"More on Formulas","title":"SoleLogics.LeftmostConjunctiveForm","text":"LeftmostConjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}\n\nSpecific instantiation of a LeftmostLinearForm, where Connectives are all CONJUNCTIONs.\n\nSee also AbstractSyntaxStructure, Connective, LeftmostLinearForm, CONJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"more-on-formulas/#SoleLogics.LeftmostDisjunctiveForm","page":"More on Formulas","title":"SoleLogics.LeftmostDisjunctiveForm","text":"LeftmostDisjunctiveForm{SS<:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}\n\nSpecific instantiation of a LeftmostLinearForm, where Connectives are all DISJUNCTIONs.\n\nSee also AbstractSyntaxStructure, Connective, LeftmostLinearForm, DISJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"more-on-formulas/#SoleLogics.CNF","page":"More on Formulas","title":"SoleLogics.CNF","text":"CNF{SS<:AbstractSyntaxStructure} = LeftmostConjunctiveForm{LeftmostDisjunctiveForm{SS}}\n\nConjunctive Normal Form of an AbstractSyntaxStructure.\n\nSee also AbstractSyntaxStructure, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, CONJUNCTION, DISJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"more-on-formulas/#SoleLogics.DNF","page":"More on Formulas","title":"SoleLogics.DNF","text":"DNF{SS<:AbstractSyntaxStructure} = LeftmostConjunctiveForm{LeftmostConjunctiveForm{SS}}\n\nDisjunctive Normal Form of an AbstractSyntaxStructure.\n\nSee also AbstractSyntaxStructure, LeftmostConjunctiveForm, LeftmostDisjunctiveForm, CONJUNCTION, DISJUNCTION.\n\n\n\n\n\n","category":"type"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"AnchoredFormula\nlogic(φ::AnchoredFormula)\nsynstruct(φ::AnchoredFormula)\n\nbaseformula(φ::Formula; infer_logic = true, additional_operators::Union{Nothing,Vector{<:Operator}} = nothing, kwargs...)\n\nparsebaseformula(expr::String, additional_operators::Union{Nothing,Vector{<:Operator}} = nothing; operators::Union{Nothing,Vector{<:Operator}}, grammar::Union{Nothing,AbstractGrammar} = nothing, algebra::Union{Nothing,AbstractAlgebra} = nothing, kwargs...)","category":"page"},{"location":"more-on-formulas/#SoleLogics.AnchoredFormula","page":"More on Formulas","title":"SoleLogics.AnchoredFormula","text":"struct AnchoredFormula{L<:AbstractLogic} <: Formula\n    _logic::Base.RefValue{L}\n    synstruct::AbstractSyntaxStructure\nend\n\nA formula anchored to a logic of type L, and wrapping a syntax structure. The structure encodes a formula belonging to the grammar of the logic, and the truth of the formula can be evaluated on interpretations of the same logic. Note that, here, the logic is represented by a reference.\n\nUpon construction, the logic can be passed either directly, or via a RefValue. Additionally, the following keyword arguments may be specified:\n\ncheck_atoms::Bool = false: whether to perform or not a check that the atoms   belong to the alphabet of the logic;\ncheck_tree::Bool = false: whether to perform or not a check that the formula's   syntactic structure honors the grammar   (includes the check performed with check_atoms = true);\n\nCool feature: a AnchoredFormula can be used for instating other formulas of the same logic. See the examples.\n\nExamples\n\njulia> φ = parsebaseformula(\"◊(p→q)\");\n\njulia> f2 = φ(parseformula(\"p\"));\n\njulia> syntaxstring(φ)\n\"◊(→(p, q))\"\n\njulia> syntaxstring(f2)\n\"p\"\n\njulia> @assert logic(φ) == logic(f2)\n\njulia> @assert ◊ in operators(logic(f2))\n\njulia> @assert ◊ isa operatorstype(logic(f2))\n\n\nSee also AbstractLogic, logic, SyntaxToken, SyntaxBranch, tree.\n\n\n\n\n\n","category":"type"},{"location":"more-on-formulas/#SoleLogics.logic-Tuple{AnchoredFormula}","page":"More on Formulas","title":"SoleLogics.logic","text":"logic(φ::AnchoredFormula)::AbstractLogic\n\nReturn the logic of an anchored formula\n\nSee AnchoredFormula.\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/#SoleLogics.synstruct-Tuple{AnchoredFormula}","page":"More on Formulas","title":"SoleLogics.synstruct","text":"synstruct(φ::AnchoredFormula)::AbstractSyntaxStructure\n\nReturn the syntactic component of an anchored formula.\n\nSee AnchoredFormula.\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/#SoleLogics.baseformula-Tuple{Formula}","page":"More on Formulas","title":"SoleLogics.baseformula","text":"function baseformula(\n    φ::Formula;\n    infer_logic = true,\n    additional_operators::Union{Nothing,Vector{<:Operator}} = nothing,\n    kwargs...\n)\n\nAttempt at instantiating a AnchoredFormula from a syntax token/formula, by inferring the logic it belongs to. If infer_logic is true, then a canonical logic (e.g., propositional logic with all the BASE_PROPOSITIONAL_CONNECTIVES) is inferred; if it's false, then a logic with exactly the operators appearing in the syntax tree, plus the additional_operators is instantiated.\n\nExamples\n\njulia> t = parseformula(\"◊((p∧q)→r)\");\n\njulia> unique(operators(logic(SoleLogics.baseformula(t))))\n3-element Vector{Union{SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:∧}}}:\n ∧\n ◊\n →\n\njulia> unique(operators(logic(SoleLogics.baseformula(t; additional_operators = SoleLogics.BASE_MODAL_CONNECTIVES))))\n8-element Vector{Union{SoleLogics.BottomOperator, SoleLogics.NamedConnective{:¬}, SoleLogics.NamedConnective{:∧}, SoleLogics.NamedConnective{:∨}, SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:□}, SoleLogics.TopOperator}}:\n ¬\n ∧\n ∨\n →\n ◊\n □\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/#SoleLogics.parsebaseformula","page":"More on Formulas","title":"SoleLogics.parsebaseformula","text":"parsebaseformula(\n    expr::String,\n    additional_operators::Union{Nothing,Vector{<:Operator}} = nothing;\n    operators::Union{Nothing,Vector{<:Operator}},\n    grammar::Union{Nothing,AbstractGrammar} = nothing,\n    algebra::Union{Nothing,AbstractAlgebra} = nothing,\n    kwargs...\n)::AnchoredFormula\n\nReturn a AnchoredFormula which is the result of parsing an expression via the Shunting yard algorithm. By default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_CONNECTIVES; additional operators may be provided as a second argument.\n\nThe grammar and algebra of the associated logic is inferred using the baseformula function from the operators encountered in the expression, and those in additional_operators.\n\nSee parseformula, baseformula, BASE_PARSABLE_CONNECTIVES.\n\n\n\n\n\n","category":"function"},{"location":"more-on-formulas/#Random-sampling-and-generation","page":"More on Formulas","title":"Random sampling and generation","text":"","category":"section"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"Base.rand(alphabet::AbstractAlphabet, args...; kwargs...)\nSoleLogics.randatom\nStatsBase.sample(alphabet::AbstractAlphabet, weights::AbstractWeights, args...; kwargs...)\n\nrandformula(height::Integer, alphabet, operators::AbstractVector; rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG)","category":"page"},{"location":"more-on-formulas/#Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}","page":"More on Formulas","title":"Base.rand","text":"Base.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    alphabet::AbstractAlphabet,\n    args...;\n    kwargs...\n)::Atom\n\nBase.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG],\n    height::Integer,\n    l::AbstractLogic,\n    args...;\n    kwargs...\n)::Formula\n\nBase.rand(\n    [rng::AbstractRNG = Random.GLOBAL_RNG,]\n    height::Integer,\n    g::CompleteFlatGrammar,\n    args...\n)::Formula\n\nBase.rand(\n    height::Integer,\n    connectives::Union{AbstractVector{<:Operator},AbstractVector{<:Connective}},\n    atoms::Union{AbstractVector{<:Atom},AbstractAlphabet},\n    truthvalues::Union{Nothing,AbstractAlgebra,AbstractVector{<:Truth}} = nothing,\n    args...;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    kwargs...\n)::Formula\n\nRandomly generate an Atom from an AbstractAlphabet according to a uniform distribution. If a CompleteFlatGrammar is provided together with an height a Formula could also be generated.\n\nImplementation\n\nIf the alphabet is finite, the function defaults to rand(rng, atoms(alphabet)); otherwise, it must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.\n\nSee also AbstractAlphabet, Atom, CompleteFlatGrammar, Formula, randformula.\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/#SoleLogics.randatom","page":"More on Formulas","title":"SoleLogics.randatom","text":"randatom(a::AbstractAlphabet)\nrandatom(rng, a::AbstractAlphabet)\n\nReturn a random atom from a finite alphabet.\n\nSee also natoms, AbstractAlphabet.\n\n\n\n\n\nrandatom(\n    rng::Union{Integer,AbstractRNG},\n    a::UnionAlphabet;\n    atompicking_mode::Symbol=:uniform,\n    subalphabets_weights::Union{AbstractWeights,AbstractVector{<:Real},Nothing} = nothing\n)::Atom\n\nSample an atom from a UnionAlphabet. By default, the sampling is uniform with respect to the atoms. However, by setting atompicking_mode = :uniform_subalphabets one can force a uniform sampling with respect to the sub-alphabets. Moreover, one can specify a :weighted atompicking_mode, together with a subalphabets_weights vector.\n\nSee also UnionAlphabet.\n\n\n\n\n\n","category":"function"},{"location":"more-on-formulas/#Parsing","page":"More on Formulas","title":"Parsing","text":"","category":"section"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"BASE_PARSABLE_CONNECTIVES\n\nparseformula(F::Type{<:SyntaxTree}, expr::String, additional_operators::Union{Nothing,AbstractVector} = nothing; function_notation::Bool = false, atom_parser::Base.Callable = Atom{String}, additional_whitespaces::Vector{Char} = Char[], opening_parenthesis::String = DEFAULT_OPENING_PARENTHESIS, closing_parenthesis::String = DEFAULT_CLOSING_PARENTHESIS, arg_delim::String = DEFAULT_ARG_DELIM)","category":"page"},{"location":"more-on-formulas/#SoleLogics.BASE_PARSABLE_CONNECTIVES","page":"More on Formulas","title":"SoleLogics.BASE_PARSABLE_CONNECTIVES","text":"const BASE_PARSABLE_CONNECTIVES = SoleLogics.Syntactical[¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤, ⊥]\n\nVector of (standard) operators that are automatically taken care of when parsing. These are ¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤ and ⊥.\n\nSee also parseformula.\n\n\n\n\n\n","category":"constant"},{"location":"more-on-formulas/#SoleLogics.parseformula","page":"More on Formulas","title":"SoleLogics.parseformula","text":"parseformula(expr::String, additional_operators = nothing; kwargs...)\n\nparseformula(\n    F::Type{<:SyntaxTree},\n    expr::String,\n    additional_operators::Union{Nothing,AbstractVector} = nothing;\n    function_notation::Bool = false,\n    atom_parser::Base.Callable = Atom{String},\n    additional_whitespaces::Vector{Char} = Char[],\n    opening_parenthesis::String = \"(\",\n    closing_parenthesis::String = \")\",\n    arg_delim::String = \",\"\n)::F\n\nparseformula(F::Type{<:Formula}, expr::String, additional_operators = nothing; kwargs...)\nparseformula(F::Type{<:SyntaxTree}, expr::String, logic::AbstractLogic; kwargs...)\n\nParse a formula of type F from a string expression (its syntaxstring). When F is not specified, it defaults to SyntaxTree.\n\nBy default, this function is only able to parse operators in SoleLogics.BASE_PARSABLE_CONNECTIVES (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector additional_operators, and their syntaxstrings will be used for parsing them. Note that, in case of clashing syntaxstrings, the provided additional operators will override the standard ones.\n\nWhen parsing SyntaxTrees, the Shunting yard algorithm is used, and the method allows the following keywords arguments.\n\nKeyword Arguments\n\nfunction_notation::Bool = false: if set to true, the expression is considered   in function notation (e.g., \"⨁(arg1, arg2)\");   otherwise, it is considered in   infix notation (e.g., \"arg1 ⨁ arg2\");\natom_parser::Base.Callable = Atom{String}: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the Atom itself;\nadditional_whitespaces::Vector{Char} = Char[]: characters to be stripped out from each   syntax token.   For example, if '@' in additional_whitespaces, \"¬@p@\" is parsed just as \"¬p\".\nopening_parenthesis::String = \"(\":   the string signaling the opening of an expression block;\nclosing_parenthesis::String = \")\":   the string signaling the closing of an expression block;\narg_delim::String = \",\":   when function_notation = true,   the string that delimits the different arguments of a function call.\n\nwarning: Warning\nFor a proper functioning, the syntaxstring of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator ⨁, it should hold that syntaxstring(⨁) == strip(syntaxstring(⨁)). Also, syntaxstrings cannot contain special symbols (opening_parenthesis, closing_parenthesis, and arg_delim) as substrings.\n\nExamples\n\njulia> syntaxstring(parseformula(\"¬p∧q∧(¬s∧¬z)\"))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"∧(¬p,∧(q,∧(¬s,¬z)))\", function_notation=true))\n\"¬p ∧ q ∧ ¬s ∧ ¬z\"\n\njulia> syntaxstring(parseformula(\"¬1→0\"; atom_parser = (x -> Atom{Float64}(parse(Float64, x)))))\n\"(¬1.0) → 0.0\"\n\nnote: Note\nFor any Formula type F, this function should be the inverse of syntaxstring; that is, if φ::F then the following should hold, for at least some args, and for every kwargs allowing correct parsing: φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...).\n\nSee also SyntaxTree, BASE_PARSABLE_CONNECTIVES, syntaxstring.\n\n\n\n\n\n","category":"function"},{"location":"more-on-formulas/#Utilities","page":"More on Formulas","title":"Utilities","text":"","category":"section"},{"location":"more-on-formulas/","page":"More on Formulas","title":"More on Formulas","text":"treewalk(st::SyntaxTree, args...; rng::AbstractRNG = Random.GLOBAL_RNG, criterion::Function = ntokens, toleaf::Bool = true, returnnode::Bool = false, transformnode::Function = nothing)\n\nsubformulas(f::Formula; sorted=true)\n\nnormalize(f::Formula; remove_boxes = true, reduce_negations = true, allow_atom_flipping = true)\n\nisgrounded(f::Formula)","category":"page"},{"location":"more-on-formulas/#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}","page":"More on Formulas","title":"SoleLogics.treewalk","text":"treewalk(\n    st::SyntaxTree,\n    args...;\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    criterion::Function = ntokens,\n    toleaf::Bool = true,\n    returnnode::Bool = false,\n    transformnode::Function = nothing\n)::SyntaxTree\n\nReturn a subtree of syntax tree, by following these options:\n\ncriterion: function used to compute the probability of stopping at a random node;\nreturnnode: true if only the subtree is to be returned;\ntransformnode: function that will be applied to the chosen subtree.\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/#SoleLogics.subformulas-Tuple{Formula}","page":"More on Formulas","title":"SoleLogics.subformulas","text":"subformulas(f::Formula; sorted=true)\n\nReturn all sub-formulas (sorted by size when sorted=true) of a given formula.\n\nExamples\n\njulia> syntaxstring.(SoleLogics.subformulas(parseformula(\"◊((p∧q)→r)\")))\n6-element Vector{String}:\n \"p\"\n \"q\"\n \"r\"\n \"p ∧ q\"\n \"◊(p ∧ q)\"\n \"(◊(p ∧ q)) → r\"\n\nSee also SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/#SoleLogics.normalize-Tuple{Formula}","page":"More on Formulas","title":"SoleLogics.normalize","text":"normalize(\n    f::Formula;\n    profile = :readability,\n    remove_boxes = nothing,\n    reduce_negations = true,\n    simplify_constants = true,\n    allow_atom_flipping = false,\n    prefer_implications = false,\n    remove_implications = false,\n    forced_negation_removal = nothing,\n    remove_identities = true,\n    unify_toones = true,\n    rotate_commutatives = true,\n)\n\nReturn a modified version of a given formula, that has the same semantics but different syntax. This is useful for simplifying formulas for readability, or when checking the truth of many (possibly semantically similar) formulas; for example, when performing model checking. The current implementation assumes the underlying algebra is Boolean!\n\nArguments\n\nf::Formula: when set to true,   the formula;\nprofile::Symbol: possible values are :readability, which optimizes for qualitative   simplicity for a human to understand, and :modelchecking, which optimizes   model checking speed;\nremove_boxes::Bool: remove all (non-relational and relational) box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.\nreduce_negations::Bool: when set to true,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., De Morgan's laws).   Note: this assumes an underlying Boolean algebra.\nallow_atom_flipping::Bool: when set to true,   together with reduce_negations=true, this may cause the negation of an atom   to be replaced with the its dual atom.\n\nExamples\n\njulia> f = parseformula(\"□¬((p∧¬q)→r)∧⊤\");\n\njulia> syntaxstring(f)\n\"□¬((p ∧ ¬q) → r) ∧ ⊤\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))\n\"¬◊(q ∨ ¬p ∨ r)\"\n\njulia> syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))\n\"□(¬r ∧ p ∧ ¬q)\"\n\nSee also SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"more-on-formulas/#SoleLogics.isgrounded-Tuple{Formula}","page":"More on Formulas","title":"SoleLogics.isgrounded","text":"isgrounded(f::Formula)::Bool\n\nReturn true if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.\n\nExamples\n\njulia> f = parseformula(\"⟨G⟩p → [G]q\");\n\njulia> syntaxstring(f)\n\"(⟨G⟩p) → ([G]q)\"\n\njulia> SoleLogics.isgrounded(f)\ntrue\n\nSee also isgrounding), SyntaxTree), Formula.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"CurrentModule = SoleLogics.ManyValuedLogics","category":"page"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"Pages = [\"many-valued-logics.md\"]","category":"page"},{"location":"many-valued-logics/#many-valued-logics-introduction","page":"Many-valued logics","title":"Introduction","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"SoleLogics also provides tools to work with many-valued logics (e.g., fuzzy logics), that is, logics with more truth values other than the classical Boolean ones ⊤ and ⊥. With many-valued logics, the truth values are elements of a bounded lattice, providing a partial order between them, which encodes a truer than relation.","category":"page"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"Most of the tools for dealing with these logics can be accessed by importing the ManyValuedLogics submodule:","category":"page"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"using SoleLogics.ManyValuedLogics","category":"page"},{"location":"many-valued-logics/#many-valued-logics-operation","page":"Many-valued logics","title":"Operation","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"Operation\nBinaryOperation","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Operation","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Operation","text":"abstract type Operation end\n\nAn operation is a function which takes zero or more operands to a well-defined output value.\n\nSee also BinaryOperation, arity.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.BinaryOperation","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.BinaryOperation","text":"struct BinaryOperation{T<:Truth, D<:AbstractVector{T}} <: Operation\n    domain::D\n    truthtable::AbstractDict{Tuple{T, T}, T}\nend\n\nA binary operation on a set S is a mapping of the elements of the Cartesian product S × S → S. The closure property of a binary operation expresses the existence of a result for the operation given any pair of operands. Binary operations are required to be defined on all elements of S × S.\n\nSee also Operation, arity.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#many-valued-logics-axiom","page":"Many-valued logics","title":"Axiom","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"Axiom\ncheckaxiom","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Axiom","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Axiom","text":"struct Axiom{Symbol} end\n\nAn axiom is a statement that is taken to be true, to serve as a premise or starting point for further reasoning and arguments. Axioms aim to capture what is special about a particular structure (or set of structures).\n\nSee also checkaxiom.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.checkaxiom","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.checkaxiom","text":"function checkaxiom(a::Axiom, args...)\n\nCheck if axiom a is satisfied.\n\nSee also Axiom.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(Commutativity),\n    o::BinaryOperation{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nA binary operation * on a set S is called commutative if x * y = y * x ∀ x, y ∈ S.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(Associativity),\n    o::BinaryOperation{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nA binary operation * on a set S is called associative if it satisfies the associative law: (x * y) * z = x * (y * z) ∀ x, y, z ∈ S.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(AbsorptionLaw),\n    o1::BinaryOperation{T,D},\n    o2::BinaryOperation{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nThe absorption law or absorption identity is an identity linking a pair of binary operations. Two binary operations, * and ⋅, are said to be connected by the absotprion law if a * (a ⋅ b) = a ⋅ (a * b) = a.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(LeftIdentity),\n    o::BinaryOperation{T,D},\n    e::T\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nLet (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a left identity if e * s = s ∀ s ∈ S.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(RightIdentity),\n    o::BinaryOperation{T,D},\n    e::T\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nLet (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a right identity if s * e = s ∀ s ∈ S.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(IdentityElement),\n    o::BinaryOperation{T,D},\n    e::T\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nAn identity element or neutral element of a binary operation is an element that leaves unchanged every element when the operation is applied. I.e., let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a two-sided identity, or simply identity, if e is both a left identity and a right identity.\n\nSee also Axiom, BinaryOperation, LeftIdentity, RightIdentity.\n\n\n\n\n\nfunction checkaxiom(a::Axiom, m::Monoid{T,D}) where {T<:Truth, D<:AbstractVector{T}}\n\nCheck if axiom a is satisfied by the operation of the monoid m.\n\nSee also Axiom, Monoid.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(RightResidual),\n    m::Monoid{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nCheck that ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S such that x ⋅ y ≤ z.\n\nSee also Axiom, Monoid.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(LeftResidual),\n    m::Monoid{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nCheck that ∀ x ∈ S there exists for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.\n\nSee also Axiom, Monoid.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(ResiduationProperty),\n    m::Monoid{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nCheck that ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S and for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.\n\nSee also Axiom, Monoid.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(Implication1),\n    o::BinaryOperation{T,D},\n    top::Truth\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nCheck if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, a → a = ⊤ holds.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(Implication2),\n    o1::BinaryOperation{T,D},\n    o2::BinaryOperation{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nCheck if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and two binary operations ∧ (o1) and → (o2), a ∧ (a → b) = a ∧ b holds.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(Implication3),\n    o1::BinaryOperation{T,D},\n    o2::BinaryOperation{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nCheck if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and two binary operations ∧ (o1) and → (o2), b ∧ (a → b) = b holds.\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\nfunction checkaxiom(\n    ::typeof(DistributiveLaw),\n    o1::BinaryOperation{T,D},\n    o2::BinaryOperation{T,D}\n) where {\n    T<:Truth,\n    D<:AbstractVector{T}\n}\n\nCheck if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ⋅ and *, ⋅ is distributive over * if ∀ a, b, c ∈ L: a ⋅ (b * c) = (a ⋅ b) * (a ⋅ c).\n\nSee also Axiom, BinaryOperation.\n\n\n\n\n\n","category":"function"},{"location":"many-valued-logics/#many-valued-logics-common-axioms","page":"Many-valued logics","title":"Common axioms","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"Commutativity\nAssociativity\nAbsorptionLaw\nLeftIdentity\nRightIdentity\nIdentityElement\nRightResidual\nLeftResidual\nResiduationProperty\nImplication1\nImplication2\nImplication3\nDistributiveLaw","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Commutativity","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Commutativity","text":"const Commutativity\n\nA binary operation * on a set S is called commutative if x * y = y * x ∀ x, y ∈ S.\n\nSee also Axiom, BinaryOperation, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Associativity","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Associativity","text":"const Associativity\n\nA binary operation * on a set S is called associative if it satisfies the associative law: (x * y) * z = x * (y * z) ∀ x, y, z ∈ S.\n\nSee also Axiom, BinaryOperation, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.AbsorptionLaw","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.AbsorptionLaw","text":"const AbsorptionLaw\n\nThe absorption law or absorption identity is an identity linking a pair of binary operations. Two binary operations, * and ⋅, are said to be connected by the absorption law if a * (a ⋅ b) = a ⋅ (a * b) = a.\n\nSee also Axiom, BinaryOperation, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.LeftIdentity","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.LeftIdentity","text":"const LeftIdentity\n\nLet (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a left identity if e * s = s ∀ s ∈ S.\n\nSee also Axiom, BinaryOperation, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.RightIdentity","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.RightIdentity","text":"const RightIdentity\n\nLet (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a right identity if s * e = s ∀ s ∈ S.\n\nSee also Axiom, BinaryOperation, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.IdentityElement","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.IdentityElement","text":"const IdentityElement\n\nAn identity element or neutral element of a binary operation is an element that leaves unchanged every element when the operation is applied. I.e., let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a two-sided identity, or simply identity, if e is both a left identity and a right identity.\n\nSee also Axiom, BinaryOperation, LeftIdentity, RightIdentity, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.RightResidual","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.RightResidual","text":"const RightResidual\n\nThe right residual between two elements z, x ∈ S is the greatest y ∈ S such that x ⋅ y ≤ z.\n\nSee also Axiom, Monoid, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.LeftResidual","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.LeftResidual","text":"const LeftResidual\n\nThe left residual between two elements z, y ∈ S is the greatest x ∈ S such that x ⋅ y ≤ z.\n\nSee also Axiom, Monoid, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.ResiduationProperty","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.ResiduationProperty","text":"const ResiduationProperty\n\nA lattice (L, ∨, ∧, ⋅, ⊥, →) is residuated if ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S and for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.\n\nSee also Axiom, Monoid, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Implication1","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Implication1","text":"const Implication1\n\nAxiom Implication1 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, a → a = ⊤ holds.\n\nSee also Axiom, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Implication2","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Implication2","text":"const Implication2\n\nAxiom Implication2 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ∧ (o1) and → (o2), a ∧ (a → b) = a ∧ b holds.\n\nSee also Axiom, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Implication3","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Implication3","text":"const Implication3\n\nAxiom Implication3 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ∧ (o1) and → (o2), b ∧ (a → b) = b holds.\n\nSee also Axiom, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.DistributiveLaw","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.DistributiveLaw","text":"const DistributiveLaw\n\nGiven a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ⋅ and *, ⋅ is distributive over * if ∀ a, b, c ∈ L: a ⋅ (b * c) = (a ⋅ b) * (a ⋅ c).\n\nSee also Axiom, checkaxiom.\n\n\n\n\n\n","category":"constant"},{"location":"many-valued-logics/#many-valued-logics-finite-algebra","page":"Many-valued logics","title":"Finite algebra","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"FiniteAlgebra","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.FiniteAlgebra","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.FiniteAlgebra","text":"abstract type FiniteAlgebra{T<:Truth, D<:AbstractVector{T}} <: AbstractAlgebra{T} end\n\nA finite algebra is an algebraic structure defined over a finite set.\n\nSee also AbstractAlgebra.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#many-valued-logics-monoid","page":"Many-valued logics","title":"Monoid","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"Monoid\nCommutativeMonoid","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.Monoid","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.Monoid","text":"struct Monoid{T<:Truth, D<:AbstractVector{T}}\n    operation::BinaryOperation{T,D}\n    identityelement::T\nend\n\nA monoid (S, ⋅, e) is a set S equipped with a binary operation S × S → S, denoted as ⋅, satisfying the following axiomatic identities:\n\n(Associativity) ∀ a, b, c ∈ S, the equation (a ⋅ b) ⋅ c = a ⋅ (b ⋅ c) holds.\n(Identity element) There exists an element e ∈ L such that for every element a ∈ S, the equalities e ⋅ a = a and a ⋅ e = a hold. \n\nThe identity element of a monoid is unique.\n\nSee also BinaryOperation, Axiom, checkaxiom, checkmonoidaxioms, Associativity, IdentityElement.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.CommutativeMonoid","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.CommutativeMonoid","text":"struct CommutativeMonoid{T<:Truth, D<:AbstractVector{T}}\n    operation::BinaryOperation{T,D}\n    identityelement::T\nend\n\nA commutative monoid (S, ⋅, e) is a monoid whose operation is commutative.\n\nSee also Monoid, Commutativity.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#many-valued-logics-finite-lattice","page":"Many-valued logics","title":"Finite lattice","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"FiniteLattice\nFiniteBoundedLattice\nFiniteResiduatedLattice","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.FiniteLattice","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.FiniteLattice","text":"struct FiniteLattice{T<:Truth, D<:AbstractVector{T}} <: FiniteAlgebra{T,D}\n    join::BinaryOperation{T,D}\n    meet::BinaryOperation{T,D}\nend\n\nA finite lattice is a lattice defined over a finite set.\n\nA lattice is an algebraic structure (L, ∨, ∧) consisting of a set L and two binary, commutative and associative operations ∨ and ∧ on L satisfying the following axiomatic identities for all elements a, b ∈ L (sometimes called absorption laws):\n\na ∨ (a ∧ b) = a\na ∧ (a ∨ b) = a\n\nSee also FiniteAlgebra, BinaryOperation.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.FiniteBoundedLattice","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.FiniteBoundedLattice","text":"struct FiniteBoundedLattice{T<:Truth, D<:AbstractVector{T}} <: FiniteAlgebra{T,D}\n    join::BinaryOperation{T,D}\n    meet::BinaryOperation{T,D}\n    bot::T\n    top::T\nend\n\nA finite bounded lattice is a bounded lattice defined over a finite set.\n\nA bounded lattice is an algebraic structure (L, ∨, ∧, ⊥, ⊤) such that (L, ∨, ∧) is a lattice, the bottom element ⊥ is the identity element for the join operation ∨, and the top element ⊤ is the identity element for the meet operation ∧:\n\na ∨ ⊥ = a\na ∧ ⊤ = a\n\nSee also FiniteLattice.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.FiniteResiduatedLattice","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.FiniteResiduatedLattice","text":"struct FiniteResiduatedLattice{T<:Truth, D<:AbstractVector{T}} <: FiniteAlgebra{T,D}\n    domain::D\n    join::BinaryOperation{T,D}\n    meet::BinaryOperation{T,D}\n    monoid::Monoid{T,D}\n    rightresidual::BinaryOperation{T,D}\n    leftresidual::BinaryOperation{T,D}\n    bot::T\n    top::T\nend\n\nA residuated lattice is an algebraic structure L = (L, ∨, ∧, ⋅, e) such that:\n\n(L, ∨, ∧) is a lattice\n(L, ⋅, e) is a monoid\n∀ x ∈ L there exists for every x ∈ L a greatest y ∈ L and for every y ∈ L a greatest x ∈ L such that x ⋅ y ≤ z\n\nSee also FiniteBoundedLattice, \n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#many-valued-logics-finite-algebra-varieties","page":"Many-valued logics","title":"Finite algebra varieties","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"FiniteFLewAlgebra\nFiniteHeytingAlgebra","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.FiniteFLewAlgebra","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.FiniteFLewAlgebra","text":"struct FiniteFLewAlgebra{T<:Truth, D<:AbstractVector{T}} <: FiniteAlgebra{T,D}\n    domain::D\n    join::BinaryOperation{T,D}\n    meet::BinaryOperation{T,D}\n    monoid::Monoid{T,D}\n    implication::BinaryOperation{T,D}\n    bot::T\n    top::T\nend\n\nAn FLew-algebra is an algebra (L, ∨, ∧, ⋅, →, ⊥, ⊤), where\n\n(L, ∨, ∧, ⊥, ⊤) is a bounded lattice with top element ⊤ and bottom element ⊥\n(L, ⋅, ⊤) is a commutative monoid\nThe residuation property holds: x ⋅ y ≤ z iff x ≤ y → z\n\nSee also FiniteBoundedLattice, CommutativeMonoid.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra","text":"struct FiniteHeytingAlgebra{T<:Truth, D<:AbstractVector{T}} <: FiniteAlgebra{T,D}\n    domain::D\n    join::BinaryOperation{T,D}\n    meet::BinaryOperation{T,D}\n    implication::BinaryOperation{T,D}\n    bot::T\n    top::T\nend\n\nA Heyting algebra (H, ∨, ∧, →, ⊥, ⊤) is a bounded lattice (H, ∨, ∧, ⊥, ⊤) equipped with a binary operation a → b of implication such that (c ∧ a) ≤ b is equivalent to c ≤ (a → b).\n\nGiven a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, these together form a Heyting algebra if and only if the following hold:\n\n(Implication1) a → a = ⊤\n(Implication2) a ∧ (a → b) = a ∧ b\n(Implication3) b ∧ (a → b) = b\n(Distributive law for →) a → (b ∧ c) = (a → b) ∧ (a → c)\n\nSee also FiniteBoundedLattice, BinaryOperation.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/#many-valued-logics-order-utilities","page":"Many-valued logics","title":"Order utilities","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-valued logics","title":"Many-valued logics","text":"precedeq\nprecedes\nsucceedeq\nsucceedes","category":"page"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.precedeq","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.precedeq","text":"function precedeq(\n    l::L,\n    t1::T1,\n    t2::T2\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    L<:FiniteAlgebra{T,D},\n    T1<:Truth,\n    T2<:Truth\n}\n\nReturn true if t1 ≤ t2 in l. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.\n\nSee also precedes, succeedes, succeedeq.\n\n\n\n\n\n","category":"function"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.precedes","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.precedes","text":"function precedes(\n    l::L,\n    t1::T1,\n    t2::T2\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    L<:FiniteAlgebra{T,D},\n    T1<:Truth,\n    T2<:Truth\n}\n\nReturn true if t1 < t2 in l. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.\n\nSee also precedeq, succeedes, succeedeq.\n\n\n\n\n\n","category":"function"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.succeedeq","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.succeedeq","text":"function succeedeq(\n    l::L,\n    t1::T1,\n    t2::T2\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    L<:FiniteAlgebra{T,D},\n    T1<:Truth,\n    T2<:Truth\n}\n\nReturn true if t1 ≥ t2 in l. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.\n\nSee also precedes, precedeq, succeedes.\n\n\n\n\n\n","category":"function"},{"location":"many-valued-logics/#SoleLogics.ManyValuedLogics.succeedes","page":"Many-valued logics","title":"SoleLogics.ManyValuedLogics.succeedes","text":"function succeedeq(\n    l::L,\n    t1::T,\n    t2::T\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    L<:FiniteAlgebra{T,D}\n}\n\nReturn true if t1 > t2 in l. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.\n\nSee also precedes, precedeq, succeedeq.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleLogics","category":"page"},{"location":"#SoleLogics","page":"Home","title":"SoleLogics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleLogics.jl, a Julia package for computational logic. To let you better orient yourself while understanding SoleLogics' structure, each chapter will begin with a little summary of what you are going to learn, in the form of small type-hierarchy trees that will grow during your reading journey. To see a complete map of SoleLogics.jl types and structures, please refer to Complete Exports Map.","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.jl allows manipulation of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Syntax tokens (e.g., atoms, logical constants (e.g., operators and truth values), etc.);\nAlphabets & context-free logical grammars (e.g., normal forms);\nAlgebras (e.g., crisp, fuzzy, many-valued);\nLogics (e.g., propositional, (multi)modal);\nFormulas (e.g., syntax trees, DNFs, CNFs): random generation, parsing, minimization;\nInterpretations (e.g., propositional assignments, Kripke structures);\nAlgorithms for evaluating the truth of a formula on an interpretation (model checking);\nInterfaces to Z3, for evaluating the validity/satisfiability of a propositional formula.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleLogics.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleLogics\")","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics.jl lays the logical foundations for Sole.jl, an open-source framework for symbolic machine learning, originally designed for machine learning based on modal logics (see Eduard I. Stan's PhD thesis 'Foundations of Modal Symbolic Learning' here).","category":"page"},{"location":"","page":"Home","title":"Home","text":"More on Sole:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SoleData.jl\nSoleFeatures.jl \nSoleModels.jl\nSolePostHoc.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"#complete-exports-map","page":"Home","title":"Complete Types Hierarchy Map","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a map of SoleLogics' most important types and structures. Feels overwhelming? Don't worry, if you are not practical with SoleLogics, this is useful to just know what definitions exist and hints at a glance how types are related to each other.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Syntactical\nConnective (¬, ∧, ∨, →, ◊, □)\nAbstractRelationalConnective\nDiamondRelationalConnective\nBoxRelationalConnective         \nFormula\nAnchoredFormula \nAbstractSyntaxStructure\nSyntaxTree              \nSyntaxLeaf\nAtom            \nTruth    \nBooleanTruth \nFiniteTruth \nSyntaxBranch        \nLeftmostLinearForm\nLiteral         \nOperator \nSyntaxToken\nAbstractInterpretation\nAbstractAssignment\nTruthDict\nDefaultedTruthDict\nAbstractKripkeStructure\nKripkeStructure\nLogicalInstance\nAbstractInterpretationSet\nInterpretationVector\nAbstractAlphabet\nExplicitAlphabet\nAlphabetOfAny\nAbstractGrammar \nCompleteFlatGrammar\nAbstractAlgebra\nBooleanAlgebra\nAbstractLogic\nBaseLogic\nAbstractWorld\nWorld\nPiont\nInterval\nInterval2D\nAbstractFrame\nAbstractUniModalFrame\nAbstractMultiModalFrame\nWrapperMultiModalFrame\nAbstractRelation","category":"page"},{"location":"hands-on/","page":"Hands On","title":"Hands On","text":"CurrentModule = SoleLogics","category":"page"},{"location":"hands-on/","page":"Hands On","title":"Hands On","text":"Pages = [\"hands-on.md\"]","category":"page"},{"location":"hands-on/","page":"Hands On","title":"Hands On","text":"TODO: get inspiration from Gio pluto tutorial","category":"page"},{"location":"more-on-interpretations/","page":"More on Interpretations","title":"More on Interpretations","text":"CurrentModule = SoleLogics","category":"page"},{"location":"more-on-interpretations/","page":"More on Interpretations","title":"More on Interpretations","text":"Pages = [\"more-on-interpretations.md\"]","category":"page"},{"location":"more-on-interpretations/#more-on-interpretations-section","page":"More on Interpretations","title":"More on Interpretations","text":"","category":"section"},{"location":"more-on-interpretations/","page":"More on Interpretations","title":"More on Interpretations","text":"","category":"page"}]
}
