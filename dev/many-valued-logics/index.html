<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Many-valued logics · SoleLogics.jl</title><meta name="title" content="Many-valued logics · SoleLogics.jl"/><meta property="og:title" content="Many-valued logics · SoleLogics.jl"/><meta property="twitter:title" content="Many-valued logics · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/many-valued-logics/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/many-valued-logics/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/many-valued-logics/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../base-logic/">Introduction to Logics and Propositional Logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li class="is-active"><a class="tocitem" href>Many-valued logics</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#many-valued-logics-operation"><span>Operation</span></a></li><li class="toplevel"><a class="tocitem" href="#many-valued-logics-axiom"><span>Axiom</span></a></li><li><a class="tocitem" href="#many-valued-logics-common-axioms"><span>Common axioms</span></a></li><li class="toplevel"><a class="tocitem" href="#many-valued-logics-finite-algebra"><span>Finite algebra</span></a></li><li><a class="tocitem" href="#many-valued-logics-monoid"><span>Monoid</span></a></li><li><a class="tocitem" href="#many-valued-logics-finite-lattice"><span>Finite lattice</span></a></li><li><a class="tocitem" href="#many-valued-logics-finite-algebra-varieties"><span>Finite algebra varieties</span></a></li><li class="toplevel"><a class="tocitem" href="#many-valued-logics-order-utilities"><span>Order utilities</span></a></li></ul></li><li><a class="tocitem" href="../more-on-formulas/">More on Formulas</a></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Many-valued logics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Many-valued logics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/many-valued-logics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#many-valued-logics-introduction">Introduction</a></li><li><a href="#many-valued-logics-operation">Operation</a></li><li><a href="#many-valued-logics-axiom">Axiom</a></li><li class="no-marker"><ul><li><a href="#many-valued-logics-common-axioms">Common axioms</a></li></ul></li><li><a href="#many-valued-logics-finite-algebra">Finite algebra</a></li><li class="no-marker"><ul><li><a href="#many-valued-logics-monoid">Monoid</a></li><li><a href="#many-valued-logics-finite-lattice">Finite lattice</a></li><li><a href="#many-valued-logics-finite-algebra-varieties">Finite algebra varieties</a></li></ul></li><li><a href="#many-valued-logics-order-utilities">Order utilities</a></li></ul><h1 id="many-valued-logics-introduction"><a class="docs-heading-anchor" href="#many-valued-logics-introduction">Introduction</a><a id="many-valued-logics-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-introduction" title="Permalink"></a></h1><p>SoleLogics also provides tools to work with <a href="https://en.wikipedia.org/wiki/Many-valued_logic">many-valued logics</a> (e.g., fuzzy logics), that is, logics with more truth values other than the classical Boolean ones <code>⊤</code> and <code>⊥</code>. With many-valued logics, the truth values are elements of a bounded lattice, providing a partial order between them, which encodes a <em>truer than</em> relation.</p><p>Most of the tools for dealing with these logics can be accessed by importing the ManyValuedLogics submodule:</p><pre><code class="language-julia hljs">using SoleLogics.ManyValuedLogics</code></pre><h1 id="many-valued-logics-operation"><a class="docs-heading-anchor" href="#many-valued-logics-operation">Operation</a><a id="many-valued-logics-operation-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-operation" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Operation"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Operation"><code>SoleLogics.ManyValuedLogics.Operation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Operation end</code></pre><p>An operation is a function which takes zero or more operands to a well-defined output value.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="../getting-started/#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/operations.jl#L4-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.BinaryOperation"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>SoleLogics.ManyValuedLogics.BinaryOperation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct BinaryOperation{N,M&lt;:SMatrix{N,N,FiniteTruth}} &lt;: AbstractBinaryOperation
    truthtable::M
end</code></pre><p>A binary operation on a set S is a mapping of the elements of the Cartesian product S × S → S. The closure property of a binary operation expresses the existence of a result for the operation given any pair of operands. Binary operations are required to be defined on all elements of S × S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Operation"><code>Operation</code></a>, <a href="../getting-started/#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/operations.jl#L38-L49">source</a></section></details></article><h1 id="many-valued-logics-axiom"><a class="docs-heading-anchor" href="#many-valued-logics-axiom">Axiom</a><a id="many-valued-logics-axiom-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-axiom" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Axiom"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Axiom"><code>SoleLogics.ManyValuedLogics.Axiom</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Axiom{Symbol} end</code></pre><p>An axiom is a statement that is taken to be true, to serve as a premise or starting point for further reasoning and arguments. Axioms aim to capture what is special about a particular structure (or set of structures).</p><p>See also <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L5-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.checkaxiom"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>SoleLogics.ManyValuedLogics.checkaxiom</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function checkaxiom(a::Axiom, args...)</code></pre><p>Check if axiom <code>a</code> is satisfied.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L16-L22">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Commutativity),
    o::O
) where {
    O&lt;:AbstractBinaryOperation
}</code></pre><p>A binary operation * on a set S is called commutative if x * y = y * x ∀ x, y ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L51-L62">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Associativity),
    o::O
) where {
    O&lt;:AbstractBinaryOperation
}</code></pre><p>A binary operation * on a set S is called associative if it satisfies the associative law: (x * y) * z = x * (y * z) ∀ x, y, z ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L92-L104">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(AbsorptionLaw),
    o1::O,
    o2::O
) where {
    O&lt;:AbstractBinaryOperation
}</code></pre><p>The absorption law or absorption identity is an identity linking a pair of binary operations. Two binary operations, * and ⋅, are said to be connected by the absotprion law if a * (a ⋅ b) = a ⋅ (a * b) = a.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L137-L151">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(LeftIdentity),
    o::O,
    e::T
) where {
    O&lt;:AbstractBinaryOperation,
    T&lt;:Truth
}</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a left identity if e * s = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L178-L192">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(RightIdentity),
    o::O,
    e::T
) where {
    O&lt;:AbstractBinaryOperation,
    T&lt;:Truth
}</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a right identity if s * e = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L217-L231">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(IdentityElement),
    o::O,
    e::T
) where {
    O&lt;:AbstractBinaryOperation,
    T&lt;:Truth
}</code></pre><p>An identity element or neutral element of a binary operation is an element that leaves unchanged every element when the operation is applied. I.e., let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a two-sided identity, or simply identity, if e is both a left identity and a right identity.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.LeftIdentity"><code>LeftIdentity</code></a>, <a href="#SoleLogics.ManyValuedLogics.RightIdentity"><code>RightIdentity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L259-L276">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(a::Axiom, m::Monoid{N}) where {N}</code></pre><p>Check if axiom <code>a</code> is satisfied by the operation of the monoid <code>m</code>.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L136-L142">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(RightResidual),
    m::Monoid{T}
) where {
    T&lt;:Truth,
}</code></pre><p>Check that ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L462-L473">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(LeftResidual),
    m::Monoid{T}
) where {
    T&lt;:Truth,
}</code></pre><p>Check that ∀ x ∈ S there exists for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L520-L531">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(ResiduationProperty),
    m::Monoid{N}
) where {
    N
}</code></pre><p>Check that ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S and for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L579-L591">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Implication1),
    o::B,
    top::Truth
) where {
    N,
    B&lt;:BinaryOperation{N}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, a → a = ⊤ holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L828-L842">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Implication2),
    o1::B,
    o2::B
) where {
    N,
    B&lt;:BinaryOperation{N}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), a ∧ (a → b) = a ∧ b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L867-L881">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Implication3),
    o1::B,
    o2::B
) where {
    N,
    B&lt;:BinaryOperation{N}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), b ∧ (a → b) = b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L908-L922">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(DistributiveLaw),
    o1::B,
    o2::B
) where {
    N,
    B&lt;:BinaryOperation{N}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ⋅ and *, ⋅ is distributive over * if ∀ a, b, c ∈ L: a ⋅ (b * c) = (a ⋅ b) * (a ⋅ c).</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L949-L963">source</a></section></details></article><h2 id="many-valued-logics-common-axioms"><a class="docs-heading-anchor" href="#many-valued-logics-common-axioms">Common axioms</a><a id="many-valued-logics-common-axioms-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-common-axioms" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Commutativity"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Commutativity"><code>SoleLogics.ManyValuedLogics.Commutativity</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Commutativity</code></pre><p>A binary operation * on a set S is called commutative if x * y = y * x ∀ x, y ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L42-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Associativity"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Associativity"><code>SoleLogics.ManyValuedLogics.Associativity</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Associativity</code></pre><p>A binary operation * on a set S is called associative if it satisfies the associative law: (x * y) * z = x * (y * z) ∀ x, y, z ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L82-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.AbsorptionLaw"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.AbsorptionLaw"><code>SoleLogics.ManyValuedLogics.AbsorptionLaw</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const AbsorptionLaw</code></pre><p>The absorption law or absorption identity is an identity linking a pair of binary operations. Two binary operations, * and ⋅, are said to be connected by the absorption law if a * (a ⋅ b) = a ⋅ (a * b) = a.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L126-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.LeftIdentity"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.LeftIdentity"><code>SoleLogics.ManyValuedLogics.LeftIdentity</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const LeftIdentity</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a left identity if e * s = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L168-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.RightIdentity"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.RightIdentity"><code>SoleLogics.ManyValuedLogics.RightIdentity</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const RightIdentity</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a right identity if s * e = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L207-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.IdentityElement"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.IdentityElement"><code>SoleLogics.ManyValuedLogics.IdentityElement</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const IdentityElement</code></pre><p>An identity element or neutral element of a binary operation is an element that leaves unchanged every element when the operation is applied. I.e., let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a two-sided identity, or simply identity, if e is both a left identity and a right identity.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.LeftIdentity"><code>LeftIdentity</code></a>, <a href="#SoleLogics.ManyValuedLogics.RightIdentity"><code>RightIdentity</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/axioms.jl#L246-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.RightResidual"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.RightResidual"><code>SoleLogics.ManyValuedLogics.RightResidual</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const RightResidual</code></pre><p>The right residual between two elements z, x ∈ S is the greatest y ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L453-L459">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.LeftResidual"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.LeftResidual"><code>SoleLogics.ManyValuedLogics.LeftResidual</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const LeftResidual</code></pre><p>The left residual between two elements z, y ∈ S is the greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L511-L517">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.ResiduationProperty"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.ResiduationProperty"><code>SoleLogics.ManyValuedLogics.ResiduationProperty</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const ResiduationProperty</code></pre><p>A lattice (L, ∨, ∧, ⋅, ⊥, →) is residuated if ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S and for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L569-L576">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Implication1"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Implication1"><code>SoleLogics.ManyValuedLogics.Implication1</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Implication1</code></pre><p>Axiom Implication1 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, a → a = ⊤ holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L818-L825">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Implication2"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Implication2"><code>SoleLogics.ManyValuedLogics.Implication2</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Implication2</code></pre><p>Axiom Implication2 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), a ∧ (a → b) = a ∧ b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L857-L864">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Implication3"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Implication3"><code>SoleLogics.ManyValuedLogics.Implication3</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Implication3</code></pre><p>Axiom Implication3 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), b ∧ (a → b) = b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L898-L905">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.DistributiveLaw"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.DistributiveLaw"><code>SoleLogics.ManyValuedLogics.DistributiveLaw</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const DistributiveLaw</code></pre><p>Given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ⋅ and *, ⋅ is distributive over * if ∀ a, b, c ∈ L: a ⋅ (b * c) = (a ⋅ b) * (a ⋅ c).</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L939-L946">source</a></section></details></article><h1 id="many-valued-logics-finite-algebra"><a class="docs-heading-anchor" href="#many-valued-logics-finite-algebra">Finite algebra</a><a id="many-valued-logics-finite-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-finite-algebra" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.FiniteAlgebra"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.FiniteAlgebra"><code>SoleLogics.ManyValuedLogics.FiniteAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type FiniteAlgebra{N} &lt;: AbstractAlgebra{FiniteTruth} end</code></pre><p>A finite algebra is an algebraic structure defined over a finite set.</p><p>See also <a href="../base-logic/#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L10-L16">source</a></section></details></article><h2 id="many-valued-logics-monoid"><a class="docs-heading-anchor" href="#many-valued-logics-monoid">Monoid</a><a id="many-valued-logics-monoid-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-monoid" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.Monoid"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.Monoid"><code>SoleLogics.ManyValuedLogics.Monoid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Monoid{T&lt;:Truth,D&lt;:AbstractVector{T},B&lt;:BinaryOperation{T}}
    operation::B
    identityelement::T
end</code></pre><p>A monoid (S, ⋅, e) is a set S equipped with a binary operation S × S → S, denoted as ⋅, satisfying the following axiomatic identities:</p><ul><li>(Associativity) ∀ a, b, c ∈ S, the equation (a ⋅ b) ⋅ c = a ⋅ (b ⋅ c) holds.</li><li>(Identity element) There exists an element e ∈ L such that for every element a ∈ S, the equalities e ⋅ a = a and a ⋅ e = a hold. </li></ul><p>The identity element of a monoid is unique.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>, <a href="@ref"><code>checkmonoidaxioms</code></a>, <a href="#SoleLogics.ManyValuedLogics.Associativity"><code>Associativity</code></a>, <a href="#SoleLogics.ManyValuedLogics.IdentityElement"><code>IdentityElement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L65-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.CommutativeMonoid"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.CommutativeMonoid"><code>SoleLogics.ManyValuedLogics.CommutativeMonoid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct CommutativeMonoid{N} &lt;: FiniteAlgebra{N}
    operation::BinaryOperation{N}
    identityelement::FiniteTruth
end</code></pre><p>A commutative monoid (S, ⋅, e) is a monoid whose operation is commutative.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.Commutativity"><code>Commutativity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L163-L172">source</a></section></details></article><h2 id="many-valued-logics-finite-lattice"><a class="docs-heading-anchor" href="#many-valued-logics-finite-lattice">Finite lattice</a><a id="many-valued-logics-finite-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-finite-lattice" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.FiniteLattice"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.FiniteLattice"><code>SoleLogics.ManyValuedLogics.FiniteLattice</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FiniteLattice{N} &lt;: FiniteAlgebra{N}
    join::BinaryOperation{N}
    meet::BinaryOperation{N}
end</code></pre><p>A finite lattice is a lattice defined over a finite set.</p><p>A lattice is an algebraic structure (L, ∨, ∧) consisting of a set L and two binary, commutative and associative operations ∨ and ∧ on L satisfying the following axiomatic identities for all elements a, b ∈ L (sometimes called absorption laws):</p><ul><li>a ∨ (a ∧ b) = a</li><li>a ∧ (a ∨ b) = a</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteAlgebra"><code>FiniteAlgebra</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L261-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>SoleLogics.ManyValuedLogics.FiniteBoundedLattice</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FiniteBoundedLattice{N} &lt;: FiniteAlgebra{N}
    join::BinaryOperation{N}
    meet::BinaryOperation{N}
    bot::FiniteTruth
    top::FiniteTruth
end</code></pre><p>A finite bounded lattice is a bounded lattice defined over a finite set.</p><p>A bounded lattice is an algebraic structure (L, ∨, ∧, ⊥, ⊤) such that (L, ∨, ∧) is a lattice, the bottom element ⊥ is the identity element for the join operation ∨, and the top element ⊤ is the identity element for the meet operation ∧:</p><ul><li>a ∨ ⊥ = a</li><li>a ∧ ⊤ = a</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteLattice"><code>FiniteLattice</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L371-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.FiniteResiduatedLattice"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.FiniteResiduatedLattice"><code>SoleLogics.ManyValuedLogics.FiniteResiduatedLattice</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FiniteResiduatedLattice{N} &lt;: FiniteAlgebra{N}
    join::BinaryOperation{N}
    meet::BinaryOperation{N}
    monoid::CommutativeMonoid{N}
    rightresidual::BinaryOperation{N}
    leftresidual::BinaryOperation{N}
    bot::FiniteTruth
    top::FiniteTruth
end</code></pre><p>A residuated lattice is an algebraic structure L = (L, ∨, ∧, ⋅, e) such that:</p><ul><li>(L, ∨, ∧) is a lattice</li><li>(L, ⋅, e) is a monoid</li><li>∀ x ∈ L there exists for every x ∈ L a greatest y ∈ L and for every y ∈ L a greatest x ∈ L such that x ⋅ y ≤ z</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>FiniteBoundedLattice</code></a>, </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L610-L628">source</a></section></details></article><h2 id="many-valued-logics-finite-algebra-varieties"><a class="docs-heading-anchor" href="#many-valued-logics-finite-algebra-varieties">Finite algebra varieties</a><a id="many-valued-logics-finite-algebra-varieties-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-finite-algebra-varieties" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.FiniteFLewAlgebra"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.FiniteFLewAlgebra"><code>SoleLogics.ManyValuedLogics.FiniteFLewAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FiniteFLewAlgebra{N} &lt;: FiniteAlgebra{N}
    join::BinaryOperation{N}
    meet::BinaryOperation{N}
    monoid::CommutativeMonoid{N}
    implication::BinaryOperation{N}
    bot::FiniteTruth
    top::FiniteTruth
end</code></pre><p>An FLew-algebra is an algebra (L, ∨, ∧, ⋅, →, ⊥, ⊤), where</p><ul><li>(L, ∨, ∧, ⊥, ⊤) is a bounded lattice with top element ⊤ and bottom element ⊥</li><li>(L, ⋅, ⊤) is a commutative monoid</li><li>The residuation property holds: x ⋅ y ≤ z iff x ≤ y → z</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>FiniteBoundedLattice</code></a>, <a href="#SoleLogics.ManyValuedLogics.CommutativeMonoid"><code>CommutativeMonoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L710-L726">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra"><code>SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FiniteHeytingAlgebra{N} &lt;: FiniteAlgebra{N}
    join::BinaryOperation{N}
    meet::BinaryOperation{N}
    implication::BinaryOperation{N}
    bot::FiniteTruth
    top::FiniteTruth
end</code></pre><p>A Heyting algebra (H, ∨, ∧, →, ⊥, ⊤) is a bounded lattice (H, ∨, ∧, ⊥, ⊤) equipped with a binary operation a → b of implication such that (c ∧ a) ≤ b is equivalent to c ≤ (a → b).</p><p>Given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, these together form a Heyting algebra if and only if the following hold:</p><ul><li>(Implication1) a → a = ⊤</li><li>(Implication2) a ∧ (a → b) = a ∧ b</li><li>(Implication3) b ∧ (a → b) = b</li><li>(Distributive law for →) a → (b ∧ c) = (a → b) ∧ (a → c)</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>FiniteBoundedLattice</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/finite-algebras.jl#L982-L1002">source</a></section></details></article><h1 id="many-valued-logics-order-utilities"><a class="docs-heading-anchor" href="#many-valued-logics-order-utilities">Order utilities</a><a id="many-valued-logics-order-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-order-utilities" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.precedeq"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.precedeq"><code>SoleLogics.ManyValuedLogics.precedeq</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function precedeq(
    l::L,
    t1::T1,
    t2::T2
) where {
    N,
    L&lt;:FiniteAlgebra{N},
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> ≤ <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L3-L19">source</a></section><section><div><pre><code class="language-julia hljs">function precedeq(
    l::FuzzyLogic,
    t1::T1,
    t2::T2
) where {
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> ≤ <code>t2</code> in fuzzy logic <code>l</code>. For continuous truth values,  this is the standard strict less-than ordering on real numbers in [0,1].</p><p>See also <a href="#SoleLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L41-L55">source</a></section><section><div><pre><code class="language-julia hljs">function precedeq(
    l::ManyExpertAlgebra,
    t1::NTuple{N, T1},
    t2::NTuple{N, T2}
) where {
    T1 &lt;: Truth,
    T2 &lt;: Truth,
    N
}</code></pre><p>Return true if each truth in the tuple <code>t1</code> ≤ <code>t2</code> in a many expert algebra. For continuous  truth values, this is the standard strict less-than ordering on real numbers in [0,1].</p><p>See also <a href="#SoleLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L69-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.precedes"><a class="docstring-binding" href="#SoleLogics.precedes"><code>SoleLogics.precedes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">precedes(t1::Truth, t2::Truth)::Bool</code></pre><p>Encodes the order relation (also denoted as <code>≺</code>) between truth values.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using SoleLogics


julia&gt; SoleLogics.precedes(⊥, ⊤)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/types/syntactical.jl#L809-L822">source</a></section><section><div><pre><code class="language-julia hljs">function precedes(
    l::L,
    t1::T1,
    t2::T2
) where {
    N,
    L&lt;:FiniteAlgebra{N},
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> &lt; <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L100-L116">source</a></section><section><div><pre><code class="language-julia hljs">function precedes(
    l::FuzzyLogic,
    t1::T1,
    t2::T2
) where {
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> &lt; <code>t2</code> in fuzzy logic <code>l</code>. For continuous truth values,  this is the standard strict less-than ordering on real numbers in [0,1].</p><p>See also <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L134-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.succeedeq"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.succeedeq"><code>SoleLogics.ManyValuedLogics.succeedeq</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function succeedeq(
    l::L,
    t1::T1,
    t2::T2
) where {
    N,
    L&lt;:FiniteAlgebra{N},
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> ≥ <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L194-L210">source</a></section><section><div><pre><code class="language-julia hljs">function succeedeq(
    l::FuzzyLogic,
    t1::T1,
    t2::T2
) where {
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> ≥ <code>t2</code> in fuzzy logic <code>l</code>. For continuous truth values,  this is the standard greater-than-or-equal ordering on real numbers in [0,1].</p><p>See also <a href="#SoleLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L228-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SoleLogics.ManyValuedLogics.succeedes"><a class="docstring-binding" href="#SoleLogics.ManyValuedLogics.succeedes"><code>SoleLogics.ManyValuedLogics.succeedes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function succeedes(
    l::L,
    t1::T1,
    t2::T2
) where {
    N,
    L&lt;:FiniteAlgebra{N},
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> &gt; <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L288-L304">source</a></section><section><div><pre><code class="language-julia hljs">function succeedes(
    l::FuzzyLogic,
    t1::T1,
    t2::T2
) where {
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> &gt; <code>t2</code> in fuzzy logic <code>l</code>. For continuous truth values,  this is the standard strict greater-than ordering on real numbers in [0,1].</p><p>See also <a href="#SoleLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/7aff93fe298cadd430de35101bbf4dfb03dcad2e/src/many-valued-logics/order-utilities.jl#L322-L336">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modal-logic/">« Modal Logic</a><a class="docs-footer-nextpage" href="../more-on-formulas/">More on Formulas »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 11:06">Tuesday 3 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
