<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Many-valued logics · SoleLogics.jl</title><meta name="title" content="Many-valued logics · SoleLogics.jl"/><meta property="og:title" content="Many-valued logics · SoleLogics.jl"/><meta property="twitter:title" content="Many-valued logics · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/many-valued-logics/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/many-valued-logics/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/many-valued-logics/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../base-logic/">Introduction to Logics and Propositional Logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li class="is-active"><a class="tocitem" href>Many-valued logics</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#many-valued-logics-operation"><span>Operation</span></a></li><li class="toplevel"><a class="tocitem" href="#many-valued-logics-axiom"><span>Axiom</span></a></li><li><a class="tocitem" href="#many-valued-logics-common-axioms"><span>Common axioms</span></a></li><li class="toplevel"><a class="tocitem" href="#many-valued-logics-finite-algebra"><span>Finite algebra</span></a></li><li><a class="tocitem" href="#many-valued-logics-monoid"><span>Monoid</span></a></li><li><a class="tocitem" href="#many-valued-logics-finite-lattice"><span>Finite lattice</span></a></li><li><a class="tocitem" href="#many-valued-logics-finite-algebra-varieties"><span>Finite algebra varieties</span></a></li><li class="toplevel"><a class="tocitem" href="#many-valued-logics-order-utilities"><span>Order utilities</span></a></li></ul></li><li><a class="tocitem" href="../more-on-formulas/">More on Formulas</a></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Many-valued logics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Many-valued logics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/many-valued-logics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#many-valued-logics-introduction">Introduction</a></li><li><a href="#many-valued-logics-operation">Operation</a></li><li><a href="#many-valued-logics-axiom">Axiom</a></li><li class="no-marker"><ul><li><a href="#many-valued-logics-common-axioms">Common axioms</a></li></ul></li><li><a href="#many-valued-logics-finite-algebra">Finite algebra</a></li><li class="no-marker"><ul><li><a href="#many-valued-logics-monoid">Monoid</a></li><li><a href="#many-valued-logics-finite-lattice">Finite lattice</a></li><li><a href="#many-valued-logics-finite-algebra-varieties">Finite algebra varieties</a></li></ul></li><li><a href="#many-valued-logics-order-utilities">Order utilities</a></li></ul><h1 id="many-valued-logics-introduction"><a class="docs-heading-anchor" href="#many-valued-logics-introduction">Introduction</a><a id="many-valued-logics-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-introduction" title="Permalink"></a></h1><p>SoleLogics also provides tools to work with <a href="https://en.wikipedia.org/wiki/Many-valued_logic">many-valued logics</a> (e.g., fuzzy logics), that is, logics with more truth values other than the classical Boolean ones <code>⊤</code> and <code>⊥</code>. With many-valued logics, the truth values are elements of a bounded lattice, providing a partial order between them, which encodes a <em>truer than</em> relation.</p><p>Most of the tools for dealing with these logics can be accessed by importing the ManyValuedLogics submodule:</p><pre><code class="language-julia hljs">using SoleLogics.ManyValuedLogics</code></pre><h1 id="many-valued-logics-operation"><a class="docs-heading-anchor" href="#many-valued-logics-operation">Operation</a><a id="many-valued-logics-operation-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-operation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Operation" href="#SoleLogics.ManyValuedLogics.Operation"><code>SoleLogics.ManyValuedLogics.Operation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Operation end</code></pre><p>An operation is a function which takes zero or more operands to a well-defined output value.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="../getting-started/#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/operations.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.BinaryOperation" href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>SoleLogics.ManyValuedLogics.BinaryOperation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BinaryOperation{T&lt;:Truth, D&lt;:AbstractVector{T}} &lt;: Operation
    domain::D
    truthtable::AbstractDict{Tuple{T, T}, T}
end</code></pre><p>A binary operation on a set S is a mapping of the elements of the Cartesian product S × S → S. The closure property of a binary operation expresses the existence of a result for the operation given any pair of operands. Binary operations are required to be defined on all elements of S × S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Operation"><code>Operation</code></a>, <a href="../getting-started/#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/operations.jl#L35-L47">source</a></section></article><h1 id="many-valued-logics-axiom"><a class="docs-heading-anchor" href="#many-valued-logics-axiom">Axiom</a><a id="many-valued-logics-axiom-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-axiom" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Axiom" href="#SoleLogics.ManyValuedLogics.Axiom"><code>SoleLogics.ManyValuedLogics.Axiom</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Axiom{Symbol} end</code></pre><p>An axiom is a statement that is taken to be true, to serve as a premise or starting point for further reasoning and arguments. Axioms aim to capture what is special about a particular structure (or set of structures).</p><p>See also <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.checkaxiom" href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>SoleLogics.ManyValuedLogics.checkaxiom</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function checkaxiom(a::Axiom, args...)</code></pre><p>Check if axiom <code>a</code> is satisfied.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L16-L22">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Commutativity),
    o::BinaryOperation{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>A binary operation * on a set S is called commutative if x * y = y * x ∀ x, y ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L51-L63">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Associativity),
    o::BinaryOperation{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>A binary operation * on a set S is called associative if it satisfies the associative law: (x * y) * z = x * (y * z) ∀ x, y, z ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L94-L107">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(AbsorptionLaw),
    o1::BinaryOperation{T,D},
    o2::BinaryOperation{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>The absorption law or absorption identity is an identity linking a pair of binary operations. Two binary operations, * and ⋅, are said to be connected by the absotprion law if a * (a ⋅ b) = a ⋅ (a * b) = a.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L141-L156">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(LeftIdentity),
    o::BinaryOperation{T,D},
    e::T
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a left identity if e * s = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L184-L198">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(RightIdentity),
    o::BinaryOperation{T,D},
    e::T
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a right identity if s * e = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L223-L237">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(IdentityElement),
    o::BinaryOperation{T,D},
    e::T
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>An identity element or neutral element of a binary operation is an element that leaves unchanged every element when the operation is applied. I.e., let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a two-sided identity, or simply identity, if e is both a left identity and a right identity.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.LeftIdentity"><code>LeftIdentity</code></a>, <a href="#SoleLogics.ManyValuedLogics.RightIdentity"><code>RightIdentity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L265-L282">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(a::Axiom, m::Monoid{T,D}) where {T&lt;:Truth, D&lt;:AbstractVector{T}}</code></pre><p>Check if axiom <code>a</code> is satisfied by the operation of the monoid <code>m</code>.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L156-L162">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(RightResidual),
    m::Monoid{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Check that ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L489-L501">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(LeftResidual),
    m::Monoid{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Check that ∀ x ∈ S there exists for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L548-L560">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(ResiduationProperty),
    m::Monoid{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Check that ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S and for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L608-L621">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Implication1),
    o::BinaryOperation{T,D},
    top::Truth
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, a → a = ⊤ holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L859-L873">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Implication2),
    o1::BinaryOperation{T,D},
    o2::BinaryOperation{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), a ∧ (a → b) = a ∧ b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L898-L912">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(Implication3),
    o1::BinaryOperation{T,D},
    o2::BinaryOperation{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), b ∧ (a → b) = b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L939-L953">source</a></section><section><div><pre><code class="language-julia hljs">function checkaxiom(
    ::typeof(DistributiveLaw),
    o1::BinaryOperation{T,D},
    o2::BinaryOperation{T,D}
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T}
}</code></pre><p>Check if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ⋅ and *, ⋅ is distributive over * if ∀ a, b, c ∈ L: a ⋅ (b * c) = (a ⋅ b) * (a ⋅ c).</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L980-L994">source</a></section></article><h2 id="many-valued-logics-common-axioms"><a class="docs-heading-anchor" href="#many-valued-logics-common-axioms">Common axioms</a><a id="many-valued-logics-common-axioms-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-common-axioms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Commutativity" href="#SoleLogics.ManyValuedLogics.Commutativity"><code>SoleLogics.ManyValuedLogics.Commutativity</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const Commutativity</code></pre><p>A binary operation * on a set S is called commutative if x * y = y * x ∀ x, y ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Associativity" href="#SoleLogics.ManyValuedLogics.Associativity"><code>SoleLogics.ManyValuedLogics.Associativity</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const Associativity</code></pre><p>A binary operation * on a set S is called associative if it satisfies the associative law: (x * y) * z = x * (y * z) ∀ x, y, z ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.AbsorptionLaw" href="#SoleLogics.ManyValuedLogics.AbsorptionLaw"><code>SoleLogics.ManyValuedLogics.AbsorptionLaw</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const AbsorptionLaw</code></pre><p>The absorption law or absorption identity is an identity linking a pair of binary operations. Two binary operations, * and ⋅, are said to be connected by the absorption law if a * (a ⋅ b) = a ⋅ (a * b) = a.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.LeftIdentity" href="#SoleLogics.ManyValuedLogics.LeftIdentity"><code>SoleLogics.ManyValuedLogics.LeftIdentity</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LeftIdentity</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a left identity if e * s = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L174-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.RightIdentity" href="#SoleLogics.ManyValuedLogics.RightIdentity"><code>SoleLogics.ManyValuedLogics.RightIdentity</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const RightIdentity</code></pre><p>Let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a right identity if s * e = s ∀ s ∈ S.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.IdentityElement" href="#SoleLogics.ManyValuedLogics.IdentityElement"><code>SoleLogics.ManyValuedLogics.IdentityElement</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const IdentityElement</code></pre><p>An identity element or neutral element of a binary operation is an element that leaves unchanged every element when the operation is applied. I.e., let (S, *) be a set S equipped with a binary operation *. Then an element e of S is called a two-sided identity, or simply identity, if e is both a left identity and a right identity.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.LeftIdentity"><code>LeftIdentity</code></a>, <a href="#SoleLogics.ManyValuedLogics.RightIdentity"><code>RightIdentity</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/axioms.jl#L252-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.RightResidual" href="#SoleLogics.ManyValuedLogics.RightResidual"><code>SoleLogics.ManyValuedLogics.RightResidual</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const RightResidual</code></pre><p>The right residual between two elements z, x ∈ S is the greatest y ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L480-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.LeftResidual" href="#SoleLogics.ManyValuedLogics.LeftResidual"><code>SoleLogics.ManyValuedLogics.LeftResidual</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LeftResidual</code></pre><p>The left residual between two elements z, y ∈ S is the greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L539-L545">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.ResiduationProperty" href="#SoleLogics.ManyValuedLogics.ResiduationProperty"><code>SoleLogics.ManyValuedLogics.ResiduationProperty</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ResiduationProperty</code></pre><p>A lattice (L, ∨, ∧, ⋅, ⊥, →) is residuated if ∀ x ∈ S there exists for every x ∈ S a greatest y ∈ S and for every y ∈ S a greatest x ∈ S such that x ⋅ y ≤ z.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L598-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Implication1" href="#SoleLogics.ManyValuedLogics.Implication1"><code>SoleLogics.ManyValuedLogics.Implication1</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const Implication1</code></pre><p>Axiom Implication1 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, a → a = ⊤ holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L849-L856">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Implication2" href="#SoleLogics.ManyValuedLogics.Implication2"><code>SoleLogics.ManyValuedLogics.Implication2</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const Implication2</code></pre><p>Axiom Implication2 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), a ∧ (a → b) = a ∧ b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L888-L895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Implication3" href="#SoleLogics.ManyValuedLogics.Implication3"><code>SoleLogics.ManyValuedLogics.Implication3</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const Implication3</code></pre><p>Axiom Implication3 is satisfied if given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ∧ (<code>o1</code>) and → (<code>o2</code>), b ∧ (a → b) = b holds.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L929-L936">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.DistributiveLaw" href="#SoleLogics.ManyValuedLogics.DistributiveLaw"><code>SoleLogics.ManyValuedLogics.DistributiveLaw</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const DistributiveLaw</code></pre><p>Given a bounded lattice (H, ∨, ∧, ⊥, ⊤) and two binary operations ⋅ and *, ⋅ is distributive over * if ∀ a, b, c ∈ L: a ⋅ (b * c) = (a ⋅ b) * (a ⋅ c).</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L970-L977">source</a></section></article><h1 id="many-valued-logics-finite-algebra"><a class="docs-heading-anchor" href="#many-valued-logics-finite-algebra">Finite algebra</a><a id="many-valued-logics-finite-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-finite-algebra" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.FiniteAlgebra" href="#SoleLogics.ManyValuedLogics.FiniteAlgebra"><code>SoleLogics.ManyValuedLogics.FiniteAlgebra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type FiniteAlgebra{T&lt;:Truth, D&lt;:AbstractVector{T}} &lt;: AbstractAlgebra{T} end</code></pre><p>A finite algebra is an algebraic structure defined over a finite set.</p><p>See also <a href="../base-logic/#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L35-L41">source</a></section></article><h2 id="many-valued-logics-monoid"><a class="docs-heading-anchor" href="#many-valued-logics-monoid">Monoid</a><a id="many-valued-logics-monoid-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-monoid" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.Monoid" href="#SoleLogics.ManyValuedLogics.Monoid"><code>SoleLogics.ManyValuedLogics.Monoid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Monoid{T&lt;:Truth, D&lt;:AbstractVector{T}}
    operation::BinaryOperation{T,D}
    identityelement::T
end</code></pre><p>A monoid (S, ⋅, e) is a set S equipped with a binary operation S × S → S, denoted as ⋅, satisfying the following axiomatic identities:</p><ul><li>(Associativity) ∀ a, b, c ∈ S, the equation (a ⋅ b) ⋅ c = a ⋅ (b ⋅ c) holds.</li><li>(Identity element) There exists an element e ∈ L such that for every element a ∈ S, the equalities e ⋅ a = a and a ⋅ e = a hold. </li></ul><p>The identity element of a monoid is unique.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>, <a href="#SoleLogics.ManyValuedLogics.Axiom"><code>Axiom</code></a>, <a href="#SoleLogics.ManyValuedLogics.checkaxiom"><code>checkaxiom</code></a>, <a href="@ref"><code>checkmonoidaxioms</code></a>, <a href="#SoleLogics.ManyValuedLogics.Associativity"><code>Associativity</code></a>, <a href="#SoleLogics.ManyValuedLogics.IdentityElement"><code>IdentityElement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L84-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.CommutativeMonoid" href="#SoleLogics.ManyValuedLogics.CommutativeMonoid"><code>SoleLogics.ManyValuedLogics.CommutativeMonoid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CommutativeMonoid{T&lt;:Truth, D&lt;:AbstractVector{T}}
    operation::BinaryOperation{T,D}
    identityelement::T
end</code></pre><p>A commutative monoid (S, ⋅, e) is a monoid whose operation is commutative.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.Monoid"><code>Monoid</code></a>, <a href="#SoleLogics.ManyValuedLogics.Commutativity"><code>Commutativity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L180-L189">source</a></section></article><h2 id="many-valued-logics-finite-lattice"><a class="docs-heading-anchor" href="#many-valued-logics-finite-lattice">Finite lattice</a><a id="many-valued-logics-finite-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-finite-lattice" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.FiniteLattice" href="#SoleLogics.ManyValuedLogics.FiniteLattice"><code>SoleLogics.ManyValuedLogics.FiniteLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteLattice{T&lt;:Truth, D&lt;:AbstractVector{T}} &lt;: FiniteAlgebra{T,D}
    join::BinaryOperation{T,D}
    meet::BinaryOperation{T,D}
end</code></pre><p>A finite lattice is a lattice defined over a finite set.</p><p>A lattice is an algebraic structure (L, ∨, ∧) consisting of a set L and two binary, commutative and associative operations ∨ and ∧ on L satisfying the following axiomatic identities for all elements a, b ∈ L (sometimes called absorption laws):</p><ul><li>a ∨ (a ∧ b) = a</li><li>a ∧ (a ∨ b) = a</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteAlgebra"><code>FiniteAlgebra</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L267-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.FiniteBoundedLattice" href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>SoleLogics.ManyValuedLogics.FiniteBoundedLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteBoundedLattice{T&lt;:Truth, D&lt;:AbstractVector{T}} &lt;: FiniteAlgebra{T,D}
    join::BinaryOperation{T,D}
    meet::BinaryOperation{T,D}
    bot::T
    top::T
end</code></pre><p>A finite bounded lattice is a bounded lattice defined over a finite set.</p><p>A bounded lattice is an algebraic structure (L, ∨, ∧, ⊥, ⊤) such that (L, ∨, ∧) is a lattice, the bottom element ⊥ is the identity element for the join operation ∨, and the top element ⊤ is the identity element for the meet operation ∧:</p><ul><li>a ∨ ⊥ = a</li><li>a ∧ ⊤ = a</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteLattice"><code>FiniteLattice</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L395-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.FiniteResiduatedLattice" href="#SoleLogics.ManyValuedLogics.FiniteResiduatedLattice"><code>SoleLogics.ManyValuedLogics.FiniteResiduatedLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteResiduatedLattice{T&lt;:Truth, D&lt;:AbstractVector{T}} &lt;: FiniteAlgebra{T,D}
    domain::D
    join::BinaryOperation{T,D}
    meet::BinaryOperation{T,D}
    monoid::Monoid{T,D}
    rightresidual::BinaryOperation{T,D}
    leftresidual::BinaryOperation{T,D}
    bot::T
    top::T
end</code></pre><p>A residuated lattice is an algebraic structure L = (L, ∨, ∧, ⋅, e) such that:</p><ul><li>(L, ∨, ∧) is a lattice</li><li>(L, ⋅, e) is a monoid</li><li>∀ x ∈ L there exists for every x ∈ L a greatest y ∈ L and for every y ∈ L a greatest x ∈ L such that x ⋅ y ≤ z</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>FiniteBoundedLattice</code></a>, </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L640-L659">source</a></section></article><h2 id="many-valued-logics-finite-algebra-varieties"><a class="docs-heading-anchor" href="#many-valued-logics-finite-algebra-varieties">Finite algebra varieties</a><a id="many-valued-logics-finite-algebra-varieties-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-finite-algebra-varieties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.FiniteFLewAlgebra" href="#SoleLogics.ManyValuedLogics.FiniteFLewAlgebra"><code>SoleLogics.ManyValuedLogics.FiniteFLewAlgebra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteFLewAlgebra{T&lt;:Truth, D&lt;:AbstractVector{T}} &lt;: FiniteAlgebra{T,D}
    domain::D
    join::BinaryOperation{T,D}
    meet::BinaryOperation{T,D}
    monoid::Monoid{T,D}
    implication::BinaryOperation{T,D}
    bot::T
    top::T
end</code></pre><p>An FLew-algebra is an algebra (L, ∨, ∧, ⋅, →, ⊥, ⊤), where</p><ul><li>(L, ∨, ∧, ⊥, ⊤) is a bounded lattice with top element ⊤ and bottom element ⊥</li><li>(L, ⋅, ⊤) is a commutative monoid</li><li>The residuation property holds: x ⋅ y ≤ z iff x ≤ y → z</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>FiniteBoundedLattice</code></a>, <a href="#SoleLogics.ManyValuedLogics.CommutativeMonoid"><code>CommutativeMonoid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L740-L757">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra" href="#SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra"><code>SoleLogics.ManyValuedLogics.FiniteHeytingAlgebra</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FiniteHeytingAlgebra{T&lt;:Truth, D&lt;:AbstractVector{T}} &lt;: FiniteAlgebra{T,D}
    domain::D
    join::BinaryOperation{T,D}
    meet::BinaryOperation{T,D}
    implication::BinaryOperation{T,D}
    bot::T
    top::T
end</code></pre><p>A Heyting algebra (H, ∨, ∧, →, ⊥, ⊤) is a bounded lattice (H, ∨, ∧, ⊥, ⊤) equipped with a binary operation a → b of implication such that (c ∧ a) ≤ b is equivalent to c ≤ (a → b).</p><p>Given a bounded lattice (H, ∨, ∧, ⊥, ⊤) with largest and smallest elements ⊤ and ⊥, and a binary operation →, these together form a Heyting algebra if and only if the following hold:</p><ul><li>(Implication1) a → a = ⊤</li><li>(Implication2) a ∧ (a → b) = a ∧ b</li><li>(Implication3) b ∧ (a → b) = b</li><li>(Distributive law for →) a → (b ∧ c) = (a → b) ∧ (a → c)</li></ul><p>See also <a href="#SoleLogics.ManyValuedLogics.FiniteBoundedLattice"><code>FiniteBoundedLattice</code></a>, <a href="#SoleLogics.ManyValuedLogics.BinaryOperation"><code>BinaryOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/finite-algebras.jl#L1013-L1034">source</a></section></article><h1 id="many-valued-logics-order-utilities"><a class="docs-heading-anchor" href="#many-valued-logics-order-utilities">Order utilities</a><a id="many-valued-logics-order-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#many-valued-logics-order-utilities" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.precedeq" href="#SoleLogics.ManyValuedLogics.precedeq"><code>SoleLogics.ManyValuedLogics.precedeq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function precedeq(
    l::L,
    t1::T1,
    t2::T2
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T},
    L&lt;:FiniteAlgebra{T,D},
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> ≤ <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/order-utilities.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.precedes" href="#SoleLogics.ManyValuedLogics.precedes"><code>SoleLogics.ManyValuedLogics.precedes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function precedes(
    l::L,
    t1::T1,
    t2::T2
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T},
    L&lt;:FiniteAlgebra{T,D},
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> &lt; <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/order-utilities.jl#L41-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.succeedeq" href="#SoleLogics.ManyValuedLogics.succeedeq"><code>SoleLogics.ManyValuedLogics.succeedeq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function succeedeq(
    l::L,
    t1::T1,
    t2::T2
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T},
    L&lt;:FiniteAlgebra{T,D},
    T1&lt;:Truth,
    T2&lt;:Truth
}</code></pre><p>Return true if <code>t1</code> ≥ <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedes"><code>succeedes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/order-utilities.jl#L73-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.ManyValuedLogics.succeedes" href="#SoleLogics.ManyValuedLogics.succeedes"><code>SoleLogics.ManyValuedLogics.succeedes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function succeedeq(
    l::L,
    t1::T,
    t2::T
) where {
    T&lt;:Truth,
    D&lt;:AbstractVector{T},
    L&lt;:FiniteAlgebra{T,D}
}</code></pre><p>Return true if <code>t1</code> &gt; <code>t2</code> in <code>l</code>. Given an algebraically defined lattice (L, ∨, ∧), one can define a partial order ≤ on L by setting a ≤ b if a = a ∧ b.</p><p>See also <a href="#SoleLogics.ManyValuedLogics.precedes"><code>precedes</code></a>, <a href="#SoleLogics.ManyValuedLogics.precedeq"><code>precedeq</code></a>, <a href="#SoleLogics.ManyValuedLogics.succeedeq"><code>succeedeq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e59bdad48d96dc8ebd2eab05aaa1ed8481a5293b/src/many-valued-logics/order-utilities.jl#L105-L120">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modal-logic/">« Modal Logic</a><a class="docs-footer-nextpage" href="../more-on-formulas/">More on Formulas »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 25 October 2024 14:27">Friday 25 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
