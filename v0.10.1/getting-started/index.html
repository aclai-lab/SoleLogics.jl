<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · SoleLogics.jl</title><meta name="title" content="Getting started · SoleLogics.jl"/><meta property="og:title" content="Getting started · SoleLogics.jl"/><meta property="twitter:title" content="Getting started · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/getting-started/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/getting-started/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/getting-started/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Type-hierarchy"><span>Type hierarchy</span></a></li><li><a class="tocitem" href="#syntactical-base-definitions"><span>Syntax Basics</span></a></li><li><a class="tocitem" href="#semantics-base-definitions"><span>Semantics Basics</span></a></li></ul></li><li><a class="tocitem" href="../base-logic/">Introduction to Logics and Propositional Logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li><a class="tocitem" href="../many-valued-logics/">Many-valued logics</a></li><li><a class="tocitem" href="../more-on-formulas/">More on Formulas</a></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/getting-started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-core"><a class="docs-heading-anchor" href="#man-core">Getting started</a><a id="man-core-1"></a><a class="docs-heading-anchor-permalink" href="#man-core" title="Permalink"></a></h1><p>In this introductory section you will learn about the main building blocks of SoleLogics. Their definition, usage examples and how to customize them to your own needs. </p><p>In short, you can consider this package as divided into two halves.:</p><ul><li>the <a href="https://en.wikipedia.org/wiki/Syntax">syntactical</a> half, which defines structures to represent logical constructs such as assertions, logical constants, alphabets, grammars, crisp and fuzzy algebras, formulas etc. A consistent part of SoleLogics is devoted to randomly generate such structures, as well as parse and minimize formulas;</li><li>the <a href="https://en.wikipedia.org/wiki/Semantics">semantic</a> half, which defines rules to apply when interpreting a logical formulas. The &quot;semantic heart&quot; of SoleLogics is its finite <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a> algorithm, whose purpose is to efficiently check whether a formula is satisfied by an interpretation or not.</li></ul><p>Please, feel free to use the following tree structures to orient yourself in the reading of this section. More pieces will be added to this type-hierarchy tree in the following sections.</p><h2 id="Type-hierarchy"><a class="docs-heading-anchor" href="#Type-hierarchy">Type hierarchy</a><a id="Type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy" title="Permalink"></a></h2><ul><li><a href="#SoleLogics.Syntactical"><code>Syntactical</code></a><ul><li><a href="#SoleLogics.Connective"><code>Connective</code></a>                      (e.g., ∧, ∨, ¬, →)</li><li><a href="#SoleLogics.Formula"><code>Formula</code></a><ul><li><a href="#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a><ul><li><a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>              (e.g., ¬p ∧ q → s)<ul><li><a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a><ul><li><a href="#SoleLogics.Atom"><code>Atom</code></a>            (e.g., p, q)</li><li><a href="#SoleLogics.Truth"><code>Truth</code></a>           (e.g., ⊤, ⊥)</li></ul></li><li><a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>        (e.g., p ∧ q)</li></ul></li></ul></li></ul></li></ul></li><li><a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a> (e.g., p is ⊤, equivalent to p is true in boolean logic)</li></ul><p>Also, two union types are defined:</p><ul><li><a href="#SoleLogics.Operator"><code>Operator</code></a>, that is, <code>Union{Connective,Truth}</code>, </li><li><a href="#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>, that is, <code>Union{Atom,Connective}</code>.  </li></ul><h2 id="syntactical-base-definitions"><a class="docs-heading-anchor" href="#syntactical-base-definitions">Syntax Basics</a><a id="syntactical-base-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#syntactical-base-definitions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Syntactical" href="#SoleLogics.Syntactical"><code>SoleLogics.Syntactical</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Syntactical end</code></pre><p>Master abstract type for all syntactical objects (e.g., formulas, connectives).</p><p><strong>Interface</strong></p><ul><li><code>syntaxstring(s::Syntactical; kwargs...)::String</code></li></ul><p>See also <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L25-L34">source</a></section></article><p>To print out a generic <a href="#SoleLogics.Syntactical"><code>Syntactical</code></a> element, we must define how it is converted into a string. To do this, we can implement a custom <a href="#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.syntaxstring-Tuple{Syntactical}" href="#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>SoleLogics.syntaxstring</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syntaxstring(s::Syntactical; kwargs...)::String</code></pre><p>Return the string representation of any syntactic object (e.g., <code>Formula</code>, <code>SyntaxTree</code>, <code>SyntaxToken</code>, <code>Atom</code>, <code>Truth</code>, etc). Note that this representation may introduce redundant parentheses. <code>kwargs</code> can be used to specify how to display syntax tokens/trees under some specific conditions.</p><p>The following <code>kwargs</code> are currently supported:</p><ul><li><code>function_notation = false::Bool</code>: when set to <code>true</code>, it forces the use of  function notation for binary operators  (see <a href="https://en.wikipedia.org/wiki/Infix_notation">here</a>).</li><li><code>remove_redundant_parentheses = true::Bool</code>: when set to <code>false</code>, it prints a syntaxstring  where each syntactical element is wrapped in parentheses.</li><li><code>parenthesize_atoms = !remove_redundant_parentheses::Bool</code>: when set to <code>true</code>,  it forces the atoms (which are the leaves of a formula&#39;s tree structure) to be  wrapped in parentheses.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;))
&quot;p ∧ q ∧ r ∧ s ∧ t&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), function_notation=true)
&quot;∧(∧(∧(∧(p, q), r), s), t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=false)
&quot;((((p) ∧ (q)) ∧ (r)) ∧ (s)) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;p∧q∧r∧s∧t&quot;), remove_redundant_parentheses=true, parenthesize_atoms=true)
&quot;(p) ∧ (q) ∧ (r) ∧ (s) ∧ (t)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;))
&quot;◊((p ∧ s) → q)&quot;

julia&gt; syntaxstring(parseformula(&quot;◊((p∧s)→q)&quot;); function_notation = true)
&quot;◊(→(∧(p, s), q))&quot;</code></pre><p>See also <a href="../more-on-formulas/#SoleLogics.parseformula"><code>parseformula</code></a>, <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>.</p><p><strong>Implementation</strong></p><p>In the case of a syntax tree, <code>syntaxstring</code> is a recursive function that calls itself on the syntax children of each node. For a correct functioning, the <code>syntaxstring</code> must be defined (including the <code>kwargs...</code> part!) for every newly defined <code>SyntaxToken</code> (e.g., <code>SyntaxLeaf</code>s, that is, <code>Atom</code>s and <code>Truth</code> values, and <code>Operator</code>s), in a way that it produces a <em>unique</em> string representation, since <code>Base.hash</code> and <code>Base.isequal</code>, at least for <code>SyntaxTree</code>s, rely on it.</p><p>In particular, for the case of <code>Atom</code>s, the function calls itself on the wrapped value:</p><pre><code class="nohighlight hljs">syntaxstring(a::Atom; kwargs...) = syntaxstring(value(a); kwargs...)</code></pre><p>The <code>syntaxstring</code> for any value defaults to its <code>string</code> representation, but it can be defined by defining the appropriate <code>syntaxstring</code> method.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>syntaxstring</code> for syntax tokens (e.g., atoms, operators) should not be prefixed/suffixed by whitespaces, as this may cause ambiguities upon <em>parsing</em>. For similar reasons, <code>syntaxstring</code>s should not contain parentheses (<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>), and, when parsing in function notation, commas (<code>&#39;,&#39;</code>).</p></div></div><p>See also <a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>, <a href="#SoleLogics.Operator"><code>Operator</code></a>, <a href="../more-on-formulas/#SoleLogics.parseformula"><code>parseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L37-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Connective" href="#SoleLogics.Connective"><code>SoleLogics.Connective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Connective &lt;: Syntactical end</code></pre><p>Abstract type for <a href="https://en.wikipedia.org/wiki/Logical_connective">logical connectives</a>, that are used to express non-atomic statements; for example, CONJUNCTION, DISJUNCTION, NEGATION and IMPLICATION (stylized as ∧, ∨, ¬ and →).</p><p><strong>Interface</strong></p><ul><li><code>arity(::Connective)::Int</code></li><li><code>iscommutative(::Connective)::Bool</code></li><li><code>precedence(::Connective)::Int</code></li><li><code>associativity(::Connective)::Symbol</code></li><li><code>collatetruth(::Connective, ::NTuple{N,Truth})::Truth</code></li><li><code>simplify(::Connective, ::NTuple{N,SyntaxTree})::SyntaxTree</code></li><li><code>dual(s::Connective)::Connective</code></li><li><code>hasdual(s::Connective)::Bool</code></li><li>See also <a href="#SoleLogics.Syntactical"><code>Syntactical</code></a></li></ul><p><strong>Implementation</strong></p><p>When implementing a new type <code>C</code> for a connective, please define its <code>arity</code>. For example, with a binary operator (e.g., ∨ or ∧):</p><pre><code class="nohighlight hljs">arity(::C) = 2</code></pre><p>When implementing a new type <code>C</code> for a <em>commutative</em> connective with arity higher than 1, please provide a method <code>iscommutative(::C)</code>. This can speed up model checking operations.</p><p>When implementing a custom binary connective, one can override the default <code>precedence</code> and <code>associativity</code> (see <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity">here</a>. If the custom connective is a <code>NamedConnective</code> and renders as something considered as a <code>math symbol</code> (for example, <code>⊙</code>, see https://stackoverflow.com/a/60321302/5646732), by the Julia parser, <code>Base.operator_precedence</code> and <code>Base.operator_associativity</code> are used to define these behaviors, and you might want to avoid providing these methods at all.</p><p>The semantics of a <em>propositional</em> connective can be specified via <code>collatetruth</code> (see example below); in principle, the definition can rely on the partial order between truth values (specified via <code>precedes</code>).</p><p>Here is an example of a custom implementation of the xor (⊻) Boolean operator.</p><pre><code class="language-julia hljs">import SoleLogics: arity, iscommutative, collatetruth
const ⊻ = SoleLogics.NamedConnective{:⊻}()
SoleLogics.arity(::typeof(⊻)) = 2
SoleLogics.iscommutative(::typeof(⊻)) = true
SoleLogics.collatetruth(::typeof(⊻), (t1, t2)::NTuple{N,T where T&lt;:BooleanTruth}) where {N} = (count(istop, (t1, t2)) == 1)</code></pre><p>Note that <code>collatetruth</code> must be defined at least for some truth value types <code>T</code> via methods accepting an <code>NTuple{arity,T}</code> as a second argument.</p><p>To make the operator work with incomplete interpretations (e.g., when the <code>Truth</code> value for an atom is not known), simplification rules for <code>NTuple{arity,T where T&lt;:Formula}</code>s should be provided via methods for <code>simplify</code>. For example, these rules suffice for simplifying xors between <code>TOP/</code>BOT`s, and other formulas:</p><pre><code class="language-julia hljs">import SoleLogics: simplify
simplify(::typeof(⊻), (t1, t2)::Tuple{BooleanTruth,BooleanTruth}) = istop(t1) == istop(t2) ? BOT : TOP
simplify(::typeof(⊻), (t1, t2)::Tuple{BooleanTruth,Formula}) = istop(t1) ? ¬t2 : t2
simplify(::typeof(⊻), (t1, t2)::Tuple{Formula,BooleanTruth}) = istop(t2) ? ¬t1 : t1</code></pre><p>Beware of dispatch ambiguities!</p><p>See also <a href="#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>, <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="@ref"><code>associativity</code></a>, <a href="@ref"><code>precedence</code></a>, <a href="#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>check</code></a>, <a href="@ref"><code>iscommutative</code></a>, <a href="../base-logic/#SoleLogics.NamedConnective"><code>NamedConnective</code></a>, <a href="#SoleLogics.Syntactical"><code>Syntactical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L51-L120">source</a></section></article><p>If the definition above overwhelms you, don&#39;t worry: it will be clearer later. For now we are simply interested in understanding that <a href="#SoleLogics.Connective"><code>Connective</code></a>s are simply symbols used to concatenate other logical constructs with each other. </p><p>Later, we will see some interesting example about how to equip these symbols with semantics, that is, what rules should be applied when interpreting connectives in a generic <a href="#SoleLogics.Formula"><code>Formula</code></a>. We will also understand how to define our own custom connectives.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.arity-Tuple{Connective}" href="#SoleLogics.arity-Tuple{Connective}"><code>SoleLogics.arity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arity(φ::SyntaxTree)::Integer
arity(tok::Connective)::Integer</code></pre><p>Return the <code>arity</code> of a <code>Connective</code> or a <code>SyntaxTree</code>. The <code>arity</code> is an integer representing the number of allowed children for a node in a tree. <code>Connective</code>s with <code>arity</code> equal to 0, 1 or 2 are called <code>nullary</code>, <code>unary</code> and <code>binary</code>, respectively. <code>SyntaxLeaf</code>s (<code>Atom</code>s and <code>Truth</code> values) are always nullary.</p><p>See also <a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>, <a href="#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L123-L133">source</a></section></article><p>The vast majority of data structures involved in encoding a logical formula, are children of the <a href="#SoleLogics.Formula"><code>Formula</code></a> abstract type. When such data structures purely represents tree-shaped data structures (or single nodes in them), then they are also children of the <a href="#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a> abstract type.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Formula" href="#SoleLogics.Formula"><code>SoleLogics.Formula</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Formula &lt;: Syntactical end</code></pre><p>Abstract type for logical formulas. Examples of <code>Formula</code>s are <code>SyntaxLeaf</code>s (for example, <code>Atom</code>s and <code>Truth</code> values), <code>SyntaxStructure</code>s (for example, <code>SyntaxTree</code>s and <code>LeftmostLinearForm</code>s) and <code>TruthTable</code>s ( enriched representation, which associates a syntactic structure with additional <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> structures, which can save computational time upon <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>).</p><p>Any formula can be converted into its <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a> representation via <a href="#SoleLogics.tree-Tuple{Formula}"><code>tree</code></a>; its <a href="#SoleLogics.height-Tuple{Formula}"><code>height</code></a> can be computed, and it can be queried for its syntax <a href="#SoleLogics.tokens-Tuple{Formula}"><code>tokens</code></a>, <a href="../base-logic/#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><code>atoms</code></a>, etc... It can be parsed from its <a href="#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a> representation via <a href="../more-on-formulas/#SoleLogics.parseformula"><code>parseformula</code></a>.</p><p><strong>Interface</strong></p><ul><li><code>tree(φ::Formula)::SyntaxTree</code></li><li><code>composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F&lt;:Formula}</code></li><li>See also <a href="#SoleLogics.Syntactical"><code>Syntactical</code></a></li></ul><p><strong>Utility functions (requiring a walk of the tree)</strong></p><ul><li><p><code>Base.in(tok::SyntaxToken, φ::Formula)::Bool</code></p></li><li><p><code>height(φ::Formula)::Int</code></p></li><li><p><code>tokens(φ::Formula)::AbstractVector{&lt;:SyntaxToken}</code></p></li><li><p><code>atoms(φ::Formula)::AbstractVector{&lt;:AbstractAtom}</code></p></li><li><p><code>truths(φ::Formula)::AbstractVector{&lt;:Truth}</code></p></li><li><p><code>leaves(φ::Formula)::AbstractVector{&lt;:SyntaxLeaf}</code></p></li><li><p><code>connectives(φ::Formula)::AbstractVector{&lt;:Connective}</code></p></li><li><p><code>operators(φ::Formula)::AbstractVector{&lt;:Operator}</code></p></li><li><p><code>ntokens(φ::Formula)::Int</code></p></li><li><p><code>natoms(φ::Formula)::Int</code></p></li><li><p><code>ntruths(φ::Formula)::Int</code></p></li><li><p><code>nleaves(φ::Formula)::Int</code></p></li><li><p><code>nconnectives(φ::Formula)::Int</code></p></li><li><p><code>noperators(φ::Formula)::Int</code></p></li></ul><p>See also <a href="#SoleLogics.tree-Tuple{Formula}"><code>tree</code></a>, <a href="#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L151-L191">source</a></section></article><p>The following methods define <a href="#SoleLogics.Formula"><code>Formula</code></a> interface.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.tree-Tuple{Formula}" href="#SoleLogics.tree-Tuple{Formula}"><code>SoleLogics.tree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tree(φ::Formula)::SyntaxTree</code></pre><p>Return the <code>SyntaxTree</code> representation of a formula; note that this is equivalent to <code>Base.convert(SyntaxTree, φ)</code>.</p><p>See also <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L194-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.height-Tuple{Formula}" href="#SoleLogics.height-Tuple{Formula}"><code>SoleLogics.height</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">height(φ::Formula)::Int</code></pre><p>Return the height of a formula, in its syntax tree representation.</p><p>See also <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.tokens-Tuple{Formula}" href="#SoleLogics.tokens-Tuple{Formula}"><code>SoleLogics.tokens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tokens(φ::Formula)::AbstractVector{&lt;:SyntaxToken}
atoms(φ::Formula)::AbstractVector{&lt;:Atom}
truths(φ::Formula)::AbstractVector{&lt;:Truth}
leaves(φ::Formula)::AbstractVector{&lt;:SyntaxLeaf}
connectives(φ::Formula)::AbstractVector{&lt;:Connective}
operators(φ::Formula)::AbstractVector{&lt;:Operator}
ntokens(φ::Formula)::Integer
natoms(φ::Formula)::Integer
ntruths(φ::Formula)::Integer
nleaves(φ::Formula)::Integer
nconnectives(φ::Formula)::Integer
noperators(φ::Formula)::Integer</code></pre><p>Return the list/number of (non-unique) <code>SyntaxToken</code>s, <code>Atom</code>s, etc... appearing in a formula.</p><p>See also <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L222-L240">source</a></section></article><p>Now, let us see how to <em>compose</em> syntax elements, to express more complex concepts.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.composeformulas-Union{Tuple{F}, Tuple{N}, Tuple{Connective, NTuple{N, F}}} where {N, F&lt;:Formula}" href="#SoleLogics.composeformulas-Union{Tuple{F}, Tuple{N}, Tuple{Connective, NTuple{N, F}}} where {N, F&lt;:Formula}"><code>SoleLogics.composeformulas</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">composeformulas(c::Connective, φs::NTuple{N,F})::F where {N,F&lt;:Formula}</code></pre><p>Return a new formula of type <code>F</code> by composing <code>N</code> formulas of the same type via a connective <code>c</code>. This function allows one to use connectives for flexibly composing formulas (see <em>Implementation</em> section).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;◊(p→q)&quot;);

julia&gt; p = Atom(&quot;p&quot;);

julia&gt; ∧(f, p)  # Easy way to compose a formula
SyntaxBranch: ◊(p → q) ∧ p

julia&gt; f ∧ ¬p   # Leverage infix notation ;) (see https://stackoverflow.com/a/60321302/5646732)
SyntaxBranch: ◊(p → q) ∧ ¬p

julia&gt; ∧(f, p, ¬p) # Shortcut for ∧(f, ∧(p, ¬p))
SyntaxBranch: ◊(p → q) ∧ p ∧ ¬p</code></pre><p><strong>Implementation</strong></p><p>Upon <code>composeformulas</code> lies a flexible way of using connectives for composing formulas and syntax tokens (e.g., atoms), given by methods like the following:</p><pre><code class="nohighlight hljs">function (c::Connective)(φs::NTuple{N,Formula}) where {N}
    ...
end</code></pre><p>These allow composing formulas as in <code>∧(f, ¬p)</code>, and in order to access this composition with any newly defined subtype of <code>Formula</code>, a new method for <code>composeformulas</code> should be defined, together with promotion from/to other <code>Formula</code>s should be taken care of (see <a href="https://docs.julialang.org/en/v1/manual/conversion-and-promotion/">here</a> and <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">here</a>).</p><p>Similarly, for allowing a (possibly newly defined) connective to be applied on a number of syntax tokens/formulas that differs from its arity, for any newly defined connective <code>c</code>, new methods similar to the two above should be defined. For example, although ∧ and ∨ are binary, (i.e., have arity equal to 2), compositions such as <code>∧(f, f2, f3, ...)</code> and <code>∨(f, f2, f3, ...)</code> can be done thanks to the following two methods that were defined in SoleLogics:</p><pre><code class="nohighlight hljs">function ∧(
    c1::Formula,
    c2::Formula,
    c3::Formula,
    cs::Formula...
)
    return ∧(c1, ∧(c2, c3, cs...))
end
function ∨(
    c1::Formula,
    c2::Formula,
    c3::Formula,
    cs::Formula...
)
    return ∨(c1, ∨(c2, c3, cs...))
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To allow for the composition of <code>Formula</code>s of different types, promotion rules should be provided.</p></div></div><p>See also <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L199-L269">source</a></section></article><p>We are ready to see how logical formulas are represented using syntax trees</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.SyntaxStructure" href="#SoleLogics.SyntaxStructure"><code>SoleLogics.SyntaxStructure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SyntaxStructure &lt;: Formula end</code></pre><p>Abstract type for the purely-syntactic component of a logical formula (e.g., no fancy memoization structure associated). The typical representation is the <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, however, different implementations can cover specific syntactic forms (e.g., <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive</a> or <a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">disjunctive</a> normal forms).</p><p><strong>Interface</strong></p><ul><li>See also <a href="#SoleLogics.Formula"><code>Formula</code></a></li></ul><p>See also <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="../base-logic/#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>, <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.tree-Tuple{Formula}"><code>tree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L288-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.SyntaxTree" href="#SoleLogics.SyntaxTree"><code>SoleLogics.SyntaxTree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SyntaxTree &lt;: SyntaxStructure end</code></pre><p>Abstract type for <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">syntax trees</a>; that is, syntax leaves (see <code>SyntaxLeaf</code>, such as <code>Truth</code> values and <code>Atom</code>s), and their composition via <code>Connective</code>s (i.e., <code>SyntaxBranch</code>).</p><p>Note that <code>SyntaxTree</code> are <em>ranked trees</em>, and (should) implement <code>AbstractTrees</code> interface.</p><p><strong>Interface</strong></p><ul><li><code>children(φ::SyntaxTree)::NTuple{N,SyntaxTree} where N</code></li><li><code>token(φ::SyntaxTree)::Connective</code></li><li>See also <a href="#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a></li></ul><p><strong>Utility functions</strong></p><ul><li><code>tokentype(φ::SyntaxTree)</code></li><li><code>arity(φ::SyntaxTree)::Int</code></li></ul><p><strong>Other utility functions (requiring a walk of the tree)</strong></p><ul><li><code>Base.in(tok::SyntaxToken, φ::SyntaxTree)::Bool</code></li><li><code>height(φ::SyntaxTree)::Int</code></li><li><code>tokens(φ::SyntaxTree)::AbstractVector{&lt;:SyntaxToken}</code></li><li><code>atoms(φ::SyntaxTree)::AbstractVector{&lt;:AbstractAtom}</code></li><li><code>truths(φ::SyntaxTree)::AbstractVector{&lt;:Truth}</code></li><li><code>leaves(φ::SyntaxTree)::AbstractVector{&lt;:SyntaxLeaf}</code></li><li><code>connectives(φ::SyntaxTree)::AbstractVector{&lt;:Connective}</code></li><li><code>operators(φ::SyntaxTree)::AbstractVector{&lt;:Operator}</code></li><li><code>ntokens(φ::SyntaxTree)::Int</code></li><li><code>natoms(φ::SyntaxTree)::Int</code></li><li><code>ntruths(φ::SyntaxTree)::Int</code></li><li><code>nleaves(φ::SyntaxTree)::Int</code></li><li><code>nconnectives(φ::SyntaxTree)::Int</code></li><li><code>noperators(φ::SyntaxTree)::Int</code></li><li><code>tokenstype(φ::SyntaxTree)</code></li><li><code>atomstype(φ::SyntaxTree)</code></li><li><code>truthstype(φ::SyntaxTree)</code></li><li><code>leavestype(φ::SyntaxTree)</code></li><li><code>connectivestype(φ::SyntaxTree)</code></li><li><code>operatorstype(φ::SyntaxTree)</code></li><li><code>composeformulas(c::Connective, φs::NTuple{N,SyntaxTree})</code></li></ul><p>See also <a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>, <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>, <a href="#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L315-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractTrees.children-Tuple{SyntaxTree}" href="#AbstractTrees.children-Tuple{SyntaxTree}"><code>AbstractTrees.children</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">children(φ::SyntaxTree)</code></pre><p>Return the immediate children of a syntax tree.</p><p>See also <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L365-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.token-Tuple{SyntaxTree}" href="#SoleLogics.token-Tuple{SyntaxTree}"><code>SoleLogics.token</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">token(φ::SyntaxTree)::SyntaxToken</code></pre><p>Return the token at the root of a syntax tree.</p><p>See also <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L370-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.SyntaxLeaf" href="#SoleLogics.SyntaxLeaf"><code>SoleLogics.SyntaxLeaf</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SyntaxLeaf &lt;: SyntaxStructure end</code></pre><p>An atomic logical element, like a <code>Truth</code> value or an <code>Atom</code>. <code>SyntaxLeaf</code>s have <code>arity</code> equal to zero, meaning that they are not allowed to have children in tree-like syntactic structures.</p><p><strong>Interface</strong></p><ul><li><code>syntaxstring(s::SyntaxLeaf; kwargs...)::String</code></li><li><code>dual(s::SyntaxLeaf)::SyntaxLeaf</code></li><li><code>hasdual(s::SyntaxLeaf)::Bool</code></li></ul><p>See also <a href="#SoleLogics.SyntaxStructure"><code>SyntaxStructure</code></a>,  <a href="#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>, <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L486-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.SyntaxToken" href="#SoleLogics.SyntaxToken"><code>SoleLogics.SyntaxToken</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const SyntaxToken = Union{Connective,SyntaxLeaf}</code></pre><p>Union type for values wrapped in <code>SyntaxTree</code> nodes.</p><p>See also <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.SyntaxLeaf"><code>SyntaxLeaf</code></a>, <a href="#SoleLogics.Connective"><code>Connective</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L509-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.dual-Tuple{SyntaxToken}" href="#SoleLogics.dual-Tuple{SyntaxToken}"><code>SoleLogics.dual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dual(tok::SyntaxToken)</code></pre><p>Return the <code>dual</code> of a syntax token.</p><p>If <code>tok</code> is an <code>Operator</code> of arity <code>n</code>, the dual <code>dtok</code> is such that, on a Boolean algebra, <code>tok(ch_1, ..., ch_n)</code> ≡ <code>¬dtok(¬ch_1, ..., ¬ch_n)</code>.</p><p>Duality can be used to perform syntactic simplifications on formulas. For example, since <code>∧</code> and <code>∨</code> are <code>dual</code>s, <code>¬(¬p ∧ ¬q)</code> can be simplified to <code>(p ∧ q)</code> (De Morgan&#39;s law). Duality also applies to operators with existential/universal semantics (<code>◊</code>/<code>□</code>), to <code>Truth</code> values (<code>⊤</code>/<code>⊥</code>), and to <code>Atom</code>s.</p><p><strong>Implementation</strong></p><p>When providing a <code>dual</code> for an operator of type <code>O</code>, please also provide:</p><pre><code class="nohighlight hljs">hasdual(::O) = true</code></pre><p>The dual of an <code>Atom</code> (that is, the atom with inverted semantics) is defined as:</p><pre><code class="nohighlight hljs">dual(p::Atom{V}) where {V} = Atom(dual(value(p)))</code></pre><p>As such, <code>hasdual(::V)</code> and <code>dual(::V)</code> should be defined when wrapping objects of type <code>A</code>.</p><p>See also <a href="../more-on-formulas/#SoleLogics.normalize-Tuple{Formula}"><code>normalize</code></a>, <a href="#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L518-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in-Tuple{SyntaxToken, SyntaxTree}" href="#Base.in-Tuple{SyntaxToken, SyntaxTree}"><code>Base.in</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.in(tok::SyntaxToken, φ::Formula)::Bool</code></pre><p>Return whether a syntax token appears in a formula.</p><p>See also <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L702-L708">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Atom" href="#SoleLogics.Atom"><code>SoleLogics.Atom</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Atom{V} &lt;: AbstractAtom
    value::V
end</code></pre><p>Simplest atom implementation, wrapping a <code>value</code>.</p><p>See also <a href="@ref"><code>AbstractAtom</code></a>, <a href="@ref"><code>value</code></a>, <a href="#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>check</code></a>, <a href="#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/utils/syntactical.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Truth" href="#SoleLogics.Truth"><code>SoleLogics.Truth</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Truth &lt;: SyntaxLeaf end</code></pre><p>Abstract type for syntax leaves representing values of a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice algebra</a>. In Boolean logic, the two <a href="../base-logic/#SoleLogics.BooleanTruth"><code>BooleanTruth</code></a> values TOP (⊤) and BOT (⊥) are used.</p><p>See also <a href="../base-logic/#SoleLogics.BooleanTruth"><code>BooleanTruth</code></a>.</p><p><strong>Interface</strong></p><ul><li><code>syntaxstring(s::Truth; kwargs...)::String</code></li><li><code>dual(s::Truth)::Truth</code></li><li><code>hasdual(s::Truth)::Bool</code></li><li><code>istop(t::Truth)::Bool</code></li><li><code>isbot(t::Truth)::Bool</code></li><li><code>precedes(t1::Truth, t2::Truth)::Bool</code></li><li><code>truthmeet(t1::Truth, t2::Truth)::Truth</code></li><li><code>truthjoin(t1::Truth, t2::Truth)::Truth</code></li></ul><p><strong>Implementation</strong></p><p>A <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued algebra</a>, that is, an algebra with three truth values (top, bottom and <em>unknown</em>), can be based on the following <code>Truth</code> value definitions:</p><pre><code class="language-julia hljs">import SoleLogics: precedes

abstract type ThreeVTruth &lt;: Truth end

struct ThreeTop &lt;: ThreeVTruth end
const ⫪ = ThreeTop() # Note that ⊤ is already use to indicate BooleanTruth&#39;s top.
syntaxstring(::ThreeTop; kwargs...) = &quot;⫪&quot;

struct ThreeBot &lt;: ThreeVTruth end
const ⫫ = ThreeBot() # Note that ⊥ is already use to indicate BooleanTruth&#39;s top.
syntaxstring(::ThreeBot; kwargs...) = &quot;⫫&quot;

struct ThreeUnknown &lt;: ThreeVTruth end
const υ = ThreeUnknown()
syntaxstring(::ThreeUnknown; kwargs...) = &quot;υ&quot;

istop(t::ThreeTop) = true
isbot(t::ThreeBot) = true

precedes(::ThreeBot, ::ThreeTop) = true
precedes(::ThreeBot, ::ThreeUnknown) = true
precedes(::ThreeUnknown, ::ThreeTop) = true
precedes(::ThreeTop, ::ThreeBot) = false
precedes(::ThreeUnknown, ::ThreeBot) = false
precedes(::ThreeTop, ::ThreeUnknown) = false</code></pre><p>Note that <code>precedes</code> is used to define the (partial) order between <code>Truth</code> values.</p><p>See also <a href="#SoleLogics.Connective"><code>Connective</code></a>, <a href="../base-logic/#SoleLogics.BooleanTruth"><code>BooleanTruth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L719-L775">source</a></section></article><p>Similarly to the <a href="#SoleLogics.Connective"><code>Connective</code></a>s case, <a href="#SoleLogics.Truth"><code>Truth</code></a> explanation could be unfamiliar at first sight. At the moment, what is of our interest is that SoleLogics provides us a simple interface to create custom, complex at will, algebras without worrying about adapting all the underlying algorithms (e.g., formulas generation, parsing, model checking etc.).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.istop-Tuple{Truth}" href="#SoleLogics.istop-Tuple{Truth}"><code>SoleLogics.istop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istop(::Truth)::Bool</code></pre><p>Return true if the <code>Truth</code> value is the top of its algebra. For example, in the crisp case, with <code>Bool</code> truth values, it is:</p><pre><code class="nohighlight hljs">istop(t::Bool)::Bool = (t == true)</code></pre><p>See also <a href="#SoleLogics.isbot-Tuple{Truth}"><code>isbot</code></a>, <a href="#SoleLogics.Truth"><code>Truth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L778-L787">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.isbot-Tuple{Truth}" href="#SoleLogics.isbot-Tuple{Truth}"><code>SoleLogics.isbot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isbot(::Truth)::Bool</code></pre><p>Return true if the <code>Truth</code> value is the bottom of its algebra. For example, in the crisp case, with <code>Bool</code> truth values, it is:</p><pre><code class="nohighlight hljs">isbot(t::Bool)::Bool = (t == false)</code></pre><p>See also <a href="#SoleLogics.istop-Tuple{Truth}"><code>istop</code></a>, <a href="#SoleLogics.Truth"><code>Truth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L790-L799">source</a></section></article><p>The union of <a href="#SoleLogics.Connective"><code>Connective</code></a>s and <a href="#SoleLogics.Truth"><code>Truth</code></a> values are exactly what is called <em>logical operators</em>, or simply <a href="#SoleLogics.Operator"><code>Operator</code></a>. In SoleLogics, logical operators are splitted in two parts to highlight some differences that always holds (e.g., <a href="#SoleLogics.Truth"><code>Truth</code></a> values arity is always 0, while <a href="#SoleLogics.Connective"><code>Connective</code></a>s arity is always greater than 0); apart from this technical decision, many dispatches are defined using the more general union type <a href="#SoleLogics.Operator"><code>Operator</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.Operator" href="#SoleLogics.Operator"><code>SoleLogics.Operator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const Operator = Union{Connective,Truth}</code></pre><p>Union type for logical constants of any ariety (zero for <code>Truth</code> values, non-zero for <code>Connective</code>s).</p><p>See also <a href="#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.Truth"><code>Truth</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/syntactical.jl#L865-L872">source</a></section></article><p>An <a href="#SoleLogics.Operator"><code>Operator</code></a> can be used to compose syntax tokens (e.g., <a href="#SoleLogics.Atom"><code>Atom</code></a>s), <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>s and/or <a href="#SoleLogics.Formula"><code>Formula</code></a>s.</p><pre><code class="language-julia-repl hljs">    ¬(Atom(1)) ∨ Atom(1) ∧ ⊤
    ∧(⊤,⊤)
    ⊤()</code></pre><p>The internal nodes in a <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a> definitely have <a href="@ref"><code>ariety</code></a> greater than <code>0</code>, and thus, cannot wrap <a href="#SoleLogics.Atom"><code>Atom</code></a>s nor <a href="#SoleLogics.Truth"><code>Truth</code></a> values. To clearly distinguish internal nodes and leaves, the <a href="#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a> type is defined, making each <a href="#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a> arity-complaint.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.SyntaxBranch" href="#SoleLogics.SyntaxBranch"><code>SoleLogics.SyntaxBranch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SyntaxBranch &lt;: AbstractSyntaxBranch
    token::Connective
    children::NTuple{N,SyntaxTree} where {N}
end</code></pre><p>Simple implementation of a syntax branch. The implementation is <em>arity-compliant</em>, in that, upon construction, the arity of the token is checked against the number of children provided.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p,q = Atom.([p, q])
2-element Vector{Atom{String}}:
 Atom{String}: p
 Atom{String}: q

julia&gt; branch = SyntaxBranch(CONJUNCTION, p, q)
SyntaxBranch: p ∧ q

julia&gt; token(branch)
∧

julia&gt; syntaxstring.(children(branch))
(p, q)

julia&gt; ntokens(a) == nconnectives(a) + nleaves(a)
true

julia&gt; arity(a)
2

julia&gt; height(a)
1</code></pre><p>See also <a href="#SoleLogics.token-Tuple{SyntaxTree}"><code>token</code></a>, <a href="#AbstractTrees.children-Tuple{SyntaxTree}"><code>children</code></a>, <a href="#SoleLogics.arity-Tuple{Connective}"><code>arity</code></a>, <a href="#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.height-Tuple{Formula}"><code>height</code></a>, <a href="../base-logic/#SoleLogics.atoms-Tuple{SoleLogics.AbstractAlphabet}"><code>atoms</code></a>, <a href="../base-logic/#SoleLogics.natoms-Tuple{SoleLogics.AbstractAlphabet}"><code>natoms</code></a>, <a href="@ref"><code>operators</code></a>, <a href="@ref"><code>noperators</code></a>, <a href="#SoleLogics.tokens-Tuple{Formula}"><code>tokens</code></a>, <a href="@ref"><code>ntokens</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/utils/syntactical.jl#L95-L139">source</a></section></article><h2 id="semantics-base-definitions"><a class="docs-heading-anchor" href="#semantics-base-definitions">Semantics Basics</a><a id="semantics-base-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#semantics-base-definitions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AbstractInterpretation" href="#SoleLogics.AbstractInterpretation"><code>SoleLogics.AbstractInterpretation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractInterpretation end</code></pre><p>Abstract type for representing a <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">logical interpretation</a>. In the case of <a href="https://simple.wikipedia.org/wiki/Propositional_logic">propositional logic</a>, is essentially a map <em>atom → truth value</em>.</p><p>Properties expressed via logical formulas can be <code>check</code>ed on logical interpretations.</p><p><strong>Interface</strong></p><ul><li><code>valuetype(i::AbstractInterpretation)</code></li><li><code>truthtype(i::AbstractInterpretation)</code></li><li><code>interpret(φ::Formula, i::AbstractInterpretation, args...; kwargs...)::Formula</code></li></ul><p><strong>Utility functions</strong></p><ul><li><code>check(φ::Formula, i::AbstractInterpretation, args...; kwargs...)::Bool</code></li></ul><p>See also <a href="#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>check</code></a>, <a href="../base-logic/#SoleLogics.AbstractAssignment"><code>AbstractAssignment</code></a>, <a href="../modal-logic/#SoleLogics.AbstractKripkeStructure"><code>AbstractKripkeStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/interpretation.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}" href="#SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>SoleLogics.interpret</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpret(
    φ::Formula,
    i::AbstractInterpretation,
    args...;
    kwargs...
)::Formula</code></pre><p>Return the truth value for a formula on a logical interpretation (or model).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @atoms p q
2-element Vector{Atom{String}}:
 p
 q

julia&gt; td = TruthDict([p =&gt; true, q =&gt; false])
TruthDict with values:
┌────────┬────────┐
│      q │      p │
│ String │ String │
├────────┼────────┤
│      ⊥ │      ⊤ │
└────────┴────────┘

julia&gt; interpret(CONJUNCTION(p,q), td)
⊥</code></pre><p>See also <a href="#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>check</code></a>, <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>, <a href="../base-logic/#SoleLogics.AbstractAlgebra"><code>AbstractAlgebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/interpretation.jl#L40-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}" href="#SoleLogics.check-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>SoleLogics.check</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check(
    φ::Formula,
    i::AbstractInterpretation,
    args...;
    kwargs...
)::Bool</code></pre><p>Check a formula on a logical interpretation (or model), returning <code>true</code> if the truth value for the formula <code>istop</code>. This process is referred to as (finite) <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>, and there are many algorithms for it, typically depending on the complexity of the logic.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @atoms String p q
2-element Vector{Atom{String}}:
 Atom{String}(&quot;p&quot;)
 Atom{String}(&quot;q&quot;)

julia&gt; td = TruthDict([p =&gt; TOP, q =&gt; BOT])
TruthDict with values:
┌────────┬────────┐
│      q │      p │
│ String │ String │
├────────┼────────┤
│      ⊥ │      ⊤ │
└────────┴────────┘

julia&gt; check(CONJUNCTION(p,q), td)
false</code></pre><p>See also <a href="#SoleLogics.interpret-Tuple{Formula, SoleLogics.AbstractInterpretation, Vararg{Any}}"><code>interpret</code></a>, <a href="#SoleLogics.Formula"><code>Formula</code></a>, <a href="#SoleLogics.AbstractInterpretation"><code>AbstractInterpretation</code></a>, <a href="../base-logic/#SoleLogics.TruthDict"><code>TruthDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/e65107b6bda124ab451aea1a3ce00b82f1b6e974/src/types/interpretation.jl#L110-L146">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../base-logic/">Introduction to Logics and Propositional Logic »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 29 October 2024 11:22">Tuesday 29 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
