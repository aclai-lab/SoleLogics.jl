<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More on Formulas · SoleLogics.jl</title><meta name="title" content="More on Formulas · SoleLogics.jl"/><meta property="og:title" content="More on Formulas · SoleLogics.jl"/><meta property="twitter:title" content="More on Formulas · SoleLogics.jl"/><meta name="description" content="Documentation for SoleLogics.jl."/><meta property="og:description" content="Documentation for SoleLogics.jl."/><meta property="twitter:description" content="Documentation for SoleLogics.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleLogics.jl/more-on-formulas/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SoleLogics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleLogics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li><a class="tocitem" href="../base-logic/">Introduction to Logics and Propositional Logic</a></li><li><a class="tocitem" href="../modal-logic/">Modal Logic</a></li><li class="is-active"><a class="tocitem" href>More on Formulas</a><ul class="internal"><li><a class="tocitem" href="#Linear-Forms"><span>Linear Forms</span></a></li><li><a class="tocitem" href="#Random-sampling-and-generation"><span>Random sampling and generation</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../hands-on/">Hands On</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>More on Formulas</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More on Formulas</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleLogics.jl/blob/main/docs/src/more-on-formulas.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#more-on-formulas-section">More on Formulas</a></li><li class="no-marker"><ul><li><a href="#Linear-Forms">Linear Forms</a></li><li><a href="#Random-sampling-and-generation">Random sampling and generation</a></li><li><a href="#Parsing">Parsing</a></li><li><a href="#Utilities">Utilities</a></li></ul></li></ul><h1 id="more-on-formulas-section"><a class="docs-heading-anchor" href="#more-on-formulas-section">More on Formulas</a><a id="more-on-formulas-section-1"></a><a class="docs-heading-anchor-permalink" href="#more-on-formulas-section" title="Permalink"></a></h1><p>In this chapter, you are going to learn more about <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a> representations that are alternative to syntax trees. As you will see, for example, formulas with specific structure (e.g., <a href="https://en.wikipedia.org/wiki/Canonical_normal_form">normal forms</a>) can be represented in ways that make them more easy to handle, and can lead to great benefits in terms of both computational and memory load.</p><p>We proceed by presenting the random formulae generation engine, parsing and some utility function.</p><p>Recalling the type hierarchy presented in <a href="../getting-started/#man-core">man-core</a>, it is here enriched with the following new types and structures.</p><ul><li><a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a><ul><li><a href="#SoleLogics.AnchoredFormula"><code>AnchoredFormula</code></a> <strong>(new)</strong></li><li><a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a><ul><li><a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm{C&lt;:Connective,SS&lt;:AbstractSyntaxStructure}</code></a> <strong>(new)</strong></li></ul></li></ul></li></ul><hr/><h2 id="Linear-Forms"><a class="docs-heading-anchor" href="#Linear-Forms">Linear Forms</a><a id="Linear-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Forms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.LeftmostLinearForm" href="#SoleLogics.LeftmostLinearForm"><code>SoleLogics.LeftmostLinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LeftmostLinearForm{C&lt;:Connective,SS&lt;:AbstractSyntaxStructure} &lt;: AbstractSyntaxStructure
    children::Vector{&lt;:SS}
end</code></pre><p>A syntax structure representing the <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)"><code>foldl</code></a> of a set of other syntax structure of type <code>SS</code> by means of a connective <code>C</code>. This structure enables a structured instantiation of formulas in conjuctive/disjunctive forms, and conjuctive normal form (CNF) or disjunctive normal form (DNF), defined as:</p><pre><code class="nohighlight hljs">const LeftmostConjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}
const LeftmostDisjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}

const CNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),LeftmostLinearForm{typeof(∨),SS}}
const DNF{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),LeftmostLinearForm{typeof(∧),SS}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LeftmostLinearForm(→, parseformula.([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;]))
LeftmostLinearForm{SoleLogics.NamedConnective{:→},Atom{String}}
    &quot;(p) → (q) → (r)&quot;

julia&gt; LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))
LeftmostLinearForm{SoleLogics.NamedConnective{:∧},SyntaxTree}
    &quot;(¬p) ∧ (q) ∧ (¬r)&quot;

julia&gt; LeftmostDisjunctiveForm{Literal}([Literal(false, Atom(&quot;p&quot;)), Literal(true, Atom(&quot;q&quot;)), Literal(false, Atom(&quot;r&quot;))])
LeftmostLinearForm{SoleLogics.NamedConnective{:∨},Literal}
    &quot;(¬p) ∨ (q) ∨ (¬r)&quot;

julia&gt; LeftmostDisjunctiveForm([LeftmostConjunctiveForm(parseformula.([&quot;¬p&quot;, &quot;q&quot;, &quot;¬r&quot;]))]) isa SoleLogics.DNF
true
</code></pre><p>See also <a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="../getting-started/#SoleLogics.Literal"><code>Literal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L40-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.LeftmostConjunctiveForm" href="#SoleLogics.LeftmostConjunctiveForm"><code>SoleLogics.LeftmostConjunctiveForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LeftmostConjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∧),SS}</code></pre><p>Specific instantiation of a <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, where <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are all <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>s.</p><p>See also <a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L229-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.LeftmostDisjunctiveForm" href="#SoleLogics.LeftmostDisjunctiveForm"><code>SoleLogics.LeftmostDisjunctiveForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LeftmostDisjunctiveForm{SS&lt;:AbstractSyntaxStructure} = LeftmostLinearForm{typeof(∨),SS}</code></pre><p>Specific instantiation of a <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, where <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>s are all <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>s.</p><p>See also <a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="../getting-started/#SoleLogics.Connective"><code>Connective</code></a>, <a href="#SoleLogics.LeftmostLinearForm"><code>LeftmostLinearForm</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L240-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.CNF" href="#SoleLogics.CNF"><code>SoleLogics.CNF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CNF{SS&lt;:AbstractSyntaxStructure} = LeftmostConjunctiveForm{LeftmostDisjunctiveForm{SS}}</code></pre><p>Conjunctive Normal Form of an <a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p><p>See also <a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L251-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.DNF" href="#SoleLogics.DNF"><code>SoleLogics.DNF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DNF{SS&lt;:AbstractSyntaxStructure} = LeftmostConjunctiveForm{LeftmostConjunctiveForm{SS}}</code></pre><p>Disjunctive Normal Form of an <a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>.</p><p>See also <a href="../getting-started/#SoleLogics.AbstractSyntaxStructure"><code>AbstractSyntaxStructure</code></a>, <a href="#SoleLogics.LeftmostConjunctiveForm"><code>LeftmostConjunctiveForm</code></a>, <a href="#SoleLogics.LeftmostDisjunctiveForm"><code>LeftmostDisjunctiveForm</code></a>, <a href="../base-logic/#SoleLogics.CONJUNCTION"><code>CONJUNCTION</code></a>, <a href="../base-logic/#SoleLogics.DISJUNCTION"><code>DISJUNCTION</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L261-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.AnchoredFormula" href="#SoleLogics.AnchoredFormula"><code>SoleLogics.AnchoredFormula</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct AnchoredFormula{L&lt;:AbstractLogic} &lt;: Formula
    _logic::Base.RefValue{L}
    synstruct::AbstractSyntaxStructure
end</code></pre><p>A formula anchored to a logic of type <code>L</code>, and wrapping a syntax structure. The structure encodes a formula belonging to the grammar of the logic, and the truth of the formula can be evaluated on interpretations of the same logic. Note that, here, the logic is represented by a reference.</p><p>Upon construction, the logic can be passed either directly, or via a RefValue. Additionally, the following keyword arguments may be specified:</p><ul><li><code>check_atoms::Bool = false</code>: whether to perform or not a check that the atoms   belong to the alphabet of the logic;</li><li><code>check_tree::Bool = false</code>: whether to perform or not a check that the formula&#39;s   syntactic structure honors the grammar   (includes the check performed with <code>check_atoms = true</code>);</li></ul><p><em>Cool feature</em>: a <code>AnchoredFormula</code> can be used for instating other formulas of the same logic. See the examples.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; φ = parsebaseformula(&quot;◊(p→q)&quot;);

julia&gt; f2 = φ(parseformula(&quot;p&quot;));

julia&gt; syntaxstring(φ)
&quot;◊(→(p, q))&quot;

julia&gt; syntaxstring(f2)
&quot;p&quot;

julia&gt; @assert logic(φ) == logic(f2)

julia&gt; @assert ◊ in operators(logic(f2))

julia&gt; @assert ◊ isa operatorstype(logic(f2))
</code></pre><p>See also <a href="../base-logic/#SoleLogics.AbstractLogic"><code>AbstractLogic</code></a>, <a href="#SoleLogics.logic-Tuple{AnchoredFormula}"><code>logic</code></a>, <a href="../getting-started/#SoleLogics.SyntaxToken"><code>SyntaxToken</code></a>, <a href="../getting-started/#SoleLogics.SyntaxBranch"><code>SyntaxBranch</code></a>, <a href="../getting-started/#SoleLogics.tree-Tuple{Formula}"><code>tree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/anchored-formula.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.logic-Tuple{AnchoredFormula}" href="#SoleLogics.logic-Tuple{AnchoredFormula}"><code>SoleLogics.logic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logic(φ::AnchoredFormula)::AbstractLogic</code></pre><p>Return the logic of an anchored formula</p><p>See <a href="#SoleLogics.AnchoredFormula"><code>AnchoredFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/anchored-formula.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.synstruct-Tuple{AnchoredFormula}" href="#SoleLogics.synstruct-Tuple{AnchoredFormula}"><code>SoleLogics.synstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">synstruct(φ::AnchoredFormula)::AbstractSyntaxStructure</code></pre><p>Return the syntactic component of an anchored formula.</p><p>See <a href="#SoleLogics.AnchoredFormula"><code>AnchoredFormula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/anchored-formula.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.baseformula-Tuple{Formula}" href="#SoleLogics.baseformula-Tuple{Formula}"><code>SoleLogics.baseformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function baseformula(
    φ::Formula;
    infer_logic = true,
    additional_operators::Union{Nothing,Vector{&lt;:Operator}} = nothing,
    kwargs...
)</code></pre><p>Attempt at instantiating a <code>AnchoredFormula</code> from a syntax token/formula, by inferring the logic it belongs to. If <code>infer_logic</code> is true, then a canonical logic (e.g., propositional logic with all the <code>BASE_PROPOSITIONAL_CONNECTIVES</code>) is inferred; if it&#39;s false, then a logic with exactly the operators appearing in the syntax tree, plus the <code>additional_operators</code> is instantiated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = parseformula(&quot;◊((p∧q)→r)&quot;);

julia&gt; unique(operators(logic(SoleLogics.baseformula(t))))
3-element Vector{Union{SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:∧}}}:
 ∧
 ◊
 →

julia&gt; unique(operators(logic(SoleLogics.baseformula(t; additional_operators = SoleLogics.BASE_MODAL_CONNECTIVES))))
8-element Vector{Union{SoleLogics.BottomOperator, SoleLogics.NamedConnective{:¬}, SoleLogics.NamedConnective{:∧}, SoleLogics.NamedConnective{:∨}, SoleLogics.NamedConnective{:→}, SoleLogics.NamedConnective{:◊}, SoleLogics.NamedConnective{:□}, SoleLogics.TopOperator}}:
 ¬
 ∧
 ∨
 →
 ◊
 □</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/anchored-formula.jl#L166-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.parsebaseformula" href="#SoleLogics.parsebaseformula"><code>SoleLogics.parsebaseformula</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parsebaseformula(
    expr::String,
    additional_operators::Union{Nothing,Vector{&lt;:Operator}} = nothing;
    operators::Union{Nothing,Vector{&lt;:Operator}},
    grammar::Union{Nothing,AbstractGrammar} = nothing,
    algebra::Union{Nothing,AbstractAlgebra} = nothing,
    kwargs...
)::AnchoredFormula</code></pre><p>Return a <code>AnchoredFormula</code> which is the result of parsing an expression via the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a> algorithm. By default, this function is only able to parse operators in <code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code>; additional operators may be provided as a second argument.</p><p>The <code>grammar</code> and <code>algebra</code> of the associated logic is inferred using the <code>baseformula</code> function from the operators encountered in the expression, and those in <code>additional_operators</code>.</p><p>See <a href="#SoleLogics.parseformula"><code>parseformula</code></a>, <a href="#SoleLogics.baseformula-Tuple{Formula}"><code>baseformula</code></a>, <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>BASE_PARSABLE_CONNECTIVES</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/anchored-formula.jl#L242-L263">source</a></section></article><h2 id="Random-sampling-and-generation"><a class="docs-heading-anchor" href="#Random-sampling-and-generation">Random sampling and generation</a><a id="Random-sampling-and-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-sampling-and-generation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}" href="#Base.rand-Tuple{SoleLogics.AbstractAlphabet, Vararg{Any}}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.rand(
    [rng::AbstractRNG = Random.GLOBAL_RNG,]
    alphabet::AbstractAlphabet,
    args...;
    kwargs...
)::Atom

Base.rand(
    [rng::AbstractRNG = Random.GLOBAL_RNG,]
    height::Integer,
    g::CompleteFlatGrammar,
    args...
)

Base.rand(
    height::Integer,
    connectives::Union{AbstractVector{&lt;:Operator},AbstractVector{&lt;:Connective}},
    atoms::Union{AbstractVector{&lt;:Atom},AbstractAlphabet},
    truthvalues::Union{Nothing,AbstractVector{&lt;:Truth},AbstractAlgebra} = nothing,
    args...;
    rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG,
    kwargs...
)</code></pre><p>Randomly sample an atom from an <code>alphabet</code>, according to a uniform distribution.</p><p><strong>Implementation</strong></p><p>If the <code>alphabet</code> is finite, the function defaults to <code>rand(rng, atoms(alphabet))</code>; otherwise, it must be implemented, and additional keyword arguments should be provided in order to limit the (otherwise infinite) sampling domain.</p><p>See also <a href="../base-logic/#SoleLogics.AbstractAlphabet"><code>AbstractAlphabet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/random.jl#L52-L86">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>StatsBase.sample(alphabet::AbstractAlphabet, weights::AbstractWeights, args...; kwargs...)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>randformula(height::Integer, alphabet, operators::AbstractVector; rng::Union{Integer,AbstractRNG} = Random.GLOBAL_RNG)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.BASE_PARSABLE_CONNECTIVES" href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const BASE_PARSABLE_CONNECTIVES = SoleLogics.Syntactical[¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤, ⊥]</code></pre><p>Vector of (standard) operators that are automatically taken care of when parsing. These are ¬, ∧, ∨, →, ◊, □, ⟨G⟩, [G], ⟨=⟩, [=], ⊤ and ⊥.</p><p>See also <a href="#SoleLogics.parseformula"><code>parseformula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/parse.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.parseformula" href="#SoleLogics.parseformula"><code>SoleLogics.parseformula</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parseformula(expr::String, additional_operators = nothing; kwargs...)

parseformula(
    F::Type{&lt;:SyntaxTree},
    expr::String,
    additional_operators::Union{Nothing,AbstractVector} = nothing;
    function_notation::Bool = false,
    atom_parser::Base.Callable = Atom{String},
    additional_whitespaces::Vector{Char} = Char[],
    opening_parenthesis::String = DEFAULT_OPENING_PARENTHESIS,
    closing_parenthesis::String = DEFAULT_CLOSING_PARENTHESIS,
    arg_delim::String = DEFAULT_ARG_DELIM
)::F

parseformula(F::Type{&lt;:Formula}, expr::String, additional_operators = nothing; kwargs...)
parseformula(F::Type{&lt;:SyntaxTree}, expr::String, logic::AbstractLogic; kwargs...)</code></pre><p>Parse a formula of type <code>F</code> from a string expression (its <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>). When <code>F</code> is not specified, it defaults to <code>SyntaxTree</code>.</p><p>By default, this function is only able to parse operators in <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>SoleLogics.BASE_PARSABLE_CONNECTIVES</code></a> (e.g., ¬, ∧, ∨ and →); additional, non-standard operators may be provided as a vector <code>additional_operators</code>, and their <code>syntaxstring</code>s will be used for parsing them. Note that, in case of clashing <code>syntaxstring</code>s, the provided additional operators will override the standard ones.</p><p>When parsing <code>SyntaxTree</code>s, the <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting yard</a> algorithm is used, and the method allows the following keywords arguments.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>function_notation::Bool = false</code>: if set to <code>true</code>, the expression is considered   in function notation (e.g., <code>&quot;⨁(arg1, arg2)&quot;</code>);   otherwise, it is considered in   <a href="https://en.wikipedia.org/wiki/Infix_notation">infix notation</a> (e.g., <code>&quot;arg1 ⨁ arg2&quot;</code>);</li><li><code>atom_parser::Base.Callable = Atom{String}</code>: a callable to be used for   parsing atoms, once they are recognized in the expression. It must return   the atom, or the <code>Atom</code> itself;</li><li><code>additional_whitespaces::Vector{Char} = Char[]</code>: characters to be stripped out from each   syntax token.   For example, if <code>&#39;@&#39; in additional_whitespaces</code>, &quot;¬@p@&quot; is parsed just as &quot;¬p&quot;.</li><li><code>opening_parenthesis::String = &quot;(&quot;</code>:   the string signaling the opening of an expression block;</li><li><code>closing_parenthesis::String = &quot;)&quot;</code>:   the string signaling the closing of an expression block;</li><li><code>arg_delim::String = &quot;,&quot;</code>:   when <code>function_notation = true</code>,   the string that delimits the different arguments of a function call.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For a proper functioning, the <code>syntaxstring</code> of any syntax token cannot be prefixed/suffixed by whitespaces. For example, for any operator <code>⨁</code>, it should hold that <code>syntaxstring(⨁) == strip(syntaxstring(⨁))</code>. Also, <code>syntaxstring</code>s cannot contain special symbols (<code>opening_parenthesis</code>, <code>closing_parenthesis</code>, and <code>arg_delim</code>) as substrings.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring(parseformula(&quot;¬p∧q∧(¬s∧¬z)&quot;))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;∧(¬p,∧(q,∧(¬s,¬z)))&quot;, function_notation=true))
&quot;¬p ∧ q ∧ ¬s ∧ ¬z&quot;

julia&gt; syntaxstring(parseformula(&quot;¬1→0&quot;; atom_parser = (x -&gt; Atom{Float64}(parse(Float64, x)))))
&quot;(¬1.0) → 0.0&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For any <code>Formula</code> type <code>F</code>, this function should be the inverse of <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>; that is, if <code>φ::F</code> then the following should hold, for at least some <code>args</code>, and for every <code>kwargs</code> allowing correct parsing: <code>φ == parseformula(F, syntaxstring(φ, args...; kwargs...), args...; kwargs...)</code>.</p></div></div><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>, <a href="#SoleLogics.BASE_PARSABLE_CONNECTIVES"><code>BASE_PARSABLE_CONNECTIVES</code></a>, <a href="../getting-started/#SoleLogics.syntaxstring-Tuple{Syntactical}"><code>syntaxstring</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/parse.jl#L135-L216">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}" href="#SoleLogics.treewalk-Tuple{SyntaxTree, Vararg{Any}}"><code>SoleLogics.treewalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">treewalk(
    st::SyntaxTree,
    args...;
    rng::AbstractRNG = Random.GLOBAL_RNG,
    criterion::Function = ntokens,
    toleaf::Bool = true,
    returnnode::Bool = false,
    transformnode::Function = nothing
)::SyntaxTree</code></pre><p>Return a subtree of syntax tree, by following these options:</p><ul><li><code>criterion</code>: function used to compute the probability of stopping at a random node;</li><li><code>returnnode</code>: true if only the subtree is to be returned;</li><li><code>transformnode</code>: function that will be applied to the chosen subtree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L359-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.subformulas-Tuple{Formula}" href="#SoleLogics.subformulas-Tuple{Formula}"><code>SoleLogics.subformulas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subformulas(f::Formula; sorted=true)</code></pre><p>Return all sub-formulas (sorted by size when <code>sorted=true</code>) of a given formula.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; syntaxstring.(SoleLogics.subformulas(parseformula(&quot;◊((p∧q)→r)&quot;)))
6-element Vector{String}:
 &quot;p&quot;
 &quot;q&quot;
 &quot;r&quot;
 &quot;p ∧ q&quot;
 &quot;◊(p ∧ q)&quot;
 &quot;(◊(p ∧ q)) → r&quot;</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L431-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.normalize-Tuple{Formula}" href="#SoleLogics.normalize-Tuple{Formula}"><code>SoleLogics.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize(
    f::Formula;
    remove_boxes = true,
    reduce_negations = true,
    allow_atom_flipping = true
)</code></pre><p>Return a modified version of a given formula, that has the same semantics but different syntax. This is useful when dealing with the truth of many (possibly similar) formulas; for example, when performing <a href="https://en.wikipedia.org/wiki/Model_checking">model checking</a>. BEWARE: it currently assumes the underlying algebra is Boolean!</p><p><strong>Arguments</strong></p><ul><li><code>f::Formula</code>: when set to <code>true</code>,   the formula;</li><li><code>remove_boxes::Bool</code>: remove all (non-relational and relational) box operators by using the   equivalence ◊φ ≡ ¬□¬φ. Note: this assumes an underlying Boolean algebra.</li><li><code>reduce_negations::Bool</code>: when set to <code>true</code>,   attempts at reducing the number of negations by appling   some transformation rules   (e.g., <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan&#39;s laws</a>).   Note: this assumes an underlying Boolean algebra.</li><li><code>allow_atom_flipping::Bool</code>: when set to <code>true</code>,   together with <code>reduce_negations=true</code>, this may cause the negation of an atom   to be replaced with the its <a href="../getting-started/#SoleLogics.dual-Tuple{SyntaxToken}"><code>dual</code></a> atom.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;□¬((p∧¬q)→r)∧⊤&quot;);

julia&gt; syntaxstring(f)
&quot;□¬((p ∧ ¬q) → r) ∧ ⊤&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :modelchecking, allow_atom_flipping = false))
&quot;¬◊(q ∨ ¬p ∨ r)&quot;

julia&gt; syntaxstring(SoleLogics.normalize(f; profile = :readability, allow_atom_flipping = false))
&quot;□(¬r ∧ p ∧ ¬q)&quot;</code></pre><p>See also <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L476-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleLogics.isgrounded-Tuple{Formula}" href="#SoleLogics.isgrounded-Tuple{Formula}"><code>SoleLogics.isgrounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isgrounded(f::Formula)::Bool</code></pre><p>Return <code>true</code> if the formula is grounded, that is, if it can be inferred from its syntactic structure that, given any frame-based model, the truth value of the formula is the same on every world.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = parseformula(&quot;⟨G⟩p → [G]q&quot;);

julia&gt; syntaxstring(f)
&quot;(⟨G⟩p) → ([G]q)&quot;

julia&gt; SoleLogics.isgrounded(f)
true</code></pre><p>See also <a href="../modal-logic/#SoleLogics.isgrounding-Tuple{AbstractRelation}"><code>isgrounding</code></a>), <a href="../getting-started/#SoleLogics.SyntaxTree"><code>SyntaxTree</code></a>), <a href="../getting-started/#SoleLogics.Formula"><code>Formula</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleLogics.jl/blob/f2b0cfcccced1e908597984a5585096f5f95f456/src/syntax-utils.jl#L756-L776">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modal-logic/">« Modal Logic</a><a class="docs-footer-nextpage" href="../hands-on/">Hands On »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 1 December 2023 07:20">Friday 1 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
